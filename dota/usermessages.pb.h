// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usermessages.proto

#ifndef PROTOBUF_usermessages_2eproto__INCLUDED
#define PROTOBUF_usermessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networkbasetypes.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
namespace dota {
class CEntityMessageDoSpark;
class CEntityMessageDoSparkDefaultTypeInternal;
extern CEntityMessageDoSparkDefaultTypeInternal _CEntityMessageDoSpark_default_instance_;
class CEntityMessageFixAngle;
class CEntityMessageFixAngleDefaultTypeInternal;
extern CEntityMessageFixAngleDefaultTypeInternal _CEntityMessageFixAngle_default_instance_;
class CEntityMessagePlayJingle;
class CEntityMessagePlayJingleDefaultTypeInternal;
extern CEntityMessagePlayJingleDefaultTypeInternal _CEntityMessagePlayJingle_default_instance_;
class CEntityMessagePropagateForce;
class CEntityMessagePropagateForceDefaultTypeInternal;
extern CEntityMessagePropagateForceDefaultTypeInternal _CEntityMessagePropagateForce_default_instance_;
class CEntityMessageRemoveAllDecals;
class CEntityMessageRemoveAllDecalsDefaultTypeInternal;
extern CEntityMessageRemoveAllDecalsDefaultTypeInternal _CEntityMessageRemoveAllDecals_default_instance_;
class CEntityMessageScreenOverlay;
class CEntityMessageScreenOverlayDefaultTypeInternal;
extern CEntityMessageScreenOverlayDefaultTypeInternal _CEntityMessageScreenOverlay_default_instance_;
class CMsgPlayerInfo;
class CMsgPlayerInfoDefaultTypeInternal;
extern CMsgPlayerInfoDefaultTypeInternal _CMsgPlayerInfo_default_instance_;
class CMsgQAngle;
class CMsgQAngleDefaultTypeInternal;
extern CMsgQAngleDefaultTypeInternal _CMsgQAngle_default_instance_;
class CMsgVector;
class CMsgVectorDefaultTypeInternal;
extern CMsgVectorDefaultTypeInternal _CMsgVector_default_instance_;
class CMsgVector2D;
class CMsgVector2DDefaultTypeInternal;
extern CMsgVector2DDefaultTypeInternal _CMsgVector2D_default_instance_;
class CMsg_CVars;
class CMsg_CVarsDefaultTypeInternal;
extern CMsg_CVarsDefaultTypeInternal _CMsg_CVars_default_instance_;
class CMsg_CVars_CVar;
class CMsg_CVars_CVarDefaultTypeInternal;
extern CMsg_CVars_CVarDefaultTypeInternal _CMsg_CVars_CVar_default_instance_;
class CNETMsg_Disconnect;
class CNETMsg_DisconnectDefaultTypeInternal;
extern CNETMsg_DisconnectDefaultTypeInternal _CNETMsg_Disconnect_default_instance_;
class CNETMsg_NOP;
class CNETMsg_NOPDefaultTypeInternal;
extern CNETMsg_NOPDefaultTypeInternal _CNETMsg_NOP_default_instance_;
class CNETMsg_SetConVar;
class CNETMsg_SetConVarDefaultTypeInternal;
extern CNETMsg_SetConVarDefaultTypeInternal _CNETMsg_SetConVar_default_instance_;
class CNETMsg_SignonState;
class CNETMsg_SignonStateDefaultTypeInternal;
extern CNETMsg_SignonStateDefaultTypeInternal _CNETMsg_SignonState_default_instance_;
class CNETMsg_SpawnGroup_Load;
class CNETMsg_SpawnGroup_LoadDefaultTypeInternal;
extern CNETMsg_SpawnGroup_LoadDefaultTypeInternal _CNETMsg_SpawnGroup_Load_default_instance_;
class CNETMsg_SpawnGroup_LoadCompleted;
class CNETMsg_SpawnGroup_LoadCompletedDefaultTypeInternal;
extern CNETMsg_SpawnGroup_LoadCompletedDefaultTypeInternal _CNETMsg_SpawnGroup_LoadCompleted_default_instance_;
class CNETMsg_SpawnGroup_ManifestUpdate;
class CNETMsg_SpawnGroup_ManifestUpdateDefaultTypeInternal;
extern CNETMsg_SpawnGroup_ManifestUpdateDefaultTypeInternal _CNETMsg_SpawnGroup_ManifestUpdate_default_instance_;
class CNETMsg_SpawnGroup_SetCreationTick;
class CNETMsg_SpawnGroup_SetCreationTickDefaultTypeInternal;
extern CNETMsg_SpawnGroup_SetCreationTickDefaultTypeInternal _CNETMsg_SpawnGroup_SetCreationTick_default_instance_;
class CNETMsg_SpawnGroup_Unload;
class CNETMsg_SpawnGroup_UnloadDefaultTypeInternal;
extern CNETMsg_SpawnGroup_UnloadDefaultTypeInternal _CNETMsg_SpawnGroup_Unload_default_instance_;
class CNETMsg_SplitScreenUser;
class CNETMsg_SplitScreenUserDefaultTypeInternal;
extern CNETMsg_SplitScreenUserDefaultTypeInternal _CNETMsg_SplitScreenUser_default_instance_;
class CNETMsg_StringCmd;
class CNETMsg_StringCmdDefaultTypeInternal;
extern CNETMsg_StringCmdDefaultTypeInternal _CNETMsg_StringCmd_default_instance_;
class CNETMsg_Tick;
class CNETMsg_TickDefaultTypeInternal;
extern CNETMsg_TickDefaultTypeInternal _CNETMsg_Tick_default_instance_;
class CSVCMsgList_GameEvents;
class CSVCMsgList_GameEventsDefaultTypeInternal;
extern CSVCMsgList_GameEventsDefaultTypeInternal _CSVCMsgList_GameEvents_default_instance_;
class CSVCMsgList_GameEvents_event_t;
class CSVCMsgList_GameEvents_event_tDefaultTypeInternal;
extern CSVCMsgList_GameEvents_event_tDefaultTypeInternal _CSVCMsgList_GameEvents_event_t_default_instance_;
class CSVCMsgList_UserMessages;
class CSVCMsgList_UserMessagesDefaultTypeInternal;
extern CSVCMsgList_UserMessagesDefaultTypeInternal _CSVCMsgList_UserMessages_default_instance_;
class CSVCMsgList_UserMessages_usermsg_t;
class CSVCMsgList_UserMessages_usermsg_tDefaultTypeInternal;
extern CSVCMsgList_UserMessages_usermsg_tDefaultTypeInternal _CSVCMsgList_UserMessages_usermsg_t_default_instance_;
class CSVCMsg_GameEvent;
class CSVCMsg_GameEventDefaultTypeInternal;
extern CSVCMsg_GameEventDefaultTypeInternal _CSVCMsg_GameEvent_default_instance_;
class CSVCMsg_GameEvent_key_t;
class CSVCMsg_GameEvent_key_tDefaultTypeInternal;
extern CSVCMsg_GameEvent_key_tDefaultTypeInternal _CSVCMsg_GameEvent_key_t_default_instance_;
class CSVCMsg_GameSessionConfiguration;
class CSVCMsg_GameSessionConfigurationDefaultTypeInternal;
extern CSVCMsg_GameSessionConfigurationDefaultTypeInternal _CSVCMsg_GameSessionConfiguration_default_instance_;
class CSVCMsg_UserMessage;
class CSVCMsg_UserMessageDefaultTypeInternal;
extern CSVCMsg_UserMessageDefaultTypeInternal _CSVCMsg_UserMessage_default_instance_;
class CUserMessageAchievementEvent;
class CUserMessageAchievementEventDefaultTypeInternal;
extern CUserMessageAchievementEventDefaultTypeInternal _CUserMessageAchievementEvent_default_instance_;
class CUserMessageAmmoDenied;
class CUserMessageAmmoDeniedDefaultTypeInternal;
extern CUserMessageAmmoDeniedDefaultTypeInternal _CUserMessageAmmoDenied_default_instance_;
class CUserMessageAnimStateGraphState;
class CUserMessageAnimStateGraphStateDefaultTypeInternal;
extern CUserMessageAnimStateGraphStateDefaultTypeInternal _CUserMessageAnimStateGraphState_default_instance_;
class CUserMessageAudioParameter;
class CUserMessageAudioParameterDefaultTypeInternal;
extern CUserMessageAudioParameterDefaultTypeInternal _CUserMessageAudioParameter_default_instance_;
class CUserMessageCameraTransition;
class CUserMessageCameraTransitionDefaultTypeInternal;
extern CUserMessageCameraTransitionDefaultTypeInternal _CUserMessageCameraTransition_default_instance_;
class CUserMessageCameraTransition_Transition_DataDriven;
class CUserMessageCameraTransition_Transition_DataDrivenDefaultTypeInternal;
extern CUserMessageCameraTransition_Transition_DataDrivenDefaultTypeInternal _CUserMessageCameraTransition_Transition_DataDriven_default_instance_;
class CUserMessageCloseCaption;
class CUserMessageCloseCaptionDefaultTypeInternal;
extern CUserMessageCloseCaptionDefaultTypeInternal _CUserMessageCloseCaption_default_instance_;
class CUserMessageCloseCaptionDirect;
class CUserMessageCloseCaptionDirectDefaultTypeInternal;
extern CUserMessageCloseCaptionDirectDefaultTypeInternal _CUserMessageCloseCaptionDirect_default_instance_;
class CUserMessageCloseCaptionPlaceholder;
class CUserMessageCloseCaptionPlaceholderDefaultTypeInternal;
extern CUserMessageCloseCaptionPlaceholderDefaultTypeInternal _CUserMessageCloseCaptionPlaceholder_default_instance_;
class CUserMessageColoredText;
class CUserMessageColoredTextDefaultTypeInternal;
extern CUserMessageColoredTextDefaultTypeInternal _CUserMessageColoredText_default_instance_;
class CUserMessageCreditsMsg;
class CUserMessageCreditsMsgDefaultTypeInternal;
extern CUserMessageCreditsMsgDefaultTypeInternal _CUserMessageCreditsMsg_default_instance_;
class CUserMessageCrosshairAngle;
class CUserMessageCrosshairAngleDefaultTypeInternal;
extern CUserMessageCrosshairAngleDefaultTypeInternal _CUserMessageCrosshairAngle_default_instance_;
class CUserMessageCurrentTimescale;
class CUserMessageCurrentTimescaleDefaultTypeInternal;
extern CUserMessageCurrentTimescaleDefaultTypeInternal _CUserMessageCurrentTimescale_default_instance_;
class CUserMessageDesiredTimescale;
class CUserMessageDesiredTimescaleDefaultTypeInternal;
extern CUserMessageDesiredTimescaleDefaultTypeInternal _CUserMessageDesiredTimescale_default_instance_;
class CUserMessageFade;
class CUserMessageFadeDefaultTypeInternal;
extern CUserMessageFadeDefaultTypeInternal _CUserMessageFade_default_instance_;
class CUserMessageGameTitle;
class CUserMessageGameTitleDefaultTypeInternal;
extern CUserMessageGameTitleDefaultTypeInternal _CUserMessageGameTitle_default_instance_;
class CUserMessageHapticPulse;
class CUserMessageHapticPulseDefaultTypeInternal;
extern CUserMessageHapticPulseDefaultTypeInternal _CUserMessageHapticPulse_default_instance_;
class CUserMessageHapticPulsePrecise;
class CUserMessageHapticPulsePreciseDefaultTypeInternal;
extern CUserMessageHapticPulsePreciseDefaultTypeInternal _CUserMessageHapticPulsePrecise_default_instance_;
class CUserMessageHintText;
class CUserMessageHintTextDefaultTypeInternal;
extern CUserMessageHintTextDefaultTypeInternal _CUserMessageHintText_default_instance_;
class CUserMessageHudMsg;
class CUserMessageHudMsgDefaultTypeInternal;
extern CUserMessageHudMsgDefaultTypeInternal _CUserMessageHudMsg_default_instance_;
class CUserMessageHudText;
class CUserMessageHudTextDefaultTypeInternal;
extern CUserMessageHudTextDefaultTypeInternal _CUserMessageHudText_default_instance_;
class CUserMessageItemPickup;
class CUserMessageItemPickupDefaultTypeInternal;
extern CUserMessageItemPickupDefaultTypeInternal _CUserMessageItemPickup_default_instance_;
class CUserMessageKeyHintText;
class CUserMessageKeyHintTextDefaultTypeInternal;
extern CUserMessageKeyHintTextDefaultTypeInternal _CUserMessageKeyHintText_default_instance_;
class CUserMessageRequestState;
class CUserMessageRequestStateDefaultTypeInternal;
extern CUserMessageRequestStateDefaultTypeInternal _CUserMessageRequestState_default_instance_;
class CUserMessageResetHUD;
class CUserMessageResetHUDDefaultTypeInternal;
extern CUserMessageResetHUDDefaultTypeInternal _CUserMessageResetHUD_default_instance_;
class CUserMessageRumble;
class CUserMessageRumbleDefaultTypeInternal;
extern CUserMessageRumbleDefaultTypeInternal _CUserMessageRumble_default_instance_;
class CUserMessageSayText;
class CUserMessageSayTextDefaultTypeInternal;
extern CUserMessageSayTextDefaultTypeInternal _CUserMessageSayText_default_instance_;
class CUserMessageSayText2;
class CUserMessageSayText2DefaultTypeInternal;
extern CUserMessageSayText2DefaultTypeInternal _CUserMessageSayText2_default_instance_;
class CUserMessageSayTextChannel;
class CUserMessageSayTextChannelDefaultTypeInternal;
extern CUserMessageSayTextChannelDefaultTypeInternal _CUserMessageSayTextChannel_default_instance_;
class CUserMessageScreenTilt;
class CUserMessageScreenTiltDefaultTypeInternal;
extern CUserMessageScreenTiltDefaultTypeInternal _CUserMessageScreenTilt_default_instance_;
class CUserMessageSendAudio;
class CUserMessageSendAudioDefaultTypeInternal;
extern CUserMessageSendAudioDefaultTypeInternal _CUserMessageSendAudio_default_instance_;
class CUserMessageShake;
class CUserMessageShakeDefaultTypeInternal;
extern CUserMessageShakeDefaultTypeInternal _CUserMessageShake_default_instance_;
class CUserMessageShakeDir;
class CUserMessageShakeDirDefaultTypeInternal;
extern CUserMessageShakeDirDefaultTypeInternal _CUserMessageShakeDir_default_instance_;
class CUserMessageShowMenu;
class CUserMessageShowMenuDefaultTypeInternal;
extern CUserMessageShowMenuDefaultTypeInternal _CUserMessageShowMenu_default_instance_;
class CUserMessageTextMsg;
class CUserMessageTextMsgDefaultTypeInternal;
extern CUserMessageTextMsgDefaultTypeInternal _CUserMessageTextMsg_default_instance_;
class CUserMessageTrain;
class CUserMessageTrainDefaultTypeInternal;
extern CUserMessageTrainDefaultTypeInternal _CUserMessageTrain_default_instance_;
class CUserMessageVGUIMenu;
class CUserMessageVGUIMenuDefaultTypeInternal;
extern CUserMessageVGUIMenuDefaultTypeInternal _CUserMessageVGUIMenu_default_instance_;
class CUserMessageVGUIMenu_Keys;
class CUserMessageVGUIMenu_KeysDefaultTypeInternal;
extern CUserMessageVGUIMenu_KeysDefaultTypeInternal _CUserMessageVGUIMenu_Keys_default_instance_;
class CUserMessageVoiceMask;
class CUserMessageVoiceMaskDefaultTypeInternal;
extern CUserMessageVoiceMaskDefaultTypeInternal _CUserMessageVoiceMask_default_instance_;
class CUserMessageVoiceSubtitle;
class CUserMessageVoiceSubtitleDefaultTypeInternal;
extern CUserMessageVoiceSubtitleDefaultTypeInternal _CUserMessageVoiceSubtitle_default_instance_;
class CUserMsg_CustomGameEvent;
class CUserMsg_CustomGameEventDefaultTypeInternal;
extern CUserMsg_CustomGameEventDefaultTypeInternal _CUserMsg_CustomGameEvent_default_instance_;
class CUserMsg_HudError;
class CUserMsg_HudErrorDefaultTypeInternal;
extern CUserMsg_HudErrorDefaultTypeInternal _CUserMsg_HudError_default_instance_;
class CUserMsg_ParticleManager;
class CUserMsg_ParticleManagerDefaultTypeInternal;
extern CUserMsg_ParticleManagerDefaultTypeInternal _CUserMsg_ParticleManager_default_instance_;
class CUserMsg_ParticleManager_ChangeControlPointAttachment;
class CUserMsg_ParticleManager_ChangeControlPointAttachmentDefaultTypeInternal;
extern CUserMsg_ParticleManager_ChangeControlPointAttachmentDefaultTypeInternal _CUserMsg_ParticleManager_ChangeControlPointAttachment_default_instance_;
class CUserMsg_ParticleManager_CreateParticle;
class CUserMsg_ParticleManager_CreateParticleDefaultTypeInternal;
extern CUserMsg_ParticleManager_CreateParticleDefaultTypeInternal _CUserMsg_ParticleManager_CreateParticle_default_instance_;
class CUserMsg_ParticleManager_DestroyParticle;
class CUserMsg_ParticleManager_DestroyParticleDefaultTypeInternal;
extern CUserMsg_ParticleManager_DestroyParticleDefaultTypeInternal _CUserMsg_ParticleManager_DestroyParticle_default_instance_;
class CUserMsg_ParticleManager_DestroyParticleInvolving;
class CUserMsg_ParticleManager_DestroyParticleInvolvingDefaultTypeInternal;
extern CUserMsg_ParticleManager_DestroyParticleInvolvingDefaultTypeInternal _CUserMsg_ParticleManager_DestroyParticleInvolving_default_instance_;
class CUserMsg_ParticleManager_ReleaseParticleIndex;
class CUserMsg_ParticleManager_ReleaseParticleIndexDefaultTypeInternal;
extern CUserMsg_ParticleManager_ReleaseParticleIndexDefaultTypeInternal _CUserMsg_ParticleManager_ReleaseParticleIndex_default_instance_;
class CUserMsg_ParticleManager_UpdateParticle;
class CUserMsg_ParticleManager_UpdateParticleDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticle_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleEnt;
class CUserMsg_ParticleManager_UpdateParticleEntDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleEntDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleEnt_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleFallback;
class CUserMsg_ParticleManager_UpdateParticleFallbackDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleFallbackDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleFallback_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleFwd;
class CUserMsg_ParticleManager_UpdateParticleFwdDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleFwdDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleFwd_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleOffset;
class CUserMsg_ParticleManager_UpdateParticleOffsetDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleOffsetDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleOffset_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleOrient;
class CUserMsg_ParticleManager_UpdateParticleOrientDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleOrientDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleOrient_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleSetFrozen;
class CUserMsg_ParticleManager_UpdateParticleSetFrozenDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleSetFrozenDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleSetFrozen_default_instance_;
class CUserMsg_ParticleManager_UpdateParticleShouldDraw;
class CUserMsg_ParticleManager_UpdateParticleShouldDrawDefaultTypeInternal;
extern CUserMsg_ParticleManager_UpdateParticleShouldDrawDefaultTypeInternal _CUserMsg_ParticleManager_UpdateParticleShouldDraw_default_instance_;
}  // namespace dota
}  // namespace proto

namespace proto {
namespace dota {

namespace protobuf_usermessages_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_usermessages_2eproto

enum EBaseUserMessages {
  UM_AchievementEvent = 101,
  UM_CloseCaption = 102,
  UM_CloseCaptionDirect = 103,
  UM_CurrentTimescale = 104,
  UM_DesiredTimescale = 105,
  UM_Fade = 106,
  UM_GameTitle = 107,
  UM_HintText = 109,
  UM_HudMsg = 110,
  UM_HudText = 111,
  UM_KeyHintText = 112,
  UM_ColoredText = 113,
  UM_RequestState = 114,
  UM_ResetHUD = 115,
  UM_Rumble = 116,
  UM_SayText = 117,
  UM_SayText2 = 118,
  UM_SayTextChannel = 119,
  UM_Shake = 120,
  UM_ShakeDir = 121,
  UM_TextMsg = 124,
  UM_ScreenTilt = 125,
  UM_Train = 126,
  UM_VGUIMenu = 127,
  UM_VoiceMask = 128,
  UM_VoiceSubtitle = 129,
  UM_SendAudio = 130,
  UM_ItemPickup = 131,
  UM_AmmoDenied = 132,
  UM_CrosshairAngle = 133,
  UM_ShowMenu = 134,
  UM_CreditsMsg = 135,
  UM_CloseCaptionPlaceholder = 142,
  UM_CameraTransition = 143,
  UM_AudioParameter = 144,
  UM_ParticleManager = 145,
  UM_HudError = 146,
  UM_CustomGameEvent = 148,
  UM_HandHapticPulse = 149,
  UM_AnimGraphUpdate = 150,
  UM_HandHapticPulsePrecise = 151,
  UM_MAX_BASE = 200
};
bool EBaseUserMessages_IsValid(int value);
const EBaseUserMessages EBaseUserMessages_MIN = UM_AchievementEvent;
const EBaseUserMessages EBaseUserMessages_MAX = UM_MAX_BASE;
const int EBaseUserMessages_ARRAYSIZE = EBaseUserMessages_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBaseUserMessages_descriptor();
inline const ::std::string& EBaseUserMessages_Name(EBaseUserMessages value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBaseUserMessages_descriptor(), value);
}
inline bool EBaseUserMessages_Parse(
    const ::std::string& name, EBaseUserMessages* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBaseUserMessages>(
    EBaseUserMessages_descriptor(), name, value);
}
enum EBaseEntityMessages {
  EM_PlayJingle = 136,
  EM_ScreenOverlay = 137,
  EM_RemoveAllDecals = 138,
  EM_PropagateForce = 139,
  EM_DoSpark = 140,
  EM_FixAngle = 141
};
bool EBaseEntityMessages_IsValid(int value);
const EBaseEntityMessages EBaseEntityMessages_MIN = EM_PlayJingle;
const EBaseEntityMessages EBaseEntityMessages_MAX = EM_FixAngle;
const int EBaseEntityMessages_ARRAYSIZE = EBaseEntityMessages_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBaseEntityMessages_descriptor();
inline const ::std::string& EBaseEntityMessages_Name(EBaseEntityMessages value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBaseEntityMessages_descriptor(), value);
}
inline bool EBaseEntityMessages_Parse(
    const ::std::string& name, EBaseEntityMessages* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBaseEntityMessages>(
    EBaseEntityMessages_descriptor(), name, value);
}
enum eRollType {
  ROLL_NONE = -1,
  ROLL_STATS = 0,
  ROLL_CREDITS = 1,
  ROLL_LATE_JOIN_LOGO = 2,
  ROLL_OUTTRO = 3
};
bool eRollType_IsValid(int value);
const eRollType eRollType_MIN = ROLL_NONE;
const eRollType eRollType_MAX = ROLL_OUTTRO;
const int eRollType_ARRAYSIZE = eRollType_MAX + 1;

const ::google::protobuf::EnumDescriptor* eRollType_descriptor();
inline const ::std::string& eRollType_Name(eRollType value) {
  return ::google::protobuf::internal::NameOfEnum(
    eRollType_descriptor(), value);
}
inline bool eRollType_Parse(
    const ::std::string& name, eRollType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eRollType>(
    eRollType_descriptor(), name, value);
}
enum PARTICLE_MESSAGE {
  GAME_PARTICLE_MANAGER_EVENT_CREATE = 0,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE = 1,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6,
  GAME_PARTICLE_MANAGER_EVENT_DESTROY = 7,
  GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8,
  GAME_PARTICLE_MANAGER_EVENT_RELEASE = 9,
  GAME_PARTICLE_MANAGER_EVENT_LATENCY = 10,
  GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW = 11,
  GAME_PARTICLE_MANAGER_EVENT_FROZEN = 12,
  GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT = 13
};
bool PARTICLE_MESSAGE_IsValid(int value);
const PARTICLE_MESSAGE PARTICLE_MESSAGE_MIN = GAME_PARTICLE_MANAGER_EVENT_CREATE;
const PARTICLE_MESSAGE PARTICLE_MESSAGE_MAX = GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT;
const int PARTICLE_MESSAGE_ARRAYSIZE = PARTICLE_MESSAGE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PARTICLE_MESSAGE_descriptor();
inline const ::std::string& PARTICLE_MESSAGE_Name(PARTICLE_MESSAGE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PARTICLE_MESSAGE_descriptor(), value);
}
inline bool PARTICLE_MESSAGE_Parse(
    const ::std::string& name, PARTICLE_MESSAGE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PARTICLE_MESSAGE>(
    PARTICLE_MESSAGE_descriptor(), name, value);
}
enum EHapticPulseType {
  VR_HAND_HAPTIC_PULSE_LIGHT = 0,
  VR_HAND_HAPTIC_PULSE_MEDIUM = 1,
  VR_HAND_HAPTIC_PULSE_STRONG = 2
};
bool EHapticPulseType_IsValid(int value);
const EHapticPulseType EHapticPulseType_MIN = VR_HAND_HAPTIC_PULSE_LIGHT;
const EHapticPulseType EHapticPulseType_MAX = VR_HAND_HAPTIC_PULSE_STRONG;
const int EHapticPulseType_ARRAYSIZE = EHapticPulseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHapticPulseType_descriptor();
inline const ::std::string& EHapticPulseType_Name(EHapticPulseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHapticPulseType_descriptor(), value);
}
inline bool EHapticPulseType_Parse(
    const ::std::string& name, EHapticPulseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHapticPulseType>(
    EHapticPulseType_descriptor(), name, value);
}
// ===================================================================

class CUserMessageAchievementEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageAchievementEvent) */ {
 public:
  CUserMessageAchievementEvent();
  virtual ~CUserMessageAchievementEvent();

  CUserMessageAchievementEvent(const CUserMessageAchievementEvent& from);

  inline CUserMessageAchievementEvent& operator=(const CUserMessageAchievementEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageAchievementEvent& default_instance();

  static inline const CUserMessageAchievementEvent* internal_default_instance() {
    return reinterpret_cast<const CUserMessageAchievementEvent*>(
               &_CUserMessageAchievementEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CUserMessageAchievementEvent* other);

  // implements Message ----------------------------------------------

  inline CUserMessageAchievementEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageAchievementEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageAchievementEvent& from);
  void MergeFrom(const CUserMessageAchievementEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageAchievementEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 achievement = 1;
  bool has_achievement() const;
  void clear_achievement();
  static const int kAchievementFieldNumber = 1;
  ::google::protobuf::uint32 achievement() const;
  void set_achievement(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageAchievementEvent)
 private:
  void set_has_achievement();
  void clear_has_achievement();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 achievement_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCloseCaption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCloseCaption) */ {
 public:
  CUserMessageCloseCaption();
  virtual ~CUserMessageCloseCaption();

  CUserMessageCloseCaption(const CUserMessageCloseCaption& from);

  inline CUserMessageCloseCaption& operator=(const CUserMessageCloseCaption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCloseCaption& default_instance();

  static inline const CUserMessageCloseCaption* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCloseCaption*>(
               &_CUserMessageCloseCaption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CUserMessageCloseCaption* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCloseCaption* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCloseCaption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCloseCaption& from);
  void MergeFrom(const CUserMessageCloseCaption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCloseCaption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // optional float duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  float duration() const;
  void set_duration(float value);

  // optional bool from_player = 3;
  bool has_from_player() const;
  void clear_from_player();
  static const int kFromPlayerFieldNumber = 3;
  bool from_player() const;
  void set_from_player(bool value);

  // optional int32 ent_index = 4;
  bool has_ent_index() const;
  void clear_ent_index();
  static const int kEntIndexFieldNumber = 4;
  ::google::protobuf::int32 ent_index() const;
  void set_ent_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCloseCaption)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_duration();
  void clear_has_duration();
  void set_has_from_player();
  void clear_has_from_player();
  void set_has_ent_index();
  void clear_has_ent_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 hash_;
  float duration_;
  bool from_player_;
  ::google::protobuf::int32 ent_index_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCloseCaptionDirect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCloseCaptionDirect) */ {
 public:
  CUserMessageCloseCaptionDirect();
  virtual ~CUserMessageCloseCaptionDirect();

  CUserMessageCloseCaptionDirect(const CUserMessageCloseCaptionDirect& from);

  inline CUserMessageCloseCaptionDirect& operator=(const CUserMessageCloseCaptionDirect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCloseCaptionDirect& default_instance();

  static inline const CUserMessageCloseCaptionDirect* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCloseCaptionDirect*>(
               &_CUserMessageCloseCaptionDirect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CUserMessageCloseCaptionDirect* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCloseCaptionDirect* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCloseCaptionDirect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCloseCaptionDirect& from);
  void MergeFrom(const CUserMessageCloseCaptionDirect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCloseCaptionDirect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // optional float duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  float duration() const;
  void set_duration(float value);

  // optional bool from_player = 3;
  bool has_from_player() const;
  void clear_from_player();
  static const int kFromPlayerFieldNumber = 3;
  bool from_player() const;
  void set_from_player(bool value);

  // optional int32 ent_index = 4;
  bool has_ent_index() const;
  void clear_ent_index();
  static const int kEntIndexFieldNumber = 4;
  ::google::protobuf::int32 ent_index() const;
  void set_ent_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCloseCaptionDirect)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_duration();
  void clear_has_duration();
  void set_has_from_player();
  void clear_has_from_player();
  void set_has_ent_index();
  void clear_has_ent_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 hash_;
  float duration_;
  bool from_player_;
  ::google::protobuf::int32 ent_index_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCloseCaptionPlaceholder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCloseCaptionPlaceholder) */ {
 public:
  CUserMessageCloseCaptionPlaceholder();
  virtual ~CUserMessageCloseCaptionPlaceholder();

  CUserMessageCloseCaptionPlaceholder(const CUserMessageCloseCaptionPlaceholder& from);

  inline CUserMessageCloseCaptionPlaceholder& operator=(const CUserMessageCloseCaptionPlaceholder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCloseCaptionPlaceholder& default_instance();

  static inline const CUserMessageCloseCaptionPlaceholder* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCloseCaptionPlaceholder*>(
               &_CUserMessageCloseCaptionPlaceholder_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CUserMessageCloseCaptionPlaceholder* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCloseCaptionPlaceholder* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCloseCaptionPlaceholder* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCloseCaptionPlaceholder& from);
  void MergeFrom(const CUserMessageCloseCaptionPlaceholder& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCloseCaptionPlaceholder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string string = 1;
  bool has_string() const;
  void clear_string();
  static const int kStringFieldNumber = 1;
  const ::std::string& string() const;
  void set_string(const ::std::string& value);
  #if LANG_CXX11
  void set_string(::std::string&& value);
  #endif
  void set_string(const char* value);
  void set_string(const char* value, size_t size);
  ::std::string* mutable_string();
  ::std::string* release_string();
  void set_allocated_string(::std::string* string);

  // optional float duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  float duration() const;
  void set_duration(float value);

  // optional bool from_player = 3;
  bool has_from_player() const;
  void clear_from_player();
  static const int kFromPlayerFieldNumber = 3;
  bool from_player() const;
  void set_from_player(bool value);

  // optional int32 ent_index = 4;
  bool has_ent_index() const;
  void clear_ent_index();
  static const int kEntIndexFieldNumber = 4;
  ::google::protobuf::int32 ent_index() const;
  void set_ent_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCloseCaptionPlaceholder)
 private:
  void set_has_string();
  void clear_has_string();
  void set_has_duration();
  void clear_has_duration();
  void set_has_from_player();
  void clear_has_from_player();
  void set_has_ent_index();
  void clear_has_ent_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr string_;
  float duration_;
  bool from_player_;
  ::google::protobuf::int32 ent_index_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCurrentTimescale : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCurrentTimescale) */ {
 public:
  CUserMessageCurrentTimescale();
  virtual ~CUserMessageCurrentTimescale();

  CUserMessageCurrentTimescale(const CUserMessageCurrentTimescale& from);

  inline CUserMessageCurrentTimescale& operator=(const CUserMessageCurrentTimescale& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCurrentTimescale& default_instance();

  static inline const CUserMessageCurrentTimescale* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCurrentTimescale*>(
               &_CUserMessageCurrentTimescale_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CUserMessageCurrentTimescale* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCurrentTimescale* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCurrentTimescale* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCurrentTimescale& from);
  void MergeFrom(const CUserMessageCurrentTimescale& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCurrentTimescale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float current = 1;
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 1;
  float current() const;
  void set_current(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCurrentTimescale)
 private:
  void set_has_current();
  void clear_has_current();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float current_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageDesiredTimescale : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageDesiredTimescale) */ {
 public:
  CUserMessageDesiredTimescale();
  virtual ~CUserMessageDesiredTimescale();

  CUserMessageDesiredTimescale(const CUserMessageDesiredTimescale& from);

  inline CUserMessageDesiredTimescale& operator=(const CUserMessageDesiredTimescale& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageDesiredTimescale& default_instance();

  static inline const CUserMessageDesiredTimescale* internal_default_instance() {
    return reinterpret_cast<const CUserMessageDesiredTimescale*>(
               &_CUserMessageDesiredTimescale_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CUserMessageDesiredTimescale* other);

  // implements Message ----------------------------------------------

  inline CUserMessageDesiredTimescale* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageDesiredTimescale* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageDesiredTimescale& from);
  void MergeFrom(const CUserMessageDesiredTimescale& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageDesiredTimescale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float desired = 1;
  bool has_desired() const;
  void clear_desired();
  static const int kDesiredFieldNumber = 1;
  float desired() const;
  void set_desired(float value);

  // optional float acceleration = 2;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 2;
  float acceleration() const;
  void set_acceleration(float value);

  // optional float minblendrate = 3;
  bool has_minblendrate() const;
  void clear_minblendrate();
  static const int kMinblendrateFieldNumber = 3;
  float minblendrate() const;
  void set_minblendrate(float value);

  // optional float blenddeltamultiplier = 4;
  bool has_blenddeltamultiplier() const;
  void clear_blenddeltamultiplier();
  static const int kBlenddeltamultiplierFieldNumber = 4;
  float blenddeltamultiplier() const;
  void set_blenddeltamultiplier(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageDesiredTimescale)
 private:
  void set_has_desired();
  void clear_has_desired();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_minblendrate();
  void clear_has_minblendrate();
  void set_has_blenddeltamultiplier();
  void clear_has_blenddeltamultiplier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float desired_;
  float acceleration_;
  float minblendrate_;
  float blenddeltamultiplier_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageFade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageFade) */ {
 public:
  CUserMessageFade();
  virtual ~CUserMessageFade();

  CUserMessageFade(const CUserMessageFade& from);

  inline CUserMessageFade& operator=(const CUserMessageFade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageFade& default_instance();

  static inline const CUserMessageFade* internal_default_instance() {
    return reinterpret_cast<const CUserMessageFade*>(
               &_CUserMessageFade_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CUserMessageFade* other);

  // implements Message ----------------------------------------------

  inline CUserMessageFade* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageFade* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageFade& from);
  void MergeFrom(const CUserMessageFade& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageFade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 duration = 1;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // optional uint32 hold_time = 2;
  bool has_hold_time() const;
  void clear_hold_time();
  static const int kHoldTimeFieldNumber = 2;
  ::google::protobuf::uint32 hold_time() const;
  void set_hold_time(::google::protobuf::uint32 value);

  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional fixed32 color = 4;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 4;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageFade)
 private:
  void set_has_duration();
  void clear_has_duration();
  void set_has_hold_time();
  void clear_has_hold_time();
  void set_has_flags();
  void clear_has_flags();
  void set_has_color();
  void clear_has_color();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 hold_time_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 color_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageShake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageShake) */ {
 public:
  CUserMessageShake();
  virtual ~CUserMessageShake();

  CUserMessageShake(const CUserMessageShake& from);

  inline CUserMessageShake& operator=(const CUserMessageShake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageShake& default_instance();

  static inline const CUserMessageShake* internal_default_instance() {
    return reinterpret_cast<const CUserMessageShake*>(
               &_CUserMessageShake_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(CUserMessageShake* other);

  // implements Message ----------------------------------------------

  inline CUserMessageShake* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageShake* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageShake& from);
  void MergeFrom(const CUserMessageShake& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageShake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::google::protobuf::uint32 command() const;
  void set_command(::google::protobuf::uint32 value);

  // optional float amplitude = 2;
  bool has_amplitude() const;
  void clear_amplitude();
  static const int kAmplitudeFieldNumber = 2;
  float amplitude() const;
  void set_amplitude(float value);

  // optional float frequency = 3;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  float frequency() const;
  void set_frequency(float value);

  // optional float duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageShake)
 private:
  void set_has_command();
  void clear_has_command();
  void set_has_amplitude();
  void clear_has_amplitude();
  void set_has_frequency();
  void clear_has_frequency();
  void set_has_duration();
  void clear_has_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 command_;
  float amplitude_;
  float frequency_;
  float duration_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageShakeDir : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageShakeDir) */ {
 public:
  CUserMessageShakeDir();
  virtual ~CUserMessageShakeDir();

  CUserMessageShakeDir(const CUserMessageShakeDir& from);

  inline CUserMessageShakeDir& operator=(const CUserMessageShakeDir& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageShakeDir& default_instance();

  static inline const CUserMessageShakeDir* internal_default_instance() {
    return reinterpret_cast<const CUserMessageShakeDir*>(
               &_CUserMessageShakeDir_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CUserMessageShakeDir* other);

  // implements Message ----------------------------------------------

  inline CUserMessageShakeDir* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageShakeDir* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageShakeDir& from);
  void MergeFrom(const CUserMessageShakeDir& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageShakeDir* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CUserMessageShake shake = 1;
  bool has_shake() const;
  void clear_shake();
  static const int kShakeFieldNumber = 1;
  const ::proto::dota::CUserMessageShake& shake() const;
  ::proto::dota::CUserMessageShake* mutable_shake();
  ::proto::dota::CUserMessageShake* release_shake();
  void set_allocated_shake(::proto::dota::CUserMessageShake* shake);

  // optional .proto.dota.CMsgVector direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  const ::proto::dota::CMsgVector& direction() const;
  ::proto::dota::CMsgVector* mutable_direction();
  ::proto::dota::CMsgVector* release_direction();
  void set_allocated_direction(::proto::dota::CMsgVector* direction);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageShakeDir)
 private:
  void set_has_shake();
  void clear_has_shake();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CUserMessageShake* shake_;
  ::proto::dota::CMsgVector* direction_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageScreenTilt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageScreenTilt) */ {
 public:
  CUserMessageScreenTilt();
  virtual ~CUserMessageScreenTilt();

  CUserMessageScreenTilt(const CUserMessageScreenTilt& from);

  inline CUserMessageScreenTilt& operator=(const CUserMessageScreenTilt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageScreenTilt& default_instance();

  static inline const CUserMessageScreenTilt* internal_default_instance() {
    return reinterpret_cast<const CUserMessageScreenTilt*>(
               &_CUserMessageScreenTilt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CUserMessageScreenTilt* other);

  // implements Message ----------------------------------------------

  inline CUserMessageScreenTilt* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageScreenTilt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageScreenTilt& from);
  void MergeFrom(const CUserMessageScreenTilt& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageScreenTilt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector angle = 3;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 3;
  const ::proto::dota::CMsgVector& angle() const;
  ::proto::dota::CMsgVector* mutable_angle();
  ::proto::dota::CMsgVector* release_angle();
  void set_allocated_angle(::proto::dota::CMsgVector* angle);

  // optional uint32 command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::google::protobuf::uint32 command() const;
  void set_command(::google::protobuf::uint32 value);

  // optional bool ease_in_out = 2;
  bool has_ease_in_out() const;
  void clear_ease_in_out();
  static const int kEaseInOutFieldNumber = 2;
  bool ease_in_out() const;
  void set_ease_in_out(bool value);

  // optional float duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // optional float time = 5;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 5;
  float time() const;
  void set_time(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageScreenTilt)
 private:
  void set_has_command();
  void clear_has_command();
  void set_has_ease_in_out();
  void clear_has_ease_in_out();
  void set_has_angle();
  void clear_has_angle();
  void set_has_duration();
  void clear_has_duration();
  void set_has_time();
  void clear_has_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* angle_;
  ::google::protobuf::uint32 command_;
  bool ease_in_out_;
  float duration_;
  float time_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageSayText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageSayText) */ {
 public:
  CUserMessageSayText();
  virtual ~CUserMessageSayText();

  CUserMessageSayText(const CUserMessageSayText& from);

  inline CUserMessageSayText& operator=(const CUserMessageSayText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageSayText& default_instance();

  static inline const CUserMessageSayText* internal_default_instance() {
    return reinterpret_cast<const CUserMessageSayText*>(
               &_CUserMessageSayText_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(CUserMessageSayText* other);

  // implements Message ----------------------------------------------

  inline CUserMessageSayText* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageSayText* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageSayText& from);
  void MergeFrom(const CUserMessageSayText& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageSayText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 playerindex = 1;
  bool has_playerindex() const;
  void clear_playerindex();
  static const int kPlayerindexFieldNumber = 1;
  ::google::protobuf::uint32 playerindex() const;
  void set_playerindex(::google::protobuf::uint32 value);

  // optional bool chat = 3;
  bool has_chat() const;
  void clear_chat();
  static const int kChatFieldNumber = 3;
  bool chat() const;
  void set_chat(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageSayText)
 private:
  void set_has_playerindex();
  void clear_has_playerindex();
  void set_has_text();
  void clear_has_text();
  void set_has_chat();
  void clear_has_chat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 playerindex_;
  bool chat_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageSayText2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageSayText2) */ {
 public:
  CUserMessageSayText2();
  virtual ~CUserMessageSayText2();

  CUserMessageSayText2(const CUserMessageSayText2& from);

  inline CUserMessageSayText2& operator=(const CUserMessageSayText2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageSayText2& default_instance();

  static inline const CUserMessageSayText2* internal_default_instance() {
    return reinterpret_cast<const CUserMessageSayText2*>(
               &_CUserMessageSayText2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CUserMessageSayText2* other);

  // implements Message ----------------------------------------------

  inline CUserMessageSayText2* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageSayText2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageSayText2& from);
  void MergeFrom(const CUserMessageSayText2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageSayText2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string messagename = 3;
  bool has_messagename() const;
  void clear_messagename();
  static const int kMessagenameFieldNumber = 3;
  const ::std::string& messagename() const;
  void set_messagename(const ::std::string& value);
  #if LANG_CXX11
  void set_messagename(::std::string&& value);
  #endif
  void set_messagename(const char* value);
  void set_messagename(const char* value, size_t size);
  ::std::string* mutable_messagename();
  ::std::string* release_messagename();
  void set_allocated_messagename(::std::string* messagename);

  // optional string param1 = 4;
  bool has_param1() const;
  void clear_param1();
  static const int kParam1FieldNumber = 4;
  const ::std::string& param1() const;
  void set_param1(const ::std::string& value);
  #if LANG_CXX11
  void set_param1(::std::string&& value);
  #endif
  void set_param1(const char* value);
  void set_param1(const char* value, size_t size);
  ::std::string* mutable_param1();
  ::std::string* release_param1();
  void set_allocated_param1(::std::string* param1);

  // optional string param2 = 5;
  bool has_param2() const;
  void clear_param2();
  static const int kParam2FieldNumber = 5;
  const ::std::string& param2() const;
  void set_param2(const ::std::string& value);
  #if LANG_CXX11
  void set_param2(::std::string&& value);
  #endif
  void set_param2(const char* value);
  void set_param2(const char* value, size_t size);
  ::std::string* mutable_param2();
  ::std::string* release_param2();
  void set_allocated_param2(::std::string* param2);

  // optional string param3 = 6;
  bool has_param3() const;
  void clear_param3();
  static const int kParam3FieldNumber = 6;
  const ::std::string& param3() const;
  void set_param3(const ::std::string& value);
  #if LANG_CXX11
  void set_param3(::std::string&& value);
  #endif
  void set_param3(const char* value);
  void set_param3(const char* value, size_t size);
  ::std::string* mutable_param3();
  ::std::string* release_param3();
  void set_allocated_param3(::std::string* param3);

  // optional string param4 = 7;
  bool has_param4() const;
  void clear_param4();
  static const int kParam4FieldNumber = 7;
  const ::std::string& param4() const;
  void set_param4(const ::std::string& value);
  #if LANG_CXX11
  void set_param4(::std::string&& value);
  #endif
  void set_param4(const char* value);
  void set_param4(const char* value, size_t size);
  ::std::string* mutable_param4();
  ::std::string* release_param4();
  void set_allocated_param4(::std::string* param4);

  // optional uint32 entityindex = 1;
  bool has_entityindex() const;
  void clear_entityindex();
  static const int kEntityindexFieldNumber = 1;
  ::google::protobuf::uint32 entityindex() const;
  void set_entityindex(::google::protobuf::uint32 value);

  // optional bool chat = 2;
  bool has_chat() const;
  void clear_chat();
  static const int kChatFieldNumber = 2;
  bool chat() const;
  void set_chat(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageSayText2)
 private:
  void set_has_entityindex();
  void clear_has_entityindex();
  void set_has_chat();
  void clear_has_chat();
  void set_has_messagename();
  void clear_has_messagename();
  void set_has_param1();
  void clear_has_param1();
  void set_has_param2();
  void clear_has_param2();
  void set_has_param3();
  void clear_has_param3();
  void set_has_param4();
  void clear_has_param4();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagename_;
  ::google::protobuf::internal::ArenaStringPtr param1_;
  ::google::protobuf::internal::ArenaStringPtr param2_;
  ::google::protobuf::internal::ArenaStringPtr param3_;
  ::google::protobuf::internal::ArenaStringPtr param4_;
  ::google::protobuf::uint32 entityindex_;
  bool chat_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageHudMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageHudMsg) */ {
 public:
  CUserMessageHudMsg();
  virtual ~CUserMessageHudMsg();

  CUserMessageHudMsg(const CUserMessageHudMsg& from);

  inline CUserMessageHudMsg& operator=(const CUserMessageHudMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageHudMsg& default_instance();

  static inline const CUserMessageHudMsg* internal_default_instance() {
    return reinterpret_cast<const CUserMessageHudMsg*>(
               &_CUserMessageHudMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CUserMessageHudMsg* other);

  // implements Message ----------------------------------------------

  inline CUserMessageHudMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageHudMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageHudMsg& from);
  void MergeFrom(const CUserMessageHudMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageHudMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 11;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 11;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional float x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // optional float y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // optional fixed32 color1 = 4;
  bool has_color1() const;
  void clear_color1();
  static const int kColor1FieldNumber = 4;
  ::google::protobuf::uint32 color1() const;
  void set_color1(::google::protobuf::uint32 value);

  // optional fixed32 color2 = 5;
  bool has_color2() const;
  void clear_color2();
  static const int kColor2FieldNumber = 5;
  ::google::protobuf::uint32 color2() const;
  void set_color2(::google::protobuf::uint32 value);

  // optional uint32 effect = 6;
  bool has_effect() const;
  void clear_effect();
  static const int kEffectFieldNumber = 6;
  ::google::protobuf::uint32 effect() const;
  void set_effect(::google::protobuf::uint32 value);

  // optional float fade_in_time = 7;
  bool has_fade_in_time() const;
  void clear_fade_in_time();
  static const int kFadeInTimeFieldNumber = 7;
  float fade_in_time() const;
  void set_fade_in_time(float value);

  // optional float fade_out_time = 8;
  bool has_fade_out_time() const;
  void clear_fade_out_time();
  static const int kFadeOutTimeFieldNumber = 8;
  float fade_out_time() const;
  void set_fade_out_time(float value);

  // optional float hold_time = 9;
  bool has_hold_time() const;
  void clear_hold_time();
  static const int kHoldTimeFieldNumber = 9;
  float hold_time() const;
  void set_hold_time(float value);

  // optional float fx_time = 10;
  bool has_fx_time() const;
  void clear_fx_time();
  static const int kFxTimeFieldNumber = 10;
  float fx_time() const;
  void set_fx_time(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageHudMsg)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_color1();
  void clear_has_color1();
  void set_has_color2();
  void clear_has_color2();
  void set_has_effect();
  void clear_has_effect();
  void set_has_fade_in_time();
  void clear_has_fade_in_time();
  void set_has_fade_out_time();
  void clear_has_fade_out_time();
  void set_has_hold_time();
  void clear_has_hold_time();
  void set_has_fx_time();
  void clear_has_fx_time();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 channel_;
  float x_;
  float y_;
  ::google::protobuf::uint32 color1_;
  ::google::protobuf::uint32 color2_;
  ::google::protobuf::uint32 effect_;
  float fade_in_time_;
  float fade_out_time_;
  float hold_time_;
  float fx_time_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageHudText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageHudText) */ {
 public:
  CUserMessageHudText();
  virtual ~CUserMessageHudText();

  CUserMessageHudText(const CUserMessageHudText& from);

  inline CUserMessageHudText& operator=(const CUserMessageHudText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageHudText& default_instance();

  static inline const CUserMessageHudText* internal_default_instance() {
    return reinterpret_cast<const CUserMessageHudText*>(
               &_CUserMessageHudText_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(CUserMessageHudText* other);

  // implements Message ----------------------------------------------

  inline CUserMessageHudText* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageHudText* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageHudText& from);
  void MergeFrom(const CUserMessageHudText& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageHudText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageHudText)
 private:
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageTextMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageTextMsg) */ {
 public:
  CUserMessageTextMsg();
  virtual ~CUserMessageTextMsg();

  CUserMessageTextMsg(const CUserMessageTextMsg& from);

  inline CUserMessageTextMsg& operator=(const CUserMessageTextMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageTextMsg& default_instance();

  static inline const CUserMessageTextMsg* internal_default_instance() {
    return reinterpret_cast<const CUserMessageTextMsg*>(
               &_CUserMessageTextMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(CUserMessageTextMsg* other);

  // implements Message ----------------------------------------------

  inline CUserMessageTextMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageTextMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageTextMsg& from);
  void MergeFrom(const CUserMessageTextMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageTextMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  const ::std::string& param(int index) const;
  ::std::string* mutable_param(int index);
  void set_param(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_param(int index, ::std::string&& value);
  #endif
  void set_param(int index, const char* value);
  void set_param(int index, const char* value, size_t size);
  ::std::string* add_param();
  void add_param(const ::std::string& value);
  #if LANG_CXX11
  void add_param(::std::string&& value);
  #endif
  void add_param(const char* value);
  void add_param(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& param() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_param();

  // optional uint32 dest = 1;
  bool has_dest() const;
  void clear_dest();
  static const int kDestFieldNumber = 1;
  ::google::protobuf::uint32 dest() const;
  void set_dest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageTextMsg)
 private:
  void set_has_dest();
  void clear_has_dest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> param_;
  ::google::protobuf::uint32 dest_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageGameTitle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageGameTitle) */ {
 public:
  CUserMessageGameTitle();
  virtual ~CUserMessageGameTitle();

  CUserMessageGameTitle(const CUserMessageGameTitle& from);

  inline CUserMessageGameTitle& operator=(const CUserMessageGameTitle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageGameTitle& default_instance();

  static inline const CUserMessageGameTitle* internal_default_instance() {
    return reinterpret_cast<const CUserMessageGameTitle*>(
               &_CUserMessageGameTitle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(CUserMessageGameTitle* other);

  // implements Message ----------------------------------------------

  inline CUserMessageGameTitle* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageGameTitle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageGameTitle& from);
  void MergeFrom(const CUserMessageGameTitle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageGameTitle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageGameTitle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageResetHUD : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageResetHUD) */ {
 public:
  CUserMessageResetHUD();
  virtual ~CUserMessageResetHUD();

  CUserMessageResetHUD(const CUserMessageResetHUD& from);

  inline CUserMessageResetHUD& operator=(const CUserMessageResetHUD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageResetHUD& default_instance();

  static inline const CUserMessageResetHUD* internal_default_instance() {
    return reinterpret_cast<const CUserMessageResetHUD*>(
               &_CUserMessageResetHUD_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(CUserMessageResetHUD* other);

  // implements Message ----------------------------------------------

  inline CUserMessageResetHUD* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageResetHUD* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageResetHUD& from);
  void MergeFrom(const CUserMessageResetHUD& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageResetHUD* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageResetHUD)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageSendAudio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageSendAudio) */ {
 public:
  CUserMessageSendAudio();
  virtual ~CUserMessageSendAudio();

  CUserMessageSendAudio(const CUserMessageSendAudio& from);

  inline CUserMessageSendAudio& operator=(const CUserMessageSendAudio& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageSendAudio& default_instance();

  static inline const CUserMessageSendAudio* internal_default_instance() {
    return reinterpret_cast<const CUserMessageSendAudio*>(
               &_CUserMessageSendAudio_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(CUserMessageSendAudio* other);

  // implements Message ----------------------------------------------

  inline CUserMessageSendAudio* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageSendAudio* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageSendAudio& from);
  void MergeFrom(const CUserMessageSendAudio& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageSendAudio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string soundname = 1;
  bool has_soundname() const;
  void clear_soundname();
  static const int kSoundnameFieldNumber = 1;
  const ::std::string& soundname() const;
  void set_soundname(const ::std::string& value);
  #if LANG_CXX11
  void set_soundname(::std::string&& value);
  #endif
  void set_soundname(const char* value);
  void set_soundname(const char* value, size_t size);
  ::std::string* mutable_soundname();
  ::std::string* release_soundname();
  void set_allocated_soundname(::std::string* soundname);

  // optional bool stop = 2;
  bool has_stop() const;
  void clear_stop();
  static const int kStopFieldNumber = 2;
  bool stop() const;
  void set_stop(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageSendAudio)
 private:
  void set_has_soundname();
  void clear_has_soundname();
  void set_has_stop();
  void clear_has_stop();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr soundname_;
  bool stop_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageAudioParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageAudioParameter) */ {
 public:
  CUserMessageAudioParameter();
  virtual ~CUserMessageAudioParameter();

  CUserMessageAudioParameter(const CUserMessageAudioParameter& from);

  inline CUserMessageAudioParameter& operator=(const CUserMessageAudioParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageAudioParameter& default_instance();

  static inline const CUserMessageAudioParameter* internal_default_instance() {
    return reinterpret_cast<const CUserMessageAudioParameter*>(
               &_CUserMessageAudioParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(CUserMessageAudioParameter* other);

  // implements Message ----------------------------------------------

  inline CUserMessageAudioParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageAudioParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageAudioParameter& from);
  void MergeFrom(const CUserMessageAudioParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageAudioParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 parameter_type = 1;
  bool has_parameter_type() const;
  void clear_parameter_type();
  static const int kParameterTypeFieldNumber = 1;
  ::google::protobuf::uint32 parameter_type() const;
  void set_parameter_type(::google::protobuf::uint32 value);

  // optional uint32 name_hash_code = 2;
  bool has_name_hash_code() const;
  void clear_name_hash_code();
  static const int kNameHashCodeFieldNumber = 2;
  ::google::protobuf::uint32 name_hash_code() const;
  void set_name_hash_code(::google::protobuf::uint32 value);

  // optional float value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  float value() const;
  void set_value(float value);

  // optional uint32 int_value = 4;
  bool has_int_value() const;
  void clear_int_value();
  static const int kIntValueFieldNumber = 4;
  ::google::protobuf::uint32 int_value() const;
  void set_int_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageAudioParameter)
 private:
  void set_has_parameter_type();
  void clear_has_parameter_type();
  void set_has_name_hash_code();
  void clear_has_name_hash_code();
  void set_has_value();
  void clear_has_value();
  void set_has_int_value();
  void clear_has_int_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 parameter_type_;
  ::google::protobuf::uint32 name_hash_code_;
  float value_;
  ::google::protobuf::uint32 int_value_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageVoiceMask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageVoiceMask) */ {
 public:
  CUserMessageVoiceMask();
  virtual ~CUserMessageVoiceMask();

  CUserMessageVoiceMask(const CUserMessageVoiceMask& from);

  inline CUserMessageVoiceMask& operator=(const CUserMessageVoiceMask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageVoiceMask& default_instance();

  static inline const CUserMessageVoiceMask* internal_default_instance() {
    return reinterpret_cast<const CUserMessageVoiceMask*>(
               &_CUserMessageVoiceMask_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(CUserMessageVoiceMask* other);

  // implements Message ----------------------------------------------

  inline CUserMessageVoiceMask* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageVoiceMask* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageVoiceMask& from);
  void MergeFrom(const CUserMessageVoiceMask& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageVoiceMask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 gamerules_masks = 1;
  int gamerules_masks_size() const;
  void clear_gamerules_masks();
  static const int kGamerulesMasksFieldNumber = 1;
  ::google::protobuf::uint32 gamerules_masks(int index) const;
  void set_gamerules_masks(int index, ::google::protobuf::uint32 value);
  void add_gamerules_masks(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gamerules_masks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gamerules_masks();

  // repeated uint32 ban_masks = 2;
  int ban_masks_size() const;
  void clear_ban_masks();
  static const int kBanMasksFieldNumber = 2;
  ::google::protobuf::uint32 ban_masks(int index) const;
  void set_ban_masks(int index, ::google::protobuf::uint32 value);
  void add_ban_masks(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ban_masks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ban_masks();

  // optional bool mod_enable = 3;
  bool has_mod_enable() const;
  void clear_mod_enable();
  static const int kModEnableFieldNumber = 3;
  bool mod_enable() const;
  void set_mod_enable(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageVoiceMask)
 private:
  void set_has_mod_enable();
  void clear_has_mod_enable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gamerules_masks_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ban_masks_;
  bool mod_enable_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageRequestState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageRequestState) */ {
 public:
  CUserMessageRequestState();
  virtual ~CUserMessageRequestState();

  CUserMessageRequestState(const CUserMessageRequestState& from);

  inline CUserMessageRequestState& operator=(const CUserMessageRequestState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageRequestState& default_instance();

  static inline const CUserMessageRequestState* internal_default_instance() {
    return reinterpret_cast<const CUserMessageRequestState*>(
               &_CUserMessageRequestState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(CUserMessageRequestState* other);

  // implements Message ----------------------------------------------

  inline CUserMessageRequestState* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageRequestState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageRequestState& from);
  void MergeFrom(const CUserMessageRequestState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageRequestState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageRequestState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageHintText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageHintText) */ {
 public:
  CUserMessageHintText();
  virtual ~CUserMessageHintText();

  CUserMessageHintText(const CUserMessageHintText& from);

  inline CUserMessageHintText& operator=(const CUserMessageHintText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageHintText& default_instance();

  static inline const CUserMessageHintText* internal_default_instance() {
    return reinterpret_cast<const CUserMessageHintText*>(
               &_CUserMessageHintText_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(CUserMessageHintText* other);

  // implements Message ----------------------------------------------

  inline CUserMessageHintText* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageHintText* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageHintText& from);
  void MergeFrom(const CUserMessageHintText& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageHintText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageHintText)
 private:
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageKeyHintText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageKeyHintText) */ {
 public:
  CUserMessageKeyHintText();
  virtual ~CUserMessageKeyHintText();

  CUserMessageKeyHintText(const CUserMessageKeyHintText& from);

  inline CUserMessageKeyHintText& operator=(const CUserMessageKeyHintText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageKeyHintText& default_instance();

  static inline const CUserMessageKeyHintText* internal_default_instance() {
    return reinterpret_cast<const CUserMessageKeyHintText*>(
               &_CUserMessageKeyHintText_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(CUserMessageKeyHintText* other);

  // implements Message ----------------------------------------------

  inline CUserMessageKeyHintText* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageKeyHintText* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageKeyHintText& from);
  void MergeFrom(const CUserMessageKeyHintText& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageKeyHintText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string messages = 1;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 1;
  const ::std::string& messages(int index) const;
  ::std::string* mutable_messages(int index);
  void set_messages(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_messages(int index, ::std::string&& value);
  #endif
  void set_messages(int index, const char* value);
  void set_messages(int index, const char* value, size_t size);
  ::std::string* add_messages();
  void add_messages(const ::std::string& value);
  #if LANG_CXX11
  void add_messages(::std::string&& value);
  #endif
  void add_messages(const char* value);
  void add_messages(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& messages() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messages();

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageKeyHintText)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messages_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageVoiceSubtitle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageVoiceSubtitle) */ {
 public:
  CUserMessageVoiceSubtitle();
  virtual ~CUserMessageVoiceSubtitle();

  CUserMessageVoiceSubtitle(const CUserMessageVoiceSubtitle& from);

  inline CUserMessageVoiceSubtitle& operator=(const CUserMessageVoiceSubtitle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageVoiceSubtitle& default_instance();

  static inline const CUserMessageVoiceSubtitle* internal_default_instance() {
    return reinterpret_cast<const CUserMessageVoiceSubtitle*>(
               &_CUserMessageVoiceSubtitle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(CUserMessageVoiceSubtitle* other);

  // implements Message ----------------------------------------------

  inline CUserMessageVoiceSubtitle* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageVoiceSubtitle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageVoiceSubtitle& from);
  void MergeFrom(const CUserMessageVoiceSubtitle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageVoiceSubtitle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  ::google::protobuf::int32 player() const;
  void set_player(::google::protobuf::int32 value);

  // optional int32 menu = 2;
  bool has_menu() const;
  void clear_menu();
  static const int kMenuFieldNumber = 2;
  ::google::protobuf::int32 menu() const;
  void set_menu(::google::protobuf::int32 value);

  // optional int32 item = 3;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 3;
  ::google::protobuf::int32 item() const;
  void set_item(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageVoiceSubtitle)
 private:
  void set_has_player();
  void clear_has_player();
  void set_has_menu();
  void clear_has_menu();
  void set_has_item();
  void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 player_;
  ::google::protobuf::int32 menu_;
  ::google::protobuf::int32 item_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageVGUIMenu_Keys : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageVGUIMenu.Keys) */ {
 public:
  CUserMessageVGUIMenu_Keys();
  virtual ~CUserMessageVGUIMenu_Keys();

  CUserMessageVGUIMenu_Keys(const CUserMessageVGUIMenu_Keys& from);

  inline CUserMessageVGUIMenu_Keys& operator=(const CUserMessageVGUIMenu_Keys& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageVGUIMenu_Keys& default_instance();

  static inline const CUserMessageVGUIMenu_Keys* internal_default_instance() {
    return reinterpret_cast<const CUserMessageVGUIMenu_Keys*>(
               &_CUserMessageVGUIMenu_Keys_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(CUserMessageVGUIMenu_Keys* other);

  // implements Message ----------------------------------------------

  inline CUserMessageVGUIMenu_Keys* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageVGUIMenu_Keys* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageVGUIMenu_Keys& from);
  void MergeFrom(const CUserMessageVGUIMenu_Keys& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageVGUIMenu_Keys* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageVGUIMenu.Keys)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageVGUIMenu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageVGUIMenu) */ {
 public:
  CUserMessageVGUIMenu();
  virtual ~CUserMessageVGUIMenu();

  CUserMessageVGUIMenu(const CUserMessageVGUIMenu& from);

  inline CUserMessageVGUIMenu& operator=(const CUserMessageVGUIMenu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageVGUIMenu& default_instance();

  static inline const CUserMessageVGUIMenu* internal_default_instance() {
    return reinterpret_cast<const CUserMessageVGUIMenu*>(
               &_CUserMessageVGUIMenu_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(CUserMessageVGUIMenu* other);

  // implements Message ----------------------------------------------

  inline CUserMessageVGUIMenu* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageVGUIMenu* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageVGUIMenu& from);
  void MergeFrom(const CUserMessageVGUIMenu& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageVGUIMenu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CUserMessageVGUIMenu_Keys Keys;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CUserMessageVGUIMenu.Keys keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::proto::dota::CUserMessageVGUIMenu_Keys& keys(int index) const;
  ::proto::dota::CUserMessageVGUIMenu_Keys* mutable_keys(int index);
  ::proto::dota::CUserMessageVGUIMenu_Keys* add_keys();
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CUserMessageVGUIMenu_Keys >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CUserMessageVGUIMenu_Keys >&
      keys() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool show = 2;
  bool has_show() const;
  void clear_show();
  static const int kShowFieldNumber = 2;
  bool show() const;
  void set_show(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageVGUIMenu)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_show();
  void clear_has_show();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CUserMessageVGUIMenu_Keys > keys_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool show_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageRumble : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageRumble) */ {
 public:
  CUserMessageRumble();
  virtual ~CUserMessageRumble();

  CUserMessageRumble(const CUserMessageRumble& from);

  inline CUserMessageRumble& operator=(const CUserMessageRumble& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageRumble& default_instance();

  static inline const CUserMessageRumble* internal_default_instance() {
    return reinterpret_cast<const CUserMessageRumble*>(
               &_CUserMessageRumble_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(CUserMessageRumble* other);

  // implements Message ----------------------------------------------

  inline CUserMessageRumble* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageRumble* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageRumble& from);
  void MergeFrom(const CUserMessageRumble& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageRumble* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // optional int32 data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::google::protobuf::int32 data() const;
  void set_data(::google::protobuf::int32 value);

  // optional int32 flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::int32 flags() const;
  void set_flags(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageRumble)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_data();
  void clear_has_data();
  void set_has_flags();
  void clear_has_flags();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 data_;
  ::google::protobuf::int32 flags_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageTrain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageTrain) */ {
 public:
  CUserMessageTrain();
  virtual ~CUserMessageTrain();

  CUserMessageTrain(const CUserMessageTrain& from);

  inline CUserMessageTrain& operator=(const CUserMessageTrain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageTrain& default_instance();

  static inline const CUserMessageTrain* internal_default_instance() {
    return reinterpret_cast<const CUserMessageTrain*>(
               &_CUserMessageTrain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(CUserMessageTrain* other);

  // implements Message ----------------------------------------------

  inline CUserMessageTrain* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageTrain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageTrain& from);
  void MergeFrom(const CUserMessageTrain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageTrain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageTrain)
 private:
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 position_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageSayTextChannel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageSayTextChannel) */ {
 public:
  CUserMessageSayTextChannel();
  virtual ~CUserMessageSayTextChannel();

  CUserMessageSayTextChannel(const CUserMessageSayTextChannel& from);

  inline CUserMessageSayTextChannel& operator=(const CUserMessageSayTextChannel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageSayTextChannel& default_instance();

  static inline const CUserMessageSayTextChannel* internal_default_instance() {
    return reinterpret_cast<const CUserMessageSayTextChannel*>(
               &_CUserMessageSayTextChannel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(CUserMessageSayTextChannel* other);

  // implements Message ----------------------------------------------

  inline CUserMessageSayTextChannel* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageSayTextChannel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageSayTextChannel& from);
  void MergeFrom(const CUserMessageSayTextChannel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageSayTextChannel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional int32 player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  ::google::protobuf::int32 player() const;
  void set_player(::google::protobuf::int32 value);

  // optional int32 channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageSayTextChannel)
 private:
  void set_has_player();
  void clear_has_player();
  void set_has_channel();
  void clear_has_channel();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int32 player_;
  ::google::protobuf::int32 channel_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageColoredText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageColoredText) */ {
 public:
  CUserMessageColoredText();
  virtual ~CUserMessageColoredText();

  CUserMessageColoredText(const CUserMessageColoredText& from);

  inline CUserMessageColoredText& operator=(const CUserMessageColoredText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageColoredText& default_instance();

  static inline const CUserMessageColoredText* internal_default_instance() {
    return reinterpret_cast<const CUserMessageColoredText*>(
               &_CUserMessageColoredText_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(CUserMessageColoredText* other);

  // implements Message ----------------------------------------------

  inline CUserMessageColoredText* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageColoredText* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageColoredText& from);
  void MergeFrom(const CUserMessageColoredText& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageColoredText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // optional bool reset = 3;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 3;
  bool reset() const;
  void set_reset(bool value);

  // optional int32 context_player_id = 4;
  bool has_context_player_id() const;
  void clear_context_player_id();
  static const int kContextPlayerIdFieldNumber = 4;
  ::google::protobuf::int32 context_player_id() const;
  void set_context_player_id(::google::protobuf::int32 value);

  // optional int32 context_value = 5;
  bool has_context_value() const;
  void clear_context_value();
  static const int kContextValueFieldNumber = 5;
  ::google::protobuf::int32 context_value() const;
  void set_context_value(::google::protobuf::int32 value);

  // optional int32 context_team_id = 6;
  bool has_context_team_id() const;
  void clear_context_team_id();
  static const int kContextTeamIdFieldNumber = 6;
  ::google::protobuf::int32 context_team_id() const;
  void set_context_team_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageColoredText)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_text();
  void clear_has_text();
  void set_has_reset();
  void clear_has_reset();
  void set_has_context_player_id();
  void clear_has_context_player_id();
  void set_has_context_value();
  void clear_has_context_value();
  void set_has_context_team_id();
  void clear_has_context_team_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 color_;
  bool reset_;
  ::google::protobuf::int32 context_player_id_;
  ::google::protobuf::int32 context_value_;
  ::google::protobuf::int32 context_team_id_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageItemPickup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageItemPickup) */ {
 public:
  CUserMessageItemPickup();
  virtual ~CUserMessageItemPickup();

  CUserMessageItemPickup(const CUserMessageItemPickup& from);

  inline CUserMessageItemPickup& operator=(const CUserMessageItemPickup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageItemPickup& default_instance();

  static inline const CUserMessageItemPickup* internal_default_instance() {
    return reinterpret_cast<const CUserMessageItemPickup*>(
               &_CUserMessageItemPickup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(CUserMessageItemPickup* other);

  // implements Message ----------------------------------------------

  inline CUserMessageItemPickup* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageItemPickup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageItemPickup& from);
  void MergeFrom(const CUserMessageItemPickup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageItemPickup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string itemname = 1;
  bool has_itemname() const;
  void clear_itemname();
  static const int kItemnameFieldNumber = 1;
  const ::std::string& itemname() const;
  void set_itemname(const ::std::string& value);
  #if LANG_CXX11
  void set_itemname(::std::string&& value);
  #endif
  void set_itemname(const char* value);
  void set_itemname(const char* value, size_t size);
  ::std::string* mutable_itemname();
  ::std::string* release_itemname();
  void set_allocated_itemname(::std::string* itemname);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageItemPickup)
 private:
  void set_has_itemname();
  void clear_has_itemname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr itemname_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageAmmoDenied : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageAmmoDenied) */ {
 public:
  CUserMessageAmmoDenied();
  virtual ~CUserMessageAmmoDenied();

  CUserMessageAmmoDenied(const CUserMessageAmmoDenied& from);

  inline CUserMessageAmmoDenied& operator=(const CUserMessageAmmoDenied& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageAmmoDenied& default_instance();

  static inline const CUserMessageAmmoDenied* internal_default_instance() {
    return reinterpret_cast<const CUserMessageAmmoDenied*>(
               &_CUserMessageAmmoDenied_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(CUserMessageAmmoDenied* other);

  // implements Message ----------------------------------------------

  inline CUserMessageAmmoDenied* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageAmmoDenied* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageAmmoDenied& from);
  void MergeFrom(const CUserMessageAmmoDenied& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageAmmoDenied* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ammo_id = 1;
  bool has_ammo_id() const;
  void clear_ammo_id();
  static const int kAmmoIdFieldNumber = 1;
  ::google::protobuf::uint32 ammo_id() const;
  void set_ammo_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageAmmoDenied)
 private:
  void set_has_ammo_id();
  void clear_has_ammo_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 ammo_id_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCrosshairAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCrosshairAngle) */ {
 public:
  CUserMessageCrosshairAngle();
  virtual ~CUserMessageCrosshairAngle();

  CUserMessageCrosshairAngle(const CUserMessageCrosshairAngle& from);

  inline CUserMessageCrosshairAngle& operator=(const CUserMessageCrosshairAngle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCrosshairAngle& default_instance();

  static inline const CUserMessageCrosshairAngle* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCrosshairAngle*>(
               &_CUserMessageCrosshairAngle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(CUserMessageCrosshairAngle* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCrosshairAngle* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCrosshairAngle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCrosshairAngle& from);
  void MergeFrom(const CUserMessageCrosshairAngle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCrosshairAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgQAngle angcrosshair = 1;
  bool has_angcrosshair() const;
  void clear_angcrosshair();
  static const int kAngcrosshairFieldNumber = 1;
  const ::proto::dota::CMsgQAngle& angcrosshair() const;
  ::proto::dota::CMsgQAngle* mutable_angcrosshair();
  ::proto::dota::CMsgQAngle* release_angcrosshair();
  void set_allocated_angcrosshair(::proto::dota::CMsgQAngle* angcrosshair);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCrosshairAngle)
 private:
  void set_has_angcrosshair();
  void clear_has_angcrosshair();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgQAngle* angcrosshair_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageShowMenu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageShowMenu) */ {
 public:
  CUserMessageShowMenu();
  virtual ~CUserMessageShowMenu();

  CUserMessageShowMenu(const CUserMessageShowMenu& from);

  inline CUserMessageShowMenu& operator=(const CUserMessageShowMenu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageShowMenu& default_instance();

  static inline const CUserMessageShowMenu* internal_default_instance() {
    return reinterpret_cast<const CUserMessageShowMenu*>(
               &_CUserMessageShowMenu_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(CUserMessageShowMenu* other);

  // implements Message ----------------------------------------------

  inline CUserMessageShowMenu* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageShowMenu* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageShowMenu& from);
  void MergeFrom(const CUserMessageShowMenu& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageShowMenu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string menustring = 4;
  bool has_menustring() const;
  void clear_menustring();
  static const int kMenustringFieldNumber = 4;
  const ::std::string& menustring() const;
  void set_menustring(const ::std::string& value);
  #if LANG_CXX11
  void set_menustring(::std::string&& value);
  #endif
  void set_menustring(const char* value);
  void set_menustring(const char* value, size_t size);
  ::std::string* mutable_menustring();
  ::std::string* release_menustring();
  void set_allocated_menustring(::std::string* menustring);

  // optional uint32 validslots = 1;
  bool has_validslots() const;
  void clear_validslots();
  static const int kValidslotsFieldNumber = 1;
  ::google::protobuf::uint32 validslots() const;
  void set_validslots(::google::protobuf::uint32 value);

  // optional uint32 displaytime = 2;
  bool has_displaytime() const;
  void clear_displaytime();
  static const int kDisplaytimeFieldNumber = 2;
  ::google::protobuf::uint32 displaytime() const;
  void set_displaytime(::google::protobuf::uint32 value);

  // optional bool needmore = 3;
  bool has_needmore() const;
  void clear_needmore();
  static const int kNeedmoreFieldNumber = 3;
  bool needmore() const;
  void set_needmore(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageShowMenu)
 private:
  void set_has_validslots();
  void clear_has_validslots();
  void set_has_displaytime();
  void clear_has_displaytime();
  void set_has_needmore();
  void clear_has_needmore();
  void set_has_menustring();
  void clear_has_menustring();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr menustring_;
  ::google::protobuf::uint32 validslots_;
  ::google::protobuf::uint32 displaytime_;
  bool needmore_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCreditsMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCreditsMsg) */ {
 public:
  CUserMessageCreditsMsg();
  virtual ~CUserMessageCreditsMsg();

  CUserMessageCreditsMsg(const CUserMessageCreditsMsg& from);

  inline CUserMessageCreditsMsg& operator=(const CUserMessageCreditsMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCreditsMsg& default_instance();

  static inline const CUserMessageCreditsMsg* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCreditsMsg*>(
               &_CUserMessageCreditsMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(CUserMessageCreditsMsg* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCreditsMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCreditsMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCreditsMsg& from);
  void MergeFrom(const CUserMessageCreditsMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCreditsMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float logo_length = 2;
  bool has_logo_length() const;
  void clear_logo_length();
  static const int kLogoLengthFieldNumber = 2;
  float logo_length() const;
  void set_logo_length(float value);

  // optional .proto.dota.eRollType rolltype = 1 [default = ROLL_NONE];
  bool has_rolltype() const;
  void clear_rolltype();
  static const int kRolltypeFieldNumber = 1;
  ::proto::dota::eRollType rolltype() const;
  void set_rolltype(::proto::dota::eRollType value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCreditsMsg)
 private:
  void set_has_rolltype();
  void clear_has_rolltype();
  void set_has_logo_length();
  void clear_has_logo_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float logo_length_;
  int rolltype_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CEntityMessagePlayJingle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CEntityMessagePlayJingle) */ {
 public:
  CEntityMessagePlayJingle();
  virtual ~CEntityMessagePlayJingle();

  CEntityMessagePlayJingle(const CEntityMessagePlayJingle& from);

  inline CEntityMessagePlayJingle& operator=(const CEntityMessagePlayJingle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CEntityMessagePlayJingle& default_instance();

  static inline const CEntityMessagePlayJingle* internal_default_instance() {
    return reinterpret_cast<const CEntityMessagePlayJingle*>(
               &_CEntityMessagePlayJingle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(CEntityMessagePlayJingle* other);

  // implements Message ----------------------------------------------

  inline CEntityMessagePlayJingle* New() const PROTOBUF_FINAL { return New(NULL); }

  CEntityMessagePlayJingle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CEntityMessagePlayJingle& from);
  void MergeFrom(const CEntityMessagePlayJingle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CEntityMessagePlayJingle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CEntityMessagePlayJingle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CEntityMessageScreenOverlay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CEntityMessageScreenOverlay) */ {
 public:
  CEntityMessageScreenOverlay();
  virtual ~CEntityMessageScreenOverlay();

  CEntityMessageScreenOverlay(const CEntityMessageScreenOverlay& from);

  inline CEntityMessageScreenOverlay& operator=(const CEntityMessageScreenOverlay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CEntityMessageScreenOverlay& default_instance();

  static inline const CEntityMessageScreenOverlay* internal_default_instance() {
    return reinterpret_cast<const CEntityMessageScreenOverlay*>(
               &_CEntityMessageScreenOverlay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(CEntityMessageScreenOverlay* other);

  // implements Message ----------------------------------------------

  inline CEntityMessageScreenOverlay* New() const PROTOBUF_FINAL { return New(NULL); }

  CEntityMessageScreenOverlay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CEntityMessageScreenOverlay& from);
  void MergeFrom(const CEntityMessageScreenOverlay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CEntityMessageScreenOverlay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool start_effect = 1;
  bool has_start_effect() const;
  void clear_start_effect();
  static const int kStartEffectFieldNumber = 1;
  bool start_effect() const;
  void set_start_effect(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CEntityMessageScreenOverlay)
 private:
  void set_has_start_effect();
  void clear_has_start_effect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool start_effect_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CEntityMessageRemoveAllDecals : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CEntityMessageRemoveAllDecals) */ {
 public:
  CEntityMessageRemoveAllDecals();
  virtual ~CEntityMessageRemoveAllDecals();

  CEntityMessageRemoveAllDecals(const CEntityMessageRemoveAllDecals& from);

  inline CEntityMessageRemoveAllDecals& operator=(const CEntityMessageRemoveAllDecals& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CEntityMessageRemoveAllDecals& default_instance();

  static inline const CEntityMessageRemoveAllDecals* internal_default_instance() {
    return reinterpret_cast<const CEntityMessageRemoveAllDecals*>(
               &_CEntityMessageRemoveAllDecals_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(CEntityMessageRemoveAllDecals* other);

  // implements Message ----------------------------------------------

  inline CEntityMessageRemoveAllDecals* New() const PROTOBUF_FINAL { return New(NULL); }

  CEntityMessageRemoveAllDecals* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CEntityMessageRemoveAllDecals& from);
  void MergeFrom(const CEntityMessageRemoveAllDecals& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CEntityMessageRemoveAllDecals* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool remove_decals = 1;
  bool has_remove_decals() const;
  void clear_remove_decals();
  static const int kRemoveDecalsFieldNumber = 1;
  bool remove_decals() const;
  void set_remove_decals(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CEntityMessageRemoveAllDecals)
 private:
  void set_has_remove_decals();
  void clear_has_remove_decals();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool remove_decals_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CEntityMessagePropagateForce : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CEntityMessagePropagateForce) */ {
 public:
  CEntityMessagePropagateForce();
  virtual ~CEntityMessagePropagateForce();

  CEntityMessagePropagateForce(const CEntityMessagePropagateForce& from);

  inline CEntityMessagePropagateForce& operator=(const CEntityMessagePropagateForce& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CEntityMessagePropagateForce& default_instance();

  static inline const CEntityMessagePropagateForce* internal_default_instance() {
    return reinterpret_cast<const CEntityMessagePropagateForce*>(
               &_CEntityMessagePropagateForce_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(CEntityMessagePropagateForce* other);

  // implements Message ----------------------------------------------

  inline CEntityMessagePropagateForce* New() const PROTOBUF_FINAL { return New(NULL); }

  CEntityMessagePropagateForce* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CEntityMessagePropagateForce& from);
  void MergeFrom(const CEntityMessagePropagateForce& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CEntityMessagePropagateForce* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector impulse = 1;
  bool has_impulse() const;
  void clear_impulse();
  static const int kImpulseFieldNumber = 1;
  const ::proto::dota::CMsgVector& impulse() const;
  ::proto::dota::CMsgVector* mutable_impulse();
  ::proto::dota::CMsgVector* release_impulse();
  void set_allocated_impulse(::proto::dota::CMsgVector* impulse);

  // @@protoc_insertion_point(class_scope:proto.dota.CEntityMessagePropagateForce)
 private:
  void set_has_impulse();
  void clear_has_impulse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* impulse_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CEntityMessageDoSpark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CEntityMessageDoSpark) */ {
 public:
  CEntityMessageDoSpark();
  virtual ~CEntityMessageDoSpark();

  CEntityMessageDoSpark(const CEntityMessageDoSpark& from);

  inline CEntityMessageDoSpark& operator=(const CEntityMessageDoSpark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CEntityMessageDoSpark& default_instance();

  static inline const CEntityMessageDoSpark* internal_default_instance() {
    return reinterpret_cast<const CEntityMessageDoSpark*>(
               &_CEntityMessageDoSpark_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(CEntityMessageDoSpark* other);

  // implements Message ----------------------------------------------

  inline CEntityMessageDoSpark* New() const PROTOBUF_FINAL { return New(NULL); }

  CEntityMessageDoSpark* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CEntityMessageDoSpark& from);
  void MergeFrom(const CEntityMessageDoSpark& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CEntityMessageDoSpark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional uint32 entityindex = 2;
  bool has_entityindex() const;
  void clear_entityindex();
  static const int kEntityindexFieldNumber = 2;
  ::google::protobuf::uint32 entityindex() const;
  void set_entityindex(::google::protobuf::uint32 value);

  // optional float radius = 3;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 3;
  float radius() const;
  void set_radius(float value);

  // optional fixed32 color = 4;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 4;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // optional uint32 beams = 5;
  bool has_beams() const;
  void clear_beams();
  static const int kBeamsFieldNumber = 5;
  ::google::protobuf::uint32 beams() const;
  void set_beams(::google::protobuf::uint32 value);

  // optional float thick = 6;
  bool has_thick() const;
  void clear_thick();
  static const int kThickFieldNumber = 6;
  float thick() const;
  void set_thick(float value);

  // optional float duration = 7;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 7;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CEntityMessageDoSpark)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_entityindex();
  void clear_has_entityindex();
  void set_has_radius();
  void clear_has_radius();
  void set_has_color();
  void clear_has_color();
  void set_has_beams();
  void clear_has_beams();
  void set_has_thick();
  void clear_has_thick();
  void set_has_duration();
  void clear_has_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::google::protobuf::uint32 entityindex_;
  float radius_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 beams_;
  float thick_;
  float duration_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CEntityMessageFixAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CEntityMessageFixAngle) */ {
 public:
  CEntityMessageFixAngle();
  virtual ~CEntityMessageFixAngle();

  CEntityMessageFixAngle(const CEntityMessageFixAngle& from);

  inline CEntityMessageFixAngle& operator=(const CEntityMessageFixAngle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CEntityMessageFixAngle& default_instance();

  static inline const CEntityMessageFixAngle* internal_default_instance() {
    return reinterpret_cast<const CEntityMessageFixAngle*>(
               &_CEntityMessageFixAngle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(CEntityMessageFixAngle* other);

  // implements Message ----------------------------------------------

  inline CEntityMessageFixAngle* New() const PROTOBUF_FINAL { return New(NULL); }

  CEntityMessageFixAngle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CEntityMessageFixAngle& from);
  void MergeFrom(const CEntityMessageFixAngle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CEntityMessageFixAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgQAngle angle = 2;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 2;
  const ::proto::dota::CMsgQAngle& angle() const;
  ::proto::dota::CMsgQAngle* mutable_angle();
  ::proto::dota::CMsgQAngle* release_angle();
  void set_allocated_angle(::proto::dota::CMsgQAngle* angle);

  // optional bool relative = 1;
  bool has_relative() const;
  void clear_relative();
  static const int kRelativeFieldNumber = 1;
  bool relative() const;
  void set_relative(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CEntityMessageFixAngle)
 private:
  void set_has_relative();
  void clear_has_relative();
  void set_has_angle();
  void clear_has_angle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgQAngle* angle_;
  bool relative_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCameraTransition_Transition_DataDriven : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCameraTransition.Transition_DataDriven) */ {
 public:
  CUserMessageCameraTransition_Transition_DataDriven();
  virtual ~CUserMessageCameraTransition_Transition_DataDriven();

  CUserMessageCameraTransition_Transition_DataDriven(const CUserMessageCameraTransition_Transition_DataDriven& from);

  inline CUserMessageCameraTransition_Transition_DataDriven& operator=(const CUserMessageCameraTransition_Transition_DataDriven& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCameraTransition_Transition_DataDriven& default_instance();

  static inline const CUserMessageCameraTransition_Transition_DataDriven* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCameraTransition_Transition_DataDriven*>(
               &_CUserMessageCameraTransition_Transition_DataDriven_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(CUserMessageCameraTransition_Transition_DataDriven* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCameraTransition_Transition_DataDriven* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCameraTransition_Transition_DataDriven* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCameraTransition_Transition_DataDriven& from);
  void MergeFrom(const CUserMessageCameraTransition_Transition_DataDriven& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCameraTransition_Transition_DataDriven* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // optional int32 attach_ent_index = 2;
  bool has_attach_ent_index() const;
  void clear_attach_ent_index();
  static const int kAttachEntIndexFieldNumber = 2;
  ::google::protobuf::int32 attach_ent_index() const;
  void set_attach_ent_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCameraTransition.Transition_DataDriven)
 private:
  void set_has_filename();
  void clear_has_filename();
  void set_has_attach_ent_index();
  void clear_has_attach_ent_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::int32 attach_ent_index_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageCameraTransition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageCameraTransition) */ {
 public:
  CUserMessageCameraTransition();
  virtual ~CUserMessageCameraTransition();

  CUserMessageCameraTransition(const CUserMessageCameraTransition& from);

  inline CUserMessageCameraTransition& operator=(const CUserMessageCameraTransition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageCameraTransition& default_instance();

  static inline const CUserMessageCameraTransition* internal_default_instance() {
    return reinterpret_cast<const CUserMessageCameraTransition*>(
               &_CUserMessageCameraTransition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(CUserMessageCameraTransition* other);

  // implements Message ----------------------------------------------

  inline CUserMessageCameraTransition* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageCameraTransition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageCameraTransition& from);
  void MergeFrom(const CUserMessageCameraTransition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageCameraTransition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CUserMessageCameraTransition_Transition_DataDriven Transition_DataDriven;

  // accessors -------------------------------------------------------

  // optional .proto.dota.CUserMessageCameraTransition.Transition_DataDriven params_data_driven = 3;
  bool has_params_data_driven() const;
  void clear_params_data_driven();
  static const int kParamsDataDrivenFieldNumber = 3;
  const ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven& params_data_driven() const;
  ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* mutable_params_data_driven();
  ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* release_params_data_driven();
  void set_allocated_params_data_driven(::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* params_data_driven);

  // optional uint32 camera_type = 1;
  bool has_camera_type() const;
  void clear_camera_type();
  static const int kCameraTypeFieldNumber = 1;
  ::google::protobuf::uint32 camera_type() const;
  void set_camera_type(::google::protobuf::uint32 value);

  // optional float duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageCameraTransition)
 private:
  void set_has_camera_type();
  void clear_has_camera_type();
  void set_has_duration();
  void clear_has_duration();
  void set_has_params_data_driven();
  void clear_has_params_data_driven();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* params_data_driven_;
  ::google::protobuf::uint32 camera_type_;
  float duration_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_ReleaseParticleIndex : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.ReleaseParticleIndex) */ {
 public:
  CUserMsg_ParticleManager_ReleaseParticleIndex();
  virtual ~CUserMsg_ParticleManager_ReleaseParticleIndex();

  CUserMsg_ParticleManager_ReleaseParticleIndex(const CUserMsg_ParticleManager_ReleaseParticleIndex& from);

  inline CUserMsg_ParticleManager_ReleaseParticleIndex& operator=(const CUserMsg_ParticleManager_ReleaseParticleIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_ReleaseParticleIndex& default_instance();

  static inline const CUserMsg_ParticleManager_ReleaseParticleIndex* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_ReleaseParticleIndex*>(
               &_CUserMsg_ParticleManager_ReleaseParticleIndex_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(CUserMsg_ParticleManager_ReleaseParticleIndex* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_ReleaseParticleIndex* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_ReleaseParticleIndex* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_ReleaseParticleIndex& from);
  void MergeFrom(const CUserMsg_ParticleManager_ReleaseParticleIndex& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_ReleaseParticleIndex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.ReleaseParticleIndex)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_CreateParticle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.CreateParticle) */ {
 public:
  CUserMsg_ParticleManager_CreateParticle();
  virtual ~CUserMsg_ParticleManager_CreateParticle();

  CUserMsg_ParticleManager_CreateParticle(const CUserMsg_ParticleManager_CreateParticle& from);

  inline CUserMsg_ParticleManager_CreateParticle& operator=(const CUserMsg_ParticleManager_CreateParticle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_CreateParticle& default_instance();

  static inline const CUserMsg_ParticleManager_CreateParticle* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_CreateParticle*>(
               &_CUserMsg_ParticleManager_CreateParticle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(CUserMsg_ParticleManager_CreateParticle* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_CreateParticle* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_CreateParticle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_CreateParticle& from);
  void MergeFrom(const CUserMsg_ParticleManager_CreateParticle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_CreateParticle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 particle_name_index = 1;
  bool has_particle_name_index() const;
  void clear_particle_name_index();
  static const int kParticleNameIndexFieldNumber = 1;
  ::google::protobuf::uint64 particle_name_index() const;
  void set_particle_name_index(::google::protobuf::uint64 value);

  // optional int32 attach_type = 2;
  bool has_attach_type() const;
  void clear_attach_type();
  static const int kAttachTypeFieldNumber = 2;
  ::google::protobuf::int32 attach_type() const;
  void set_attach_type(::google::protobuf::int32 value);

  // optional int32 entity_handle = 3;
  bool has_entity_handle() const;
  void clear_entity_handle();
  static const int kEntityHandleFieldNumber = 3;
  ::google::protobuf::int32 entity_handle() const;
  void set_entity_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.CreateParticle)
 private:
  void set_has_particle_name_index();
  void clear_has_particle_name_index();
  void set_has_attach_type();
  void clear_has_attach_type();
  void set_has_entity_handle();
  void clear_has_entity_handle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 particle_name_index_;
  ::google::protobuf::int32 attach_type_;
  ::google::protobuf::int32 entity_handle_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_DestroyParticle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.DestroyParticle) */ {
 public:
  CUserMsg_ParticleManager_DestroyParticle();
  virtual ~CUserMsg_ParticleManager_DestroyParticle();

  CUserMsg_ParticleManager_DestroyParticle(const CUserMsg_ParticleManager_DestroyParticle& from);

  inline CUserMsg_ParticleManager_DestroyParticle& operator=(const CUserMsg_ParticleManager_DestroyParticle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_DestroyParticle& default_instance();

  static inline const CUserMsg_ParticleManager_DestroyParticle* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_DestroyParticle*>(
               &_CUserMsg_ParticleManager_DestroyParticle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(CUserMsg_ParticleManager_DestroyParticle* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_DestroyParticle* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_DestroyParticle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_DestroyParticle& from);
  void MergeFrom(const CUserMsg_ParticleManager_DestroyParticle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_DestroyParticle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool destroy_immediately = 1;
  bool has_destroy_immediately() const;
  void clear_destroy_immediately();
  static const int kDestroyImmediatelyFieldNumber = 1;
  bool destroy_immediately() const;
  void set_destroy_immediately(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.DestroyParticle)
 private:
  void set_has_destroy_immediately();
  void clear_has_destroy_immediately();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool destroy_immediately_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_DestroyParticleInvolving : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving) */ {
 public:
  CUserMsg_ParticleManager_DestroyParticleInvolving();
  virtual ~CUserMsg_ParticleManager_DestroyParticleInvolving();

  CUserMsg_ParticleManager_DestroyParticleInvolving(const CUserMsg_ParticleManager_DestroyParticleInvolving& from);

  inline CUserMsg_ParticleManager_DestroyParticleInvolving& operator=(const CUserMsg_ParticleManager_DestroyParticleInvolving& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_DestroyParticleInvolving& default_instance();

  static inline const CUserMsg_ParticleManager_DestroyParticleInvolving* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_DestroyParticleInvolving*>(
               &_CUserMsg_ParticleManager_DestroyParticleInvolving_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(CUserMsg_ParticleManager_DestroyParticleInvolving* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_DestroyParticleInvolving* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_DestroyParticleInvolving* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_DestroyParticleInvolving& from);
  void MergeFrom(const CUserMsg_ParticleManager_DestroyParticleInvolving& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_DestroyParticleInvolving* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool destroy_immediately = 1;
  bool has_destroy_immediately() const;
  void clear_destroy_immediately();
  static const int kDestroyImmediatelyFieldNumber = 1;
  bool destroy_immediately() const;
  void set_destroy_immediately(bool value);

  // optional int32 entity_handle = 3;
  bool has_entity_handle() const;
  void clear_entity_handle();
  static const int kEntityHandleFieldNumber = 3;
  ::google::protobuf::int32 entity_handle() const;
  void set_entity_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving)
 private:
  void set_has_destroy_immediately();
  void clear_has_destroy_immediately();
  void set_has_entity_handle();
  void clear_has_entity_handle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool destroy_immediately_;
  ::google::protobuf::int32 entity_handle_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticle) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticle();
  virtual ~CUserMsg_ParticleManager_UpdateParticle();

  CUserMsg_ParticleManager_UpdateParticle(const CUserMsg_ParticleManager_UpdateParticle& from);

  inline CUserMsg_ParticleManager_UpdateParticle& operator=(const CUserMsg_ParticleManager_UpdateParticle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticle& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticle* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticle*>(
               &_CUserMsg_ParticleManager_UpdateParticle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(CUserMsg_ParticleManager_UpdateParticle* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticle* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticle& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::proto::dota::CMsgVector& position() const;
  ::proto::dota::CMsgVector* mutable_position();
  ::proto::dota::CMsgVector* release_position();
  void set_allocated_position(::proto::dota::CMsgVector* position);

  // optional int32 control_point = 1;
  bool has_control_point() const;
  void clear_control_point();
  static const int kControlPointFieldNumber = 1;
  ::google::protobuf::int32 control_point() const;
  void set_control_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticle)
 private:
  void set_has_control_point();
  void clear_has_control_point();
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* position_;
  ::google::protobuf::int32 control_point_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleFwd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleFwd();
  virtual ~CUserMsg_ParticleManager_UpdateParticleFwd();

  CUserMsg_ParticleManager_UpdateParticleFwd(const CUserMsg_ParticleManager_UpdateParticleFwd& from);

  inline CUserMsg_ParticleManager_UpdateParticleFwd& operator=(const CUserMsg_ParticleManager_UpdateParticleFwd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleFwd& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleFwd* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleFwd*>(
               &_CUserMsg_ParticleManager_UpdateParticleFwd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(CUserMsg_ParticleManager_UpdateParticleFwd* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleFwd* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleFwd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleFwd& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleFwd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleFwd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector forward = 2;
  bool has_forward() const;
  void clear_forward();
  static const int kForwardFieldNumber = 2;
  const ::proto::dota::CMsgVector& forward() const;
  ::proto::dota::CMsgVector* mutable_forward();
  ::proto::dota::CMsgVector* release_forward();
  void set_allocated_forward(::proto::dota::CMsgVector* forward);

  // optional int32 control_point = 1;
  bool has_control_point() const;
  void clear_control_point();
  static const int kControlPointFieldNumber = 1;
  ::google::protobuf::int32 control_point() const;
  void set_control_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd)
 private:
  void set_has_control_point();
  void clear_has_control_point();
  void set_has_forward();
  void clear_has_forward();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* forward_;
  ::google::protobuf::int32 control_point_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleOrient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleOrient();
  virtual ~CUserMsg_ParticleManager_UpdateParticleOrient();

  CUserMsg_ParticleManager_UpdateParticleOrient(const CUserMsg_ParticleManager_UpdateParticleOrient& from);

  inline CUserMsg_ParticleManager_UpdateParticleOrient& operator=(const CUserMsg_ParticleManager_UpdateParticleOrient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleOrient& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleOrient* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleOrient*>(
               &_CUserMsg_ParticleManager_UpdateParticleOrient_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(CUserMsg_ParticleManager_UpdateParticleOrient* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleOrient* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleOrient* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleOrient& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleOrient& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleOrient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector forward = 2;
  bool has_forward() const;
  void clear_forward();
  static const int kForwardFieldNumber = 2;
  const ::proto::dota::CMsgVector& forward() const;
  ::proto::dota::CMsgVector* mutable_forward();
  ::proto::dota::CMsgVector* release_forward();
  void set_allocated_forward(::proto::dota::CMsgVector* forward);

  // optional .proto.dota.CMsgVector right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  const ::proto::dota::CMsgVector& right() const;
  ::proto::dota::CMsgVector* mutable_right();
  ::proto::dota::CMsgVector* release_right();
  void set_allocated_right(::proto::dota::CMsgVector* right);

  // optional .proto.dota.CMsgVector up = 4;
  bool has_up() const;
  void clear_up();
  static const int kUpFieldNumber = 4;
  const ::proto::dota::CMsgVector& up() const;
  ::proto::dota::CMsgVector* mutable_up();
  ::proto::dota::CMsgVector* release_up();
  void set_allocated_up(::proto::dota::CMsgVector* up);

  // optional int32 control_point = 1;
  bool has_control_point() const;
  void clear_control_point();
  static const int kControlPointFieldNumber = 1;
  ::google::protobuf::int32 control_point() const;
  void set_control_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient)
 private:
  void set_has_control_point();
  void clear_has_control_point();
  void set_has_forward();
  void clear_has_forward();
  void set_has_right();
  void clear_has_right();
  void set_has_up();
  void clear_has_up();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* forward_;
  ::proto::dota::CMsgVector* right_;
  ::proto::dota::CMsgVector* up_;
  ::google::protobuf::int32 control_point_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleFallback : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleFallback();
  virtual ~CUserMsg_ParticleManager_UpdateParticleFallback();

  CUserMsg_ParticleManager_UpdateParticleFallback(const CUserMsg_ParticleManager_UpdateParticleFallback& from);

  inline CUserMsg_ParticleManager_UpdateParticleFallback& operator=(const CUserMsg_ParticleManager_UpdateParticleFallback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleFallback& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleFallback* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleFallback*>(
               &_CUserMsg_ParticleManager_UpdateParticleFallback_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(CUserMsg_ParticleManager_UpdateParticleFallback* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleFallback* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleFallback* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleFallback& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleFallback& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleFallback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::proto::dota::CMsgVector& position() const;
  ::proto::dota::CMsgVector* mutable_position();
  ::proto::dota::CMsgVector* release_position();
  void set_allocated_position(::proto::dota::CMsgVector* position);

  // optional int32 control_point = 1;
  bool has_control_point() const;
  void clear_control_point();
  static const int kControlPointFieldNumber = 1;
  ::google::protobuf::int32 control_point() const;
  void set_control_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback)
 private:
  void set_has_control_point();
  void clear_has_control_point();
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* position_;
  ::google::protobuf::int32 control_point_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleOffset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleOffset();
  virtual ~CUserMsg_ParticleManager_UpdateParticleOffset();

  CUserMsg_ParticleManager_UpdateParticleOffset(const CUserMsg_ParticleManager_UpdateParticleOffset& from);

  inline CUserMsg_ParticleManager_UpdateParticleOffset& operator=(const CUserMsg_ParticleManager_UpdateParticleOffset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleOffset& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleOffset* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleOffset*>(
               &_CUserMsg_ParticleManager_UpdateParticleOffset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(CUserMsg_ParticleManager_UpdateParticleOffset* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleOffset* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleOffset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleOffset& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleOffset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleOffset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin_offset = 2;
  bool has_origin_offset() const;
  void clear_origin_offset();
  static const int kOriginOffsetFieldNumber = 2;
  const ::proto::dota::CMsgVector& origin_offset() const;
  ::proto::dota::CMsgVector* mutable_origin_offset();
  ::proto::dota::CMsgVector* release_origin_offset();
  void set_allocated_origin_offset(::proto::dota::CMsgVector* origin_offset);

  // optional int32 control_point = 1;
  bool has_control_point() const;
  void clear_control_point();
  static const int kControlPointFieldNumber = 1;
  ::google::protobuf::int32 control_point() const;
  void set_control_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset)
 private:
  void set_has_control_point();
  void clear_has_control_point();
  void set_has_origin_offset();
  void clear_has_origin_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_offset_;
  ::google::protobuf::int32 control_point_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleEnt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleEnt();
  virtual ~CUserMsg_ParticleManager_UpdateParticleEnt();

  CUserMsg_ParticleManager_UpdateParticleEnt(const CUserMsg_ParticleManager_UpdateParticleEnt& from);

  inline CUserMsg_ParticleManager_UpdateParticleEnt& operator=(const CUserMsg_ParticleManager_UpdateParticleEnt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleEnt& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleEnt* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleEnt*>(
               &_CUserMsg_ParticleManager_UpdateParticleEnt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(CUserMsg_ParticleManager_UpdateParticleEnt* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleEnt* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleEnt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleEnt& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleEnt& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleEnt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector fallback_position = 5;
  bool has_fallback_position() const;
  void clear_fallback_position();
  static const int kFallbackPositionFieldNumber = 5;
  const ::proto::dota::CMsgVector& fallback_position() const;
  ::proto::dota::CMsgVector* mutable_fallback_position();
  ::proto::dota::CMsgVector* release_fallback_position();
  void set_allocated_fallback_position(::proto::dota::CMsgVector* fallback_position);

  // optional int32 control_point = 1;
  bool has_control_point() const;
  void clear_control_point();
  static const int kControlPointFieldNumber = 1;
  ::google::protobuf::int32 control_point() const;
  void set_control_point(::google::protobuf::int32 value);

  // optional int32 entity_handle = 2;
  bool has_entity_handle() const;
  void clear_entity_handle();
  static const int kEntityHandleFieldNumber = 2;
  ::google::protobuf::int32 entity_handle() const;
  void set_entity_handle(::google::protobuf::int32 value);

  // optional int32 attach_type = 3;
  bool has_attach_type() const;
  void clear_attach_type();
  static const int kAttachTypeFieldNumber = 3;
  ::google::protobuf::int32 attach_type() const;
  void set_attach_type(::google::protobuf::int32 value);

  // optional int32 attachment = 4;
  bool has_attachment() const;
  void clear_attachment();
  static const int kAttachmentFieldNumber = 4;
  ::google::protobuf::int32 attachment() const;
  void set_attachment(::google::protobuf::int32 value);

  // optional bool include_wearables = 6;
  bool has_include_wearables() const;
  void clear_include_wearables();
  static const int kIncludeWearablesFieldNumber = 6;
  bool include_wearables() const;
  void set_include_wearables(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt)
 private:
  void set_has_control_point();
  void clear_has_control_point();
  void set_has_entity_handle();
  void clear_has_entity_handle();
  void set_has_attach_type();
  void clear_has_attach_type();
  void set_has_attachment();
  void clear_has_attachment();
  void set_has_fallback_position();
  void clear_has_fallback_position();
  void set_has_include_wearables();
  void clear_has_include_wearables();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* fallback_position_;
  ::google::protobuf::int32 control_point_;
  ::google::protobuf::int32 entity_handle_;
  ::google::protobuf::int32 attach_type_;
  ::google::protobuf::int32 attachment_;
  bool include_wearables_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleSetFrozen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleSetFrozen) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleSetFrozen();
  virtual ~CUserMsg_ParticleManager_UpdateParticleSetFrozen();

  CUserMsg_ParticleManager_UpdateParticleSetFrozen(const CUserMsg_ParticleManager_UpdateParticleSetFrozen& from);

  inline CUserMsg_ParticleManager_UpdateParticleSetFrozen& operator=(const CUserMsg_ParticleManager_UpdateParticleSetFrozen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleSetFrozen& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleSetFrozen* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleSetFrozen*>(
               &_CUserMsg_ParticleManager_UpdateParticleSetFrozen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(CUserMsg_ParticleManager_UpdateParticleSetFrozen* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleSetFrozen* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleSetFrozen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleSetFrozen& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleSetFrozen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleSetFrozen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool set_frozen = 1;
  bool has_set_frozen() const;
  void clear_set_frozen();
  static const int kSetFrozenFieldNumber = 1;
  bool set_frozen() const;
  void set_set_frozen(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleSetFrozen)
 private:
  void set_has_set_frozen();
  void clear_has_set_frozen();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool set_frozen_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_UpdateParticleShouldDraw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.UpdateParticleShouldDraw) */ {
 public:
  CUserMsg_ParticleManager_UpdateParticleShouldDraw();
  virtual ~CUserMsg_ParticleManager_UpdateParticleShouldDraw();

  CUserMsg_ParticleManager_UpdateParticleShouldDraw(const CUserMsg_ParticleManager_UpdateParticleShouldDraw& from);

  inline CUserMsg_ParticleManager_UpdateParticleShouldDraw& operator=(const CUserMsg_ParticleManager_UpdateParticleShouldDraw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_UpdateParticleShouldDraw& default_instance();

  static inline const CUserMsg_ParticleManager_UpdateParticleShouldDraw* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_UpdateParticleShouldDraw*>(
               &_CUserMsg_ParticleManager_UpdateParticleShouldDraw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(CUserMsg_ParticleManager_UpdateParticleShouldDraw* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_UpdateParticleShouldDraw* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_UpdateParticleShouldDraw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_UpdateParticleShouldDraw& from);
  void MergeFrom(const CUserMsg_ParticleManager_UpdateParticleShouldDraw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_UpdateParticleShouldDraw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool should_draw = 1;
  bool has_should_draw() const;
  void clear_should_draw();
  static const int kShouldDrawFieldNumber = 1;
  bool should_draw() const;
  void set_should_draw(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.UpdateParticleShouldDraw)
 private:
  void set_has_should_draw();
  void clear_has_should_draw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool should_draw_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager_ChangeControlPointAttachment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment) */ {
 public:
  CUserMsg_ParticleManager_ChangeControlPointAttachment();
  virtual ~CUserMsg_ParticleManager_ChangeControlPointAttachment();

  CUserMsg_ParticleManager_ChangeControlPointAttachment(const CUserMsg_ParticleManager_ChangeControlPointAttachment& from);

  inline CUserMsg_ParticleManager_ChangeControlPointAttachment& operator=(const CUserMsg_ParticleManager_ChangeControlPointAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager_ChangeControlPointAttachment& default_instance();

  static inline const CUserMsg_ParticleManager_ChangeControlPointAttachment* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager_ChangeControlPointAttachment*>(
               &_CUserMsg_ParticleManager_ChangeControlPointAttachment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(CUserMsg_ParticleManager_ChangeControlPointAttachment* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager_ChangeControlPointAttachment* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager_ChangeControlPointAttachment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager_ChangeControlPointAttachment& from);
  void MergeFrom(const CUserMsg_ParticleManager_ChangeControlPointAttachment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager_ChangeControlPointAttachment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 attachment_old = 1;
  bool has_attachment_old() const;
  void clear_attachment_old();
  static const int kAttachmentOldFieldNumber = 1;
  ::google::protobuf::int32 attachment_old() const;
  void set_attachment_old(::google::protobuf::int32 value);

  // optional int32 attachment_new = 2;
  bool has_attachment_new() const;
  void clear_attachment_new();
  static const int kAttachmentNewFieldNumber = 2;
  ::google::protobuf::int32 attachment_new() const;
  void set_attachment_new(::google::protobuf::int32 value);

  // optional int32 entity_handle = 3;
  bool has_entity_handle() const;
  void clear_entity_handle();
  static const int kEntityHandleFieldNumber = 3;
  ::google::protobuf::int32 entity_handle() const;
  void set_entity_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment)
 private:
  void set_has_attachment_old();
  void clear_has_attachment_old();
  void set_has_attachment_new();
  void clear_has_attachment_new();
  void set_has_entity_handle();
  void clear_has_entity_handle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 attachment_old_;
  ::google::protobuf::int32 attachment_new_;
  ::google::protobuf::int32 entity_handle_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_ParticleManager : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_ParticleManager) */ {
 public:
  CUserMsg_ParticleManager();
  virtual ~CUserMsg_ParticleManager();

  CUserMsg_ParticleManager(const CUserMsg_ParticleManager& from);

  inline CUserMsg_ParticleManager& operator=(const CUserMsg_ParticleManager& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_ParticleManager& default_instance();

  static inline const CUserMsg_ParticleManager* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_ParticleManager*>(
               &_CUserMsg_ParticleManager_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(CUserMsg_ParticleManager* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_ParticleManager* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_ParticleManager* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_ParticleManager& from);
  void MergeFrom(const CUserMsg_ParticleManager& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_ParticleManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CUserMsg_ParticleManager_ReleaseParticleIndex ReleaseParticleIndex;
  typedef CUserMsg_ParticleManager_CreateParticle CreateParticle;
  typedef CUserMsg_ParticleManager_DestroyParticle DestroyParticle;
  typedef CUserMsg_ParticleManager_DestroyParticleInvolving DestroyParticleInvolving;
  typedef CUserMsg_ParticleManager_UpdateParticle UpdateParticle;
  typedef CUserMsg_ParticleManager_UpdateParticleFwd UpdateParticleFwd;
  typedef CUserMsg_ParticleManager_UpdateParticleOrient UpdateParticleOrient;
  typedef CUserMsg_ParticleManager_UpdateParticleFallback UpdateParticleFallback;
  typedef CUserMsg_ParticleManager_UpdateParticleOffset UpdateParticleOffset;
  typedef CUserMsg_ParticleManager_UpdateParticleEnt UpdateParticleEnt;
  typedef CUserMsg_ParticleManager_UpdateParticleSetFrozen UpdateParticleSetFrozen;
  typedef CUserMsg_ParticleManager_UpdateParticleShouldDraw UpdateParticleShouldDraw;
  typedef CUserMsg_ParticleManager_ChangeControlPointAttachment ChangeControlPointAttachment;

  // accessors -------------------------------------------------------

  // optional .proto.dota.CUserMsg_ParticleManager.ReleaseParticleIndex release_particle_index = 3;
  bool has_release_particle_index() const;
  void clear_release_particle_index();
  static const int kReleaseParticleIndexFieldNumber = 3;
  const ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex& release_particle_index() const;
  ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* mutable_release_particle_index();
  ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* release_release_particle_index();
  void set_allocated_release_particle_index(::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* release_particle_index);

  // optional .proto.dota.CUserMsg_ParticleManager.CreateParticle create_particle = 4;
  bool has_create_particle() const;
  void clear_create_particle();
  static const int kCreateParticleFieldNumber = 4;
  const ::proto::dota::CUserMsg_ParticleManager_CreateParticle& create_particle() const;
  ::proto::dota::CUserMsg_ParticleManager_CreateParticle* mutable_create_particle();
  ::proto::dota::CUserMsg_ParticleManager_CreateParticle* release_create_particle();
  void set_allocated_create_particle(::proto::dota::CUserMsg_ParticleManager_CreateParticle* create_particle);

  // optional .proto.dota.CUserMsg_ParticleManager.DestroyParticle destroy_particle = 5;
  bool has_destroy_particle() const;
  void clear_destroy_particle();
  static const int kDestroyParticleFieldNumber = 5;
  const ::proto::dota::CUserMsg_ParticleManager_DestroyParticle& destroy_particle() const;
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticle* mutable_destroy_particle();
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticle* release_destroy_particle();
  void set_allocated_destroy_particle(::proto::dota::CUserMsg_ParticleManager_DestroyParticle* destroy_particle);

  // optional .proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving destroy_particle_involving = 6;
  bool has_destroy_particle_involving() const;
  void clear_destroy_particle_involving();
  static const int kDestroyParticleInvolvingFieldNumber = 6;
  const ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving& destroy_particle_involving() const;
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* mutable_destroy_particle_involving();
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* release_destroy_particle_involving();
  void set_allocated_destroy_particle_involving(::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* destroy_particle_involving);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticle update_particle = 7;
  bool has_update_particle() const;
  void clear_update_particle();
  static const int kUpdateParticleFieldNumber = 7;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticle& update_particle() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticle* mutable_update_particle();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticle* release_update_particle();
  void set_allocated_update_particle(::proto::dota::CUserMsg_ParticleManager_UpdateParticle* update_particle);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd update_particle_fwd = 8;
  bool has_update_particle_fwd() const;
  void clear_update_particle_fwd();
  static const int kUpdateParticleFwdFieldNumber = 8;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd& update_particle_fwd() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* mutable_update_particle_fwd();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* release_update_particle_fwd();
  void set_allocated_update_particle_fwd(::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* update_particle_fwd);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient update_particle_orient = 9;
  bool has_update_particle_orient() const;
  void clear_update_particle_orient();
  static const int kUpdateParticleOrientFieldNumber = 9;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient& update_particle_orient() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* mutable_update_particle_orient();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* release_update_particle_orient();
  void set_allocated_update_particle_orient(::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* update_particle_orient);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback update_particle_fallback = 10;
  bool has_update_particle_fallback() const;
  void clear_update_particle_fallback();
  static const int kUpdateParticleFallbackFieldNumber = 10;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback& update_particle_fallback() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* mutable_update_particle_fallback();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* release_update_particle_fallback();
  void set_allocated_update_particle_fallback(::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* update_particle_fallback);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset update_particle_offset = 11;
  bool has_update_particle_offset() const;
  void clear_update_particle_offset();
  static const int kUpdateParticleOffsetFieldNumber = 11;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset& update_particle_offset() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* mutable_update_particle_offset();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* release_update_particle_offset();
  void set_allocated_update_particle_offset(::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* update_particle_offset);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt update_particle_ent = 12;
  bool has_update_particle_ent() const;
  void clear_update_particle_ent();
  static const int kUpdateParticleEntFieldNumber = 12;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt& update_particle_ent() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* mutable_update_particle_ent();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* release_update_particle_ent();
  void set_allocated_update_particle_ent(::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* update_particle_ent);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleShouldDraw update_particle_should_draw = 14;
  bool has_update_particle_should_draw() const;
  void clear_update_particle_should_draw();
  static const int kUpdateParticleShouldDrawFieldNumber = 14;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw& update_particle_should_draw() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* mutable_update_particle_should_draw();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* release_update_particle_should_draw();
  void set_allocated_update_particle_should_draw(::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* update_particle_should_draw);

  // optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleSetFrozen update_particle_set_frozen = 15;
  bool has_update_particle_set_frozen() const;
  void clear_update_particle_set_frozen();
  static const int kUpdateParticleSetFrozenFieldNumber = 15;
  const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen& update_particle_set_frozen() const;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* mutable_update_particle_set_frozen();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* release_update_particle_set_frozen();
  void set_allocated_update_particle_set_frozen(::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* update_particle_set_frozen);

  // optional .proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment change_control_point_attachment = 16;
  bool has_change_control_point_attachment() const;
  void clear_change_control_point_attachment();
  static const int kChangeControlPointAttachmentFieldNumber = 16;
  const ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment& change_control_point_attachment() const;
  ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* mutable_change_control_point_attachment();
  ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* release_change_control_point_attachment();
  void set_allocated_change_control_point_attachment(::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* change_control_point_attachment);

  // required .proto.dota.PARTICLE_MESSAGE type = 1 [default = GAME_PARTICLE_MANAGER_EVENT_CREATE];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::dota::PARTICLE_MESSAGE type() const;
  void set_type(::proto::dota::PARTICLE_MESSAGE value);

  // required uint32 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_ParticleManager)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_index();
  void clear_has_index();
  void set_has_release_particle_index();
  void clear_has_release_particle_index();
  void set_has_create_particle();
  void clear_has_create_particle();
  void set_has_destroy_particle();
  void clear_has_destroy_particle();
  void set_has_destroy_particle_involving();
  void clear_has_destroy_particle_involving();
  void set_has_update_particle();
  void clear_has_update_particle();
  void set_has_update_particle_fwd();
  void clear_has_update_particle_fwd();
  void set_has_update_particle_orient();
  void clear_has_update_particle_orient();
  void set_has_update_particle_fallback();
  void clear_has_update_particle_fallback();
  void set_has_update_particle_offset();
  void clear_has_update_particle_offset();
  void set_has_update_particle_ent();
  void clear_has_update_particle_ent();
  void set_has_update_particle_should_draw();
  void clear_has_update_particle_should_draw();
  void set_has_update_particle_set_frozen();
  void clear_has_update_particle_set_frozen();
  void set_has_change_control_point_attachment();
  void clear_has_change_control_point_attachment();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* release_particle_index_;
  ::proto::dota::CUserMsg_ParticleManager_CreateParticle* create_particle_;
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticle* destroy_particle_;
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* destroy_particle_involving_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticle* update_particle_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* update_particle_fwd_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* update_particle_orient_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* update_particle_fallback_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* update_particle_offset_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* update_particle_ent_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* update_particle_should_draw_;
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* update_particle_set_frozen_;
  ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* change_control_point_attachment_;
  int type_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_HudError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_HudError) */ {
 public:
  CUserMsg_HudError();
  virtual ~CUserMsg_HudError();

  CUserMsg_HudError(const CUserMsg_HudError& from);

  inline CUserMsg_HudError& operator=(const CUserMsg_HudError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_HudError& default_instance();

  static inline const CUserMsg_HudError* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_HudError*>(
               &_CUserMsg_HudError_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(CUserMsg_HudError* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_HudError* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_HudError* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_HudError& from);
  void MergeFrom(const CUserMsg_HudError& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_HudError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 order_id = 1;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  ::google::protobuf::int32 order_id() const;
  void set_order_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_HudError)
 private:
  void set_has_order_id();
  void clear_has_order_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 order_id_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMsg_CustomGameEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMsg_CustomGameEvent) */ {
 public:
  CUserMsg_CustomGameEvent();
  virtual ~CUserMsg_CustomGameEvent();

  CUserMsg_CustomGameEvent(const CUserMsg_CustomGameEvent& from);

  inline CUserMsg_CustomGameEvent& operator=(const CUserMsg_CustomGameEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMsg_CustomGameEvent& default_instance();

  static inline const CUserMsg_CustomGameEvent* internal_default_instance() {
    return reinterpret_cast<const CUserMsg_CustomGameEvent*>(
               &_CUserMsg_CustomGameEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(CUserMsg_CustomGameEvent* other);

  // implements Message ----------------------------------------------

  inline CUserMsg_CustomGameEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMsg_CustomGameEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMsg_CustomGameEvent& from);
  void MergeFrom(const CUserMsg_CustomGameEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMsg_CustomGameEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string event_name = 1;
  bool has_event_name() const;
  void clear_event_name();
  static const int kEventNameFieldNumber = 1;
  const ::std::string& event_name() const;
  void set_event_name(const ::std::string& value);
  #if LANG_CXX11
  void set_event_name(::std::string&& value);
  #endif
  void set_event_name(const char* value);
  void set_event_name(const char* value, size_t size);
  ::std::string* mutable_event_name();
  ::std::string* release_event_name();
  void set_allocated_event_name(::std::string* event_name);

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMsg_CustomGameEvent)
 private:
  void set_has_event_name();
  void clear_has_event_name();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr event_name_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageHapticPulse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageHapticPulse) */ {
 public:
  CUserMessageHapticPulse();
  virtual ~CUserMessageHapticPulse();

  CUserMessageHapticPulse(const CUserMessageHapticPulse& from);

  inline CUserMessageHapticPulse& operator=(const CUserMessageHapticPulse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageHapticPulse& default_instance();

  static inline const CUserMessageHapticPulse* internal_default_instance() {
    return reinterpret_cast<const CUserMessageHapticPulse*>(
               &_CUserMessageHapticPulse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(CUserMessageHapticPulse* other);

  // implements Message ----------------------------------------------

  inline CUserMessageHapticPulse* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageHapticPulse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageHapticPulse& from);
  void MergeFrom(const CUserMessageHapticPulse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageHapticPulse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hand_id = 1;
  bool has_hand_id() const;
  void clear_hand_id();
  static const int kHandIdFieldNumber = 1;
  ::google::protobuf::int32 hand_id() const;
  void set_hand_id(::google::protobuf::int32 value);

  // optional .proto.dota.EHapticPulseType pulse_type = 2 [default = VR_HAND_HAPTIC_PULSE_LIGHT];
  bool has_pulse_type() const;
  void clear_pulse_type();
  static const int kPulseTypeFieldNumber = 2;
  ::proto::dota::EHapticPulseType pulse_type() const;
  void set_pulse_type(::proto::dota::EHapticPulseType value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageHapticPulse)
 private:
  void set_has_hand_id();
  void clear_has_hand_id();
  void set_has_pulse_type();
  void clear_has_pulse_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 hand_id_;
  int pulse_type_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageHapticPulsePrecise : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageHapticPulsePrecise) */ {
 public:
  CUserMessageHapticPulsePrecise();
  virtual ~CUserMessageHapticPulsePrecise();

  CUserMessageHapticPulsePrecise(const CUserMessageHapticPulsePrecise& from);

  inline CUserMessageHapticPulsePrecise& operator=(const CUserMessageHapticPulsePrecise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageHapticPulsePrecise& default_instance();

  static inline const CUserMessageHapticPulsePrecise* internal_default_instance() {
    return reinterpret_cast<const CUserMessageHapticPulsePrecise*>(
               &_CUserMessageHapticPulsePrecise_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(CUserMessageHapticPulsePrecise* other);

  // implements Message ----------------------------------------------

  inline CUserMessageHapticPulsePrecise* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageHapticPulsePrecise* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageHapticPulsePrecise& from);
  void MergeFrom(const CUserMessageHapticPulsePrecise& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageHapticPulsePrecise* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hand_id = 1;
  bool has_hand_id() const;
  void clear_hand_id();
  static const int kHandIdFieldNumber = 1;
  ::google::protobuf::int32 hand_id() const;
  void set_hand_id(::google::protobuf::int32 value);

  // optional int32 pulse_duration = 2;
  bool has_pulse_duration() const;
  void clear_pulse_duration();
  static const int kPulseDurationFieldNumber = 2;
  ::google::protobuf::int32 pulse_duration() const;
  void set_pulse_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageHapticPulsePrecise)
 private:
  void set_has_hand_id();
  void clear_has_hand_id();
  void set_has_pulse_duration();
  void clear_has_pulse_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 hand_id_;
  ::google::protobuf::int32 pulse_duration_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CUserMessageAnimStateGraphState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CUserMessageAnimStateGraphState) */ {
 public:
  CUserMessageAnimStateGraphState();
  virtual ~CUserMessageAnimStateGraphState();

  CUserMessageAnimStateGraphState(const CUserMessageAnimStateGraphState& from);

  inline CUserMessageAnimStateGraphState& operator=(const CUserMessageAnimStateGraphState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserMessageAnimStateGraphState& default_instance();

  static inline const CUserMessageAnimStateGraphState* internal_default_instance() {
    return reinterpret_cast<const CUserMessageAnimStateGraphState*>(
               &_CUserMessageAnimStateGraphState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(CUserMessageAnimStateGraphState* other);

  // implements Message ----------------------------------------------

  inline CUserMessageAnimStateGraphState* New() const PROTOBUF_FINAL { return New(NULL); }

  CUserMessageAnimStateGraphState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CUserMessageAnimStateGraphState& from);
  void MergeFrom(const CUserMessageAnimStateGraphState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CUserMessageAnimStateGraphState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional int32 entity_index = 1;
  bool has_entity_index() const;
  void clear_entity_index();
  static const int kEntityIndexFieldNumber = 1;
  ::google::protobuf::int32 entity_index() const;
  void set_entity_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CUserMessageAnimStateGraphState)
 private:
  void set_has_entity_index();
  void clear_has_entity_index();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 entity_index_;
  friend struct protobuf_usermessages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CUserMessageAchievementEvent

// optional uint32 achievement = 1;
inline bool CUserMessageAchievementEvent::has_achievement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageAchievementEvent::set_has_achievement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageAchievementEvent::clear_has_achievement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageAchievementEvent::clear_achievement() {
  achievement_ = 0u;
  clear_has_achievement();
}
inline ::google::protobuf::uint32 CUserMessageAchievementEvent::achievement() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAchievementEvent.achievement)
  return achievement_;
}
inline void CUserMessageAchievementEvent::set_achievement(::google::protobuf::uint32 value) {
  set_has_achievement();
  achievement_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAchievementEvent.achievement)
}

// -------------------------------------------------------------------

// CUserMessageCloseCaption

// optional fixed32 hash = 1;
inline bool CUserMessageCloseCaption::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCloseCaption::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCloseCaption::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCloseCaption::clear_hash() {
  hash_ = 0u;
  clear_has_hash();
}
inline ::google::protobuf::uint32 CUserMessageCloseCaption::hash() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaption.hash)
  return hash_;
}
inline void CUserMessageCloseCaption::set_hash(::google::protobuf::uint32 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaption.hash)
}

// optional float duration = 2;
inline bool CUserMessageCloseCaption::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageCloseCaption::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageCloseCaption::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageCloseCaption::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CUserMessageCloseCaption::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaption.duration)
  return duration_;
}
inline void CUserMessageCloseCaption::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaption.duration)
}

// optional bool from_player = 3;
inline bool CUserMessageCloseCaption::has_from_player() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageCloseCaption::set_has_from_player() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageCloseCaption::clear_has_from_player() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageCloseCaption::clear_from_player() {
  from_player_ = false;
  clear_has_from_player();
}
inline bool CUserMessageCloseCaption::from_player() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaption.from_player)
  return from_player_;
}
inline void CUserMessageCloseCaption::set_from_player(bool value) {
  set_has_from_player();
  from_player_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaption.from_player)
}

// optional int32 ent_index = 4;
inline bool CUserMessageCloseCaption::has_ent_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageCloseCaption::set_has_ent_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageCloseCaption::clear_has_ent_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageCloseCaption::clear_ent_index() {
  ent_index_ = 0;
  clear_has_ent_index();
}
inline ::google::protobuf::int32 CUserMessageCloseCaption::ent_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaption.ent_index)
  return ent_index_;
}
inline void CUserMessageCloseCaption::set_ent_index(::google::protobuf::int32 value) {
  set_has_ent_index();
  ent_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaption.ent_index)
}

// -------------------------------------------------------------------

// CUserMessageCloseCaptionDirect

// optional fixed32 hash = 1;
inline bool CUserMessageCloseCaptionDirect::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCloseCaptionDirect::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCloseCaptionDirect::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCloseCaptionDirect::clear_hash() {
  hash_ = 0u;
  clear_has_hash();
}
inline ::google::protobuf::uint32 CUserMessageCloseCaptionDirect::hash() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionDirect.hash)
  return hash_;
}
inline void CUserMessageCloseCaptionDirect::set_hash(::google::protobuf::uint32 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionDirect.hash)
}

// optional float duration = 2;
inline bool CUserMessageCloseCaptionDirect::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageCloseCaptionDirect::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageCloseCaptionDirect::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageCloseCaptionDirect::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CUserMessageCloseCaptionDirect::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionDirect.duration)
  return duration_;
}
inline void CUserMessageCloseCaptionDirect::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionDirect.duration)
}

// optional bool from_player = 3;
inline bool CUserMessageCloseCaptionDirect::has_from_player() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageCloseCaptionDirect::set_has_from_player() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageCloseCaptionDirect::clear_has_from_player() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageCloseCaptionDirect::clear_from_player() {
  from_player_ = false;
  clear_has_from_player();
}
inline bool CUserMessageCloseCaptionDirect::from_player() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionDirect.from_player)
  return from_player_;
}
inline void CUserMessageCloseCaptionDirect::set_from_player(bool value) {
  set_has_from_player();
  from_player_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionDirect.from_player)
}

// optional int32 ent_index = 4;
inline bool CUserMessageCloseCaptionDirect::has_ent_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageCloseCaptionDirect::set_has_ent_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageCloseCaptionDirect::clear_has_ent_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageCloseCaptionDirect::clear_ent_index() {
  ent_index_ = 0;
  clear_has_ent_index();
}
inline ::google::protobuf::int32 CUserMessageCloseCaptionDirect::ent_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionDirect.ent_index)
  return ent_index_;
}
inline void CUserMessageCloseCaptionDirect::set_ent_index(::google::protobuf::int32 value) {
  set_has_ent_index();
  ent_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionDirect.ent_index)
}

// -------------------------------------------------------------------

// CUserMessageCloseCaptionPlaceholder

// optional string string = 1;
inline bool CUserMessageCloseCaptionPlaceholder::has_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCloseCaptionPlaceholder::set_has_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_has_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_string() {
  string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_string();
}
inline const ::std::string& CUserMessageCloseCaptionPlaceholder::string() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
  return string_.GetNoArena();
}
inline void CUserMessageCloseCaptionPlaceholder::set_string(const ::std::string& value) {
  set_has_string();
  string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
}
#if LANG_CXX11
inline void CUserMessageCloseCaptionPlaceholder::set_string(::std::string&& value) {
  set_has_string();
  string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
}
#endif
inline void CUserMessageCloseCaptionPlaceholder::set_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_string();
  string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
}
inline void CUserMessageCloseCaptionPlaceholder::set_string(const char* value, size_t size) {
  set_has_string();
  string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
}
inline ::std::string* CUserMessageCloseCaptionPlaceholder::mutable_string() {
  set_has_string();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
  return string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageCloseCaptionPlaceholder::release_string() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
  clear_has_string();
  return string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageCloseCaptionPlaceholder::set_allocated_string(::std::string* string) {
  if (string != NULL) {
    set_has_string();
  } else {
    clear_has_string();
  }
  string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageCloseCaptionPlaceholder.string)
}

// optional float duration = 2;
inline bool CUserMessageCloseCaptionPlaceholder::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageCloseCaptionPlaceholder::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CUserMessageCloseCaptionPlaceholder::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionPlaceholder.duration)
  return duration_;
}
inline void CUserMessageCloseCaptionPlaceholder::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionPlaceholder.duration)
}

// optional bool from_player = 3;
inline bool CUserMessageCloseCaptionPlaceholder::has_from_player() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageCloseCaptionPlaceholder::set_has_from_player() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_has_from_player() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_from_player() {
  from_player_ = false;
  clear_has_from_player();
}
inline bool CUserMessageCloseCaptionPlaceholder::from_player() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionPlaceholder.from_player)
  return from_player_;
}
inline void CUserMessageCloseCaptionPlaceholder::set_from_player(bool value) {
  set_has_from_player();
  from_player_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionPlaceholder.from_player)
}

// optional int32 ent_index = 4;
inline bool CUserMessageCloseCaptionPlaceholder::has_ent_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageCloseCaptionPlaceholder::set_has_ent_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_has_ent_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageCloseCaptionPlaceholder::clear_ent_index() {
  ent_index_ = 0;
  clear_has_ent_index();
}
inline ::google::protobuf::int32 CUserMessageCloseCaptionPlaceholder::ent_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCloseCaptionPlaceholder.ent_index)
  return ent_index_;
}
inline void CUserMessageCloseCaptionPlaceholder::set_ent_index(::google::protobuf::int32 value) {
  set_has_ent_index();
  ent_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCloseCaptionPlaceholder.ent_index)
}

// -------------------------------------------------------------------

// CUserMessageCurrentTimescale

// optional float current = 1;
inline bool CUserMessageCurrentTimescale::has_current() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCurrentTimescale::set_has_current() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCurrentTimescale::clear_has_current() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCurrentTimescale::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float CUserMessageCurrentTimescale::current() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCurrentTimescale.current)
  return current_;
}
inline void CUserMessageCurrentTimescale::set_current(float value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCurrentTimescale.current)
}

// -------------------------------------------------------------------

// CUserMessageDesiredTimescale

// optional float desired = 1;
inline bool CUserMessageDesiredTimescale::has_desired() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageDesiredTimescale::set_has_desired() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageDesiredTimescale::clear_has_desired() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageDesiredTimescale::clear_desired() {
  desired_ = 0;
  clear_has_desired();
}
inline float CUserMessageDesiredTimescale::desired() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageDesiredTimescale.desired)
  return desired_;
}
inline void CUserMessageDesiredTimescale::set_desired(float value) {
  set_has_desired();
  desired_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageDesiredTimescale.desired)
}

// optional float acceleration = 2;
inline bool CUserMessageDesiredTimescale::has_acceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageDesiredTimescale::set_has_acceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageDesiredTimescale::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageDesiredTimescale::clear_acceleration() {
  acceleration_ = 0;
  clear_has_acceleration();
}
inline float CUserMessageDesiredTimescale::acceleration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageDesiredTimescale.acceleration)
  return acceleration_;
}
inline void CUserMessageDesiredTimescale::set_acceleration(float value) {
  set_has_acceleration();
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageDesiredTimescale.acceleration)
}

// optional float minblendrate = 3;
inline bool CUserMessageDesiredTimescale::has_minblendrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageDesiredTimescale::set_has_minblendrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageDesiredTimescale::clear_has_minblendrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageDesiredTimescale::clear_minblendrate() {
  minblendrate_ = 0;
  clear_has_minblendrate();
}
inline float CUserMessageDesiredTimescale::minblendrate() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageDesiredTimescale.minblendrate)
  return minblendrate_;
}
inline void CUserMessageDesiredTimescale::set_minblendrate(float value) {
  set_has_minblendrate();
  minblendrate_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageDesiredTimescale.minblendrate)
}

// optional float blenddeltamultiplier = 4;
inline bool CUserMessageDesiredTimescale::has_blenddeltamultiplier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageDesiredTimescale::set_has_blenddeltamultiplier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageDesiredTimescale::clear_has_blenddeltamultiplier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageDesiredTimescale::clear_blenddeltamultiplier() {
  blenddeltamultiplier_ = 0;
  clear_has_blenddeltamultiplier();
}
inline float CUserMessageDesiredTimescale::blenddeltamultiplier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageDesiredTimescale.blenddeltamultiplier)
  return blenddeltamultiplier_;
}
inline void CUserMessageDesiredTimescale::set_blenddeltamultiplier(float value) {
  set_has_blenddeltamultiplier();
  blenddeltamultiplier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageDesiredTimescale.blenddeltamultiplier)
}

// -------------------------------------------------------------------

// CUserMessageFade

// optional uint32 duration = 1;
inline bool CUserMessageFade::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageFade::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageFade::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageFade::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 CUserMessageFade::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageFade.duration)
  return duration_;
}
inline void CUserMessageFade::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageFade.duration)
}

// optional uint32 hold_time = 2;
inline bool CUserMessageFade::has_hold_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageFade::set_has_hold_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageFade::clear_has_hold_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageFade::clear_hold_time() {
  hold_time_ = 0u;
  clear_has_hold_time();
}
inline ::google::protobuf::uint32 CUserMessageFade::hold_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageFade.hold_time)
  return hold_time_;
}
inline void CUserMessageFade::set_hold_time(::google::protobuf::uint32 value) {
  set_has_hold_time();
  hold_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageFade.hold_time)
}

// optional uint32 flags = 3;
inline bool CUserMessageFade::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageFade::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageFade::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageFade::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CUserMessageFade::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageFade.flags)
  return flags_;
}
inline void CUserMessageFade::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageFade.flags)
}

// optional fixed32 color = 4;
inline bool CUserMessageFade::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageFade::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageFade::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageFade::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CUserMessageFade::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageFade.color)
  return color_;
}
inline void CUserMessageFade::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageFade.color)
}

// -------------------------------------------------------------------

// CUserMessageShake

// optional uint32 command = 1;
inline bool CUserMessageShake::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageShake::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageShake::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageShake::clear_command() {
  command_ = 0u;
  clear_has_command();
}
inline ::google::protobuf::uint32 CUserMessageShake::command() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShake.command)
  return command_;
}
inline void CUserMessageShake::set_command(::google::protobuf::uint32 value) {
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShake.command)
}

// optional float amplitude = 2;
inline bool CUserMessageShake::has_amplitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageShake::set_has_amplitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageShake::clear_has_amplitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageShake::clear_amplitude() {
  amplitude_ = 0;
  clear_has_amplitude();
}
inline float CUserMessageShake::amplitude() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShake.amplitude)
  return amplitude_;
}
inline void CUserMessageShake::set_amplitude(float value) {
  set_has_amplitude();
  amplitude_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShake.amplitude)
}

// optional float frequency = 3;
inline bool CUserMessageShake::has_frequency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageShake::set_has_frequency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageShake::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageShake::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline float CUserMessageShake::frequency() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShake.frequency)
  return frequency_;
}
inline void CUserMessageShake::set_frequency(float value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShake.frequency)
}

// optional float duration = 4;
inline bool CUserMessageShake::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageShake::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageShake::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageShake::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CUserMessageShake::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShake.duration)
  return duration_;
}
inline void CUserMessageShake::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShake.duration)
}

// -------------------------------------------------------------------

// CUserMessageShakeDir

// optional .proto.dota.CUserMessageShake shake = 1;
inline bool CUserMessageShakeDir::has_shake() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageShakeDir::set_has_shake() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageShakeDir::clear_has_shake() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageShakeDir::clear_shake() {
  if (shake_ != NULL) shake_->::proto::dota::CUserMessageShake::Clear();
  clear_has_shake();
}
inline const ::proto::dota::CUserMessageShake& CUserMessageShakeDir::shake() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShakeDir.shake)
  return shake_ != NULL ? *shake_
                         : *::proto::dota::CUserMessageShake::internal_default_instance();
}
inline ::proto::dota::CUserMessageShake* CUserMessageShakeDir::mutable_shake() {
  set_has_shake();
  if (shake_ == NULL) {
    shake_ = new ::proto::dota::CUserMessageShake;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageShakeDir.shake)
  return shake_;
}
inline ::proto::dota::CUserMessageShake* CUserMessageShakeDir::release_shake() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageShakeDir.shake)
  clear_has_shake();
  ::proto::dota::CUserMessageShake* temp = shake_;
  shake_ = NULL;
  return temp;
}
inline void CUserMessageShakeDir::set_allocated_shake(::proto::dota::CUserMessageShake* shake) {
  delete shake_;
  shake_ = shake;
  if (shake) {
    set_has_shake();
  } else {
    clear_has_shake();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageShakeDir.shake)
}

// optional .proto.dota.CMsgVector direction = 2;
inline bool CUserMessageShakeDir::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageShakeDir::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageShakeDir::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageShakeDir::clear_direction() {
  if (direction_ != NULL) direction_->::proto::dota::CMsgVector::Clear();
  clear_has_direction();
}
inline const ::proto::dota::CMsgVector& CUserMessageShakeDir::direction() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShakeDir.direction)
  return direction_ != NULL ? *direction_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMessageShakeDir::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageShakeDir.direction)
  return direction_;
}
inline ::proto::dota::CMsgVector* CUserMessageShakeDir::release_direction() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageShakeDir.direction)
  clear_has_direction();
  ::proto::dota::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void CUserMessageShakeDir::set_allocated_direction(::proto::dota::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageShakeDir.direction)
}

// -------------------------------------------------------------------

// CUserMessageScreenTilt

// optional uint32 command = 1;
inline bool CUserMessageScreenTilt::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageScreenTilt::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageScreenTilt::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageScreenTilt::clear_command() {
  command_ = 0u;
  clear_has_command();
}
inline ::google::protobuf::uint32 CUserMessageScreenTilt::command() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageScreenTilt.command)
  return command_;
}
inline void CUserMessageScreenTilt::set_command(::google::protobuf::uint32 value) {
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageScreenTilt.command)
}

// optional bool ease_in_out = 2;
inline bool CUserMessageScreenTilt::has_ease_in_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageScreenTilt::set_has_ease_in_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageScreenTilt::clear_has_ease_in_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageScreenTilt::clear_ease_in_out() {
  ease_in_out_ = false;
  clear_has_ease_in_out();
}
inline bool CUserMessageScreenTilt::ease_in_out() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageScreenTilt.ease_in_out)
  return ease_in_out_;
}
inline void CUserMessageScreenTilt::set_ease_in_out(bool value) {
  set_has_ease_in_out();
  ease_in_out_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageScreenTilt.ease_in_out)
}

// optional .proto.dota.CMsgVector angle = 3;
inline bool CUserMessageScreenTilt::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageScreenTilt::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageScreenTilt::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageScreenTilt::clear_angle() {
  if (angle_ != NULL) angle_->::proto::dota::CMsgVector::Clear();
  clear_has_angle();
}
inline const ::proto::dota::CMsgVector& CUserMessageScreenTilt::angle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageScreenTilt.angle)
  return angle_ != NULL ? *angle_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMessageScreenTilt::mutable_angle() {
  set_has_angle();
  if (angle_ == NULL) {
    angle_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageScreenTilt.angle)
  return angle_;
}
inline ::proto::dota::CMsgVector* CUserMessageScreenTilt::release_angle() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageScreenTilt.angle)
  clear_has_angle();
  ::proto::dota::CMsgVector* temp = angle_;
  angle_ = NULL;
  return temp;
}
inline void CUserMessageScreenTilt::set_allocated_angle(::proto::dota::CMsgVector* angle) {
  delete angle_;
  angle_ = angle;
  if (angle) {
    set_has_angle();
  } else {
    clear_has_angle();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageScreenTilt.angle)
}

// optional float duration = 4;
inline bool CUserMessageScreenTilt::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageScreenTilt::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageScreenTilt::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageScreenTilt::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CUserMessageScreenTilt::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageScreenTilt.duration)
  return duration_;
}
inline void CUserMessageScreenTilt::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageScreenTilt.duration)
}

// optional float time = 5;
inline bool CUserMessageScreenTilt::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserMessageScreenTilt::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserMessageScreenTilt::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserMessageScreenTilt::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float CUserMessageScreenTilt::time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageScreenTilt.time)
  return time_;
}
inline void CUserMessageScreenTilt::set_time(float value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageScreenTilt.time)
}

// -------------------------------------------------------------------

// CUserMessageSayText

// optional uint32 playerindex = 1;
inline bool CUserMessageSayText::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageSayText::set_has_playerindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageSayText::clear_has_playerindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageSayText::clear_playerindex() {
  playerindex_ = 0u;
  clear_has_playerindex();
}
inline ::google::protobuf::uint32 CUserMessageSayText::playerindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText.playerindex)
  return playerindex_;
}
inline void CUserMessageSayText::set_playerindex(::google::protobuf::uint32 value) {
  set_has_playerindex();
  playerindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText.playerindex)
}

// optional string text = 2;
inline bool CUserMessageSayText::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageSayText::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageSayText::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageSayText::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& CUserMessageSayText::text() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText.text)
  return text_.GetNoArena();
}
inline void CUserMessageSayText::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText.text)
}
#if LANG_CXX11
inline void CUserMessageSayText::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayText.text)
}
#endif
inline void CUserMessageSayText::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayText.text)
}
inline void CUserMessageSayText::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayText.text)
}
inline ::std::string* CUserMessageSayText::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayText.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayText::release_text() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayText.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayText::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayText.text)
}

// optional bool chat = 3;
inline bool CUserMessageSayText::has_chat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageSayText::set_has_chat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageSayText::clear_has_chat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageSayText::clear_chat() {
  chat_ = false;
  clear_has_chat();
}
inline bool CUserMessageSayText::chat() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText.chat)
  return chat_;
}
inline void CUserMessageSayText::set_chat(bool value) {
  set_has_chat();
  chat_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText.chat)
}

// -------------------------------------------------------------------

// CUserMessageSayText2

// optional uint32 entityindex = 1;
inline bool CUserMessageSayText2::has_entityindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CUserMessageSayText2::set_has_entityindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CUserMessageSayText2::clear_has_entityindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CUserMessageSayText2::clear_entityindex() {
  entityindex_ = 0u;
  clear_has_entityindex();
}
inline ::google::protobuf::uint32 CUserMessageSayText2::entityindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.entityindex)
  return entityindex_;
}
inline void CUserMessageSayText2::set_entityindex(::google::protobuf::uint32 value) {
  set_has_entityindex();
  entityindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.entityindex)
}

// optional bool chat = 2;
inline bool CUserMessageSayText2::has_chat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CUserMessageSayText2::set_has_chat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CUserMessageSayText2::clear_has_chat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CUserMessageSayText2::clear_chat() {
  chat_ = false;
  clear_has_chat();
}
inline bool CUserMessageSayText2::chat() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.chat)
  return chat_;
}
inline void CUserMessageSayText2::set_chat(bool value) {
  set_has_chat();
  chat_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.chat)
}

// optional string messagename = 3;
inline bool CUserMessageSayText2::has_messagename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageSayText2::set_has_messagename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageSayText2::clear_has_messagename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageSayText2::clear_messagename() {
  messagename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagename();
}
inline const ::std::string& CUserMessageSayText2::messagename() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.messagename)
  return messagename_.GetNoArena();
}
inline void CUserMessageSayText2::set_messagename(const ::std::string& value) {
  set_has_messagename();
  messagename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.messagename)
}
#if LANG_CXX11
inline void CUserMessageSayText2::set_messagename(::std::string&& value) {
  set_has_messagename();
  messagename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayText2.messagename)
}
#endif
inline void CUserMessageSayText2::set_messagename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagename();
  messagename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayText2.messagename)
}
inline void CUserMessageSayText2::set_messagename(const char* value, size_t size) {
  set_has_messagename();
  messagename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayText2.messagename)
}
inline ::std::string* CUserMessageSayText2::mutable_messagename() {
  set_has_messagename();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayText2.messagename)
  return messagename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayText2::release_messagename() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayText2.messagename)
  clear_has_messagename();
  return messagename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayText2::set_allocated_messagename(::std::string* messagename) {
  if (messagename != NULL) {
    set_has_messagename();
  } else {
    clear_has_messagename();
  }
  messagename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagename);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayText2.messagename)
}

// optional string param1 = 4;
inline bool CUserMessageSayText2::has_param1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageSayText2::set_has_param1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageSayText2::clear_has_param1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageSayText2::clear_param1() {
  param1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_param1();
}
inline const ::std::string& CUserMessageSayText2::param1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.param1)
  return param1_.GetNoArena();
}
inline void CUserMessageSayText2::set_param1(const ::std::string& value) {
  set_has_param1();
  param1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.param1)
}
#if LANG_CXX11
inline void CUserMessageSayText2::set_param1(::std::string&& value) {
  set_has_param1();
  param1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayText2.param1)
}
#endif
inline void CUserMessageSayText2::set_param1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_param1();
  param1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayText2.param1)
}
inline void CUserMessageSayText2::set_param1(const char* value, size_t size) {
  set_has_param1();
  param1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayText2.param1)
}
inline ::std::string* CUserMessageSayText2::mutable_param1() {
  set_has_param1();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayText2.param1)
  return param1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayText2::release_param1() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayText2.param1)
  clear_has_param1();
  return param1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayText2::set_allocated_param1(::std::string* param1) {
  if (param1 != NULL) {
    set_has_param1();
  } else {
    clear_has_param1();
  }
  param1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), param1);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayText2.param1)
}

// optional string param2 = 5;
inline bool CUserMessageSayText2::has_param2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageSayText2::set_has_param2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageSayText2::clear_has_param2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageSayText2::clear_param2() {
  param2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_param2();
}
inline const ::std::string& CUserMessageSayText2::param2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.param2)
  return param2_.GetNoArena();
}
inline void CUserMessageSayText2::set_param2(const ::std::string& value) {
  set_has_param2();
  param2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.param2)
}
#if LANG_CXX11
inline void CUserMessageSayText2::set_param2(::std::string&& value) {
  set_has_param2();
  param2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayText2.param2)
}
#endif
inline void CUserMessageSayText2::set_param2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_param2();
  param2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayText2.param2)
}
inline void CUserMessageSayText2::set_param2(const char* value, size_t size) {
  set_has_param2();
  param2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayText2.param2)
}
inline ::std::string* CUserMessageSayText2::mutable_param2() {
  set_has_param2();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayText2.param2)
  return param2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayText2::release_param2() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayText2.param2)
  clear_has_param2();
  return param2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayText2::set_allocated_param2(::std::string* param2) {
  if (param2 != NULL) {
    set_has_param2();
  } else {
    clear_has_param2();
  }
  param2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), param2);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayText2.param2)
}

// optional string param3 = 6;
inline bool CUserMessageSayText2::has_param3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageSayText2::set_has_param3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageSayText2::clear_has_param3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageSayText2::clear_param3() {
  param3_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_param3();
}
inline const ::std::string& CUserMessageSayText2::param3() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.param3)
  return param3_.GetNoArena();
}
inline void CUserMessageSayText2::set_param3(const ::std::string& value) {
  set_has_param3();
  param3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.param3)
}
#if LANG_CXX11
inline void CUserMessageSayText2::set_param3(::std::string&& value) {
  set_has_param3();
  param3_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayText2.param3)
}
#endif
inline void CUserMessageSayText2::set_param3(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_param3();
  param3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayText2.param3)
}
inline void CUserMessageSayText2::set_param3(const char* value, size_t size) {
  set_has_param3();
  param3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayText2.param3)
}
inline ::std::string* CUserMessageSayText2::mutable_param3() {
  set_has_param3();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayText2.param3)
  return param3_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayText2::release_param3() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayText2.param3)
  clear_has_param3();
  return param3_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayText2::set_allocated_param3(::std::string* param3) {
  if (param3 != NULL) {
    set_has_param3();
  } else {
    clear_has_param3();
  }
  param3_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), param3);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayText2.param3)
}

// optional string param4 = 7;
inline bool CUserMessageSayText2::has_param4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserMessageSayText2::set_has_param4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserMessageSayText2::clear_has_param4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserMessageSayText2::clear_param4() {
  param4_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_param4();
}
inline const ::std::string& CUserMessageSayText2::param4() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayText2.param4)
  return param4_.GetNoArena();
}
inline void CUserMessageSayText2::set_param4(const ::std::string& value) {
  set_has_param4();
  param4_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayText2.param4)
}
#if LANG_CXX11
inline void CUserMessageSayText2::set_param4(::std::string&& value) {
  set_has_param4();
  param4_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayText2.param4)
}
#endif
inline void CUserMessageSayText2::set_param4(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_param4();
  param4_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayText2.param4)
}
inline void CUserMessageSayText2::set_param4(const char* value, size_t size) {
  set_has_param4();
  param4_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayText2.param4)
}
inline ::std::string* CUserMessageSayText2::mutable_param4() {
  set_has_param4();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayText2.param4)
  return param4_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayText2::release_param4() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayText2.param4)
  clear_has_param4();
  return param4_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayText2::set_allocated_param4(::std::string* param4) {
  if (param4 != NULL) {
    set_has_param4();
  } else {
    clear_has_param4();
  }
  param4_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), param4);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayText2.param4)
}

// -------------------------------------------------------------------

// CUserMessageHudMsg

// optional uint32 channel = 1;
inline bool CUserMessageHudMsg::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageHudMsg::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageHudMsg::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageHudMsg::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CUserMessageHudMsg::channel() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.channel)
  return channel_;
}
inline void CUserMessageHudMsg::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.channel)
}

// optional float x = 2;
inline bool CUserMessageHudMsg::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageHudMsg::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageHudMsg::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageHudMsg::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float CUserMessageHudMsg::x() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.x)
  return x_;
}
inline void CUserMessageHudMsg::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.x)
}

// optional float y = 3;
inline bool CUserMessageHudMsg::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageHudMsg::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageHudMsg::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageHudMsg::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float CUserMessageHudMsg::y() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.y)
  return y_;
}
inline void CUserMessageHudMsg::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.y)
}

// optional fixed32 color1 = 4;
inline bool CUserMessageHudMsg::has_color1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserMessageHudMsg::set_has_color1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserMessageHudMsg::clear_has_color1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserMessageHudMsg::clear_color1() {
  color1_ = 0u;
  clear_has_color1();
}
inline ::google::protobuf::uint32 CUserMessageHudMsg::color1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.color1)
  return color1_;
}
inline void CUserMessageHudMsg::set_color1(::google::protobuf::uint32 value) {
  set_has_color1();
  color1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.color1)
}

// optional fixed32 color2 = 5;
inline bool CUserMessageHudMsg::has_color2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CUserMessageHudMsg::set_has_color2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CUserMessageHudMsg::clear_has_color2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CUserMessageHudMsg::clear_color2() {
  color2_ = 0u;
  clear_has_color2();
}
inline ::google::protobuf::uint32 CUserMessageHudMsg::color2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.color2)
  return color2_;
}
inline void CUserMessageHudMsg::set_color2(::google::protobuf::uint32 value) {
  set_has_color2();
  color2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.color2)
}

// optional uint32 effect = 6;
inline bool CUserMessageHudMsg::has_effect() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CUserMessageHudMsg::set_has_effect() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CUserMessageHudMsg::clear_has_effect() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CUserMessageHudMsg::clear_effect() {
  effect_ = 0u;
  clear_has_effect();
}
inline ::google::protobuf::uint32 CUserMessageHudMsg::effect() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.effect)
  return effect_;
}
inline void CUserMessageHudMsg::set_effect(::google::protobuf::uint32 value) {
  set_has_effect();
  effect_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.effect)
}

// optional float fade_in_time = 7;
inline bool CUserMessageHudMsg::has_fade_in_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CUserMessageHudMsg::set_has_fade_in_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CUserMessageHudMsg::clear_has_fade_in_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CUserMessageHudMsg::clear_fade_in_time() {
  fade_in_time_ = 0;
  clear_has_fade_in_time();
}
inline float CUserMessageHudMsg::fade_in_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.fade_in_time)
  return fade_in_time_;
}
inline void CUserMessageHudMsg::set_fade_in_time(float value) {
  set_has_fade_in_time();
  fade_in_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.fade_in_time)
}

// optional float fade_out_time = 8;
inline bool CUserMessageHudMsg::has_fade_out_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CUserMessageHudMsg::set_has_fade_out_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CUserMessageHudMsg::clear_has_fade_out_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CUserMessageHudMsg::clear_fade_out_time() {
  fade_out_time_ = 0;
  clear_has_fade_out_time();
}
inline float CUserMessageHudMsg::fade_out_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.fade_out_time)
  return fade_out_time_;
}
inline void CUserMessageHudMsg::set_fade_out_time(float value) {
  set_has_fade_out_time();
  fade_out_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.fade_out_time)
}

// optional float hold_time = 9;
inline bool CUserMessageHudMsg::has_hold_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CUserMessageHudMsg::set_has_hold_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CUserMessageHudMsg::clear_has_hold_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CUserMessageHudMsg::clear_hold_time() {
  hold_time_ = 0;
  clear_has_hold_time();
}
inline float CUserMessageHudMsg::hold_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.hold_time)
  return hold_time_;
}
inline void CUserMessageHudMsg::set_hold_time(float value) {
  set_has_hold_time();
  hold_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.hold_time)
}

// optional float fx_time = 10;
inline bool CUserMessageHudMsg::has_fx_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CUserMessageHudMsg::set_has_fx_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CUserMessageHudMsg::clear_has_fx_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CUserMessageHudMsg::clear_fx_time() {
  fx_time_ = 0;
  clear_has_fx_time();
}
inline float CUserMessageHudMsg::fx_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.fx_time)
  return fx_time_;
}
inline void CUserMessageHudMsg::set_fx_time(float value) {
  set_has_fx_time();
  fx_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.fx_time)
}

// optional string message = 11;
inline bool CUserMessageHudMsg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageHudMsg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageHudMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageHudMsg::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& CUserMessageHudMsg::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudMsg.message)
  return message_.GetNoArena();
}
inline void CUserMessageHudMsg::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudMsg.message)
}
#if LANG_CXX11
inline void CUserMessageHudMsg::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageHudMsg.message)
}
#endif
inline void CUserMessageHudMsg::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageHudMsg.message)
}
inline void CUserMessageHudMsg::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageHudMsg.message)
}
inline ::std::string* CUserMessageHudMsg::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageHudMsg.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageHudMsg::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageHudMsg.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageHudMsg::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageHudMsg.message)
}

// -------------------------------------------------------------------

// CUserMessageHudText

// optional string message = 1;
inline bool CUserMessageHudText::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageHudText::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageHudText::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageHudText::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& CUserMessageHudText::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHudText.message)
  return message_.GetNoArena();
}
inline void CUserMessageHudText::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHudText.message)
}
#if LANG_CXX11
inline void CUserMessageHudText::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageHudText.message)
}
#endif
inline void CUserMessageHudText::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageHudText.message)
}
inline void CUserMessageHudText::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageHudText.message)
}
inline ::std::string* CUserMessageHudText::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageHudText.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageHudText::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageHudText.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageHudText::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageHudText.message)
}

// -------------------------------------------------------------------

// CUserMessageTextMsg

// optional uint32 dest = 1;
inline bool CUserMessageTextMsg::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageTextMsg::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageTextMsg::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageTextMsg::clear_dest() {
  dest_ = 0u;
  clear_has_dest();
}
inline ::google::protobuf::uint32 CUserMessageTextMsg::dest() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageTextMsg.dest)
  return dest_;
}
inline void CUserMessageTextMsg::set_dest(::google::protobuf::uint32 value) {
  set_has_dest();
  dest_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageTextMsg.dest)
}

// repeated string param = 2;
inline int CUserMessageTextMsg::param_size() const {
  return param_.size();
}
inline void CUserMessageTextMsg::clear_param() {
  param_.Clear();
}
inline const ::std::string& CUserMessageTextMsg::param(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageTextMsg.param)
  return param_.Get(index);
}
inline ::std::string* CUserMessageTextMsg::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageTextMsg.param)
  return param_.Mutable(index);
}
inline void CUserMessageTextMsg::set_param(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageTextMsg.param)
  param_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CUserMessageTextMsg::set_param(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageTextMsg.param)
  param_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CUserMessageTextMsg::set_param(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  param_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageTextMsg.param)
}
inline void CUserMessageTextMsg::set_param(int index, const char* value, size_t size) {
  param_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageTextMsg.param)
}
inline ::std::string* CUserMessageTextMsg::add_param() {
  // @@protoc_insertion_point(field_add_mutable:proto.dota.CUserMessageTextMsg.param)
  return param_.Add();
}
inline void CUserMessageTextMsg::add_param(const ::std::string& value) {
  param_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageTextMsg.param)
}
#if LANG_CXX11
inline void CUserMessageTextMsg::add_param(::std::string&& value) {
  param_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageTextMsg.param)
}
#endif
inline void CUserMessageTextMsg::add_param(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  param_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.dota.CUserMessageTextMsg.param)
}
inline void CUserMessageTextMsg::add_param(const char* value, size_t size) {
  param_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.dota.CUserMessageTextMsg.param)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CUserMessageTextMsg::param() const {
  // @@protoc_insertion_point(field_list:proto.dota.CUserMessageTextMsg.param)
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CUserMessageTextMsg::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CUserMessageTextMsg.param)
  return &param_;
}

// -------------------------------------------------------------------

// CUserMessageGameTitle

// -------------------------------------------------------------------

// CUserMessageResetHUD

// -------------------------------------------------------------------

// CUserMessageSendAudio

// optional string soundname = 1;
inline bool CUserMessageSendAudio::has_soundname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageSendAudio::set_has_soundname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageSendAudio::clear_has_soundname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageSendAudio::clear_soundname() {
  soundname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_soundname();
}
inline const ::std::string& CUserMessageSendAudio::soundname() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSendAudio.soundname)
  return soundname_.GetNoArena();
}
inline void CUserMessageSendAudio::set_soundname(const ::std::string& value) {
  set_has_soundname();
  soundname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSendAudio.soundname)
}
#if LANG_CXX11
inline void CUserMessageSendAudio::set_soundname(::std::string&& value) {
  set_has_soundname();
  soundname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSendAudio.soundname)
}
#endif
inline void CUserMessageSendAudio::set_soundname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_soundname();
  soundname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSendAudio.soundname)
}
inline void CUserMessageSendAudio::set_soundname(const char* value, size_t size) {
  set_has_soundname();
  soundname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSendAudio.soundname)
}
inline ::std::string* CUserMessageSendAudio::mutable_soundname() {
  set_has_soundname();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSendAudio.soundname)
  return soundname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSendAudio::release_soundname() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSendAudio.soundname)
  clear_has_soundname();
  return soundname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSendAudio::set_allocated_soundname(::std::string* soundname) {
  if (soundname != NULL) {
    set_has_soundname();
  } else {
    clear_has_soundname();
  }
  soundname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), soundname);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSendAudio.soundname)
}

// optional bool stop = 2;
inline bool CUserMessageSendAudio::has_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageSendAudio::set_has_stop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageSendAudio::clear_has_stop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageSendAudio::clear_stop() {
  stop_ = false;
  clear_has_stop();
}
inline bool CUserMessageSendAudio::stop() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSendAudio.stop)
  return stop_;
}
inline void CUserMessageSendAudio::set_stop(bool value) {
  set_has_stop();
  stop_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSendAudio.stop)
}

// -------------------------------------------------------------------

// CUserMessageAudioParameter

// optional uint32 parameter_type = 1;
inline bool CUserMessageAudioParameter::has_parameter_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageAudioParameter::set_has_parameter_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageAudioParameter::clear_has_parameter_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageAudioParameter::clear_parameter_type() {
  parameter_type_ = 0u;
  clear_has_parameter_type();
}
inline ::google::protobuf::uint32 CUserMessageAudioParameter::parameter_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAudioParameter.parameter_type)
  return parameter_type_;
}
inline void CUserMessageAudioParameter::set_parameter_type(::google::protobuf::uint32 value) {
  set_has_parameter_type();
  parameter_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAudioParameter.parameter_type)
}

// optional uint32 name_hash_code = 2;
inline bool CUserMessageAudioParameter::has_name_hash_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageAudioParameter::set_has_name_hash_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageAudioParameter::clear_has_name_hash_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageAudioParameter::clear_name_hash_code() {
  name_hash_code_ = 0u;
  clear_has_name_hash_code();
}
inline ::google::protobuf::uint32 CUserMessageAudioParameter::name_hash_code() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAudioParameter.name_hash_code)
  return name_hash_code_;
}
inline void CUserMessageAudioParameter::set_name_hash_code(::google::protobuf::uint32 value) {
  set_has_name_hash_code();
  name_hash_code_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAudioParameter.name_hash_code)
}

// optional float value = 3;
inline bool CUserMessageAudioParameter::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageAudioParameter::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageAudioParameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageAudioParameter::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float CUserMessageAudioParameter::value() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAudioParameter.value)
  return value_;
}
inline void CUserMessageAudioParameter::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAudioParameter.value)
}

// optional uint32 int_value = 4;
inline bool CUserMessageAudioParameter::has_int_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageAudioParameter::set_has_int_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageAudioParameter::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageAudioParameter::clear_int_value() {
  int_value_ = 0u;
  clear_has_int_value();
}
inline ::google::protobuf::uint32 CUserMessageAudioParameter::int_value() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAudioParameter.int_value)
  return int_value_;
}
inline void CUserMessageAudioParameter::set_int_value(::google::protobuf::uint32 value) {
  set_has_int_value();
  int_value_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAudioParameter.int_value)
}

// -------------------------------------------------------------------

// CUserMessageVoiceMask

// repeated uint32 gamerules_masks = 1;
inline int CUserMessageVoiceMask::gamerules_masks_size() const {
  return gamerules_masks_.size();
}
inline void CUserMessageVoiceMask::clear_gamerules_masks() {
  gamerules_masks_.Clear();
}
inline ::google::protobuf::uint32 CUserMessageVoiceMask::gamerules_masks(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVoiceMask.gamerules_masks)
  return gamerules_masks_.Get(index);
}
inline void CUserMessageVoiceMask::set_gamerules_masks(int index, ::google::protobuf::uint32 value) {
  gamerules_masks_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVoiceMask.gamerules_masks)
}
inline void CUserMessageVoiceMask::add_gamerules_masks(::google::protobuf::uint32 value) {
  gamerules_masks_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageVoiceMask.gamerules_masks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CUserMessageVoiceMask::gamerules_masks() const {
  // @@protoc_insertion_point(field_list:proto.dota.CUserMessageVoiceMask.gamerules_masks)
  return gamerules_masks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CUserMessageVoiceMask::mutable_gamerules_masks() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CUserMessageVoiceMask.gamerules_masks)
  return &gamerules_masks_;
}

// repeated uint32 ban_masks = 2;
inline int CUserMessageVoiceMask::ban_masks_size() const {
  return ban_masks_.size();
}
inline void CUserMessageVoiceMask::clear_ban_masks() {
  ban_masks_.Clear();
}
inline ::google::protobuf::uint32 CUserMessageVoiceMask::ban_masks(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVoiceMask.ban_masks)
  return ban_masks_.Get(index);
}
inline void CUserMessageVoiceMask::set_ban_masks(int index, ::google::protobuf::uint32 value) {
  ban_masks_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVoiceMask.ban_masks)
}
inline void CUserMessageVoiceMask::add_ban_masks(::google::protobuf::uint32 value) {
  ban_masks_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageVoiceMask.ban_masks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CUserMessageVoiceMask::ban_masks() const {
  // @@protoc_insertion_point(field_list:proto.dota.CUserMessageVoiceMask.ban_masks)
  return ban_masks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CUserMessageVoiceMask::mutable_ban_masks() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CUserMessageVoiceMask.ban_masks)
  return &ban_masks_;
}

// optional bool mod_enable = 3;
inline bool CUserMessageVoiceMask::has_mod_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageVoiceMask::set_has_mod_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageVoiceMask::clear_has_mod_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageVoiceMask::clear_mod_enable() {
  mod_enable_ = false;
  clear_has_mod_enable();
}
inline bool CUserMessageVoiceMask::mod_enable() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVoiceMask.mod_enable)
  return mod_enable_;
}
inline void CUserMessageVoiceMask::set_mod_enable(bool value) {
  set_has_mod_enable();
  mod_enable_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVoiceMask.mod_enable)
}

// -------------------------------------------------------------------

// CUserMessageRequestState

// -------------------------------------------------------------------

// CUserMessageHintText

// optional string message = 1;
inline bool CUserMessageHintText::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageHintText::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageHintText::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageHintText::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& CUserMessageHintText::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHintText.message)
  return message_.GetNoArena();
}
inline void CUserMessageHintText::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHintText.message)
}
#if LANG_CXX11
inline void CUserMessageHintText::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageHintText.message)
}
#endif
inline void CUserMessageHintText::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageHintText.message)
}
inline void CUserMessageHintText::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageHintText.message)
}
inline ::std::string* CUserMessageHintText::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageHintText.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageHintText::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageHintText.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageHintText::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageHintText.message)
}

// -------------------------------------------------------------------

// CUserMessageKeyHintText

// repeated string messages = 1;
inline int CUserMessageKeyHintText::messages_size() const {
  return messages_.size();
}
inline void CUserMessageKeyHintText::clear_messages() {
  messages_.Clear();
}
inline const ::std::string& CUserMessageKeyHintText::messages(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageKeyHintText.messages)
  return messages_.Get(index);
}
inline ::std::string* CUserMessageKeyHintText::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageKeyHintText.messages)
  return messages_.Mutable(index);
}
inline void CUserMessageKeyHintText::set_messages(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageKeyHintText.messages)
  messages_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CUserMessageKeyHintText::set_messages(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageKeyHintText.messages)
  messages_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CUserMessageKeyHintText::set_messages(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageKeyHintText.messages)
}
inline void CUserMessageKeyHintText::set_messages(int index, const char* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageKeyHintText.messages)
}
inline ::std::string* CUserMessageKeyHintText::add_messages() {
  // @@protoc_insertion_point(field_add_mutable:proto.dota.CUserMessageKeyHintText.messages)
  return messages_.Add();
}
inline void CUserMessageKeyHintText::add_messages(const ::std::string& value) {
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageKeyHintText.messages)
}
#if LANG_CXX11
inline void CUserMessageKeyHintText::add_messages(::std::string&& value) {
  messages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageKeyHintText.messages)
}
#endif
inline void CUserMessageKeyHintText::add_messages(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.dota.CUserMessageKeyHintText.messages)
}
inline void CUserMessageKeyHintText::add_messages(const char* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.dota.CUserMessageKeyHintText.messages)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CUserMessageKeyHintText::messages() const {
  // @@protoc_insertion_point(field_list:proto.dota.CUserMessageKeyHintText.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CUserMessageKeyHintText::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CUserMessageKeyHintText.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// CUserMessageVoiceSubtitle

// optional int32 player = 1;
inline bool CUserMessageVoiceSubtitle::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageVoiceSubtitle::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageVoiceSubtitle::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageVoiceSubtitle::clear_player() {
  player_ = 0;
  clear_has_player();
}
inline ::google::protobuf::int32 CUserMessageVoiceSubtitle::player() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVoiceSubtitle.player)
  return player_;
}
inline void CUserMessageVoiceSubtitle::set_player(::google::protobuf::int32 value) {
  set_has_player();
  player_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVoiceSubtitle.player)
}

// optional int32 menu = 2;
inline bool CUserMessageVoiceSubtitle::has_menu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageVoiceSubtitle::set_has_menu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageVoiceSubtitle::clear_has_menu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageVoiceSubtitle::clear_menu() {
  menu_ = 0;
  clear_has_menu();
}
inline ::google::protobuf::int32 CUserMessageVoiceSubtitle::menu() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVoiceSubtitle.menu)
  return menu_;
}
inline void CUserMessageVoiceSubtitle::set_menu(::google::protobuf::int32 value) {
  set_has_menu();
  menu_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVoiceSubtitle.menu)
}

// optional int32 item = 3;
inline bool CUserMessageVoiceSubtitle::has_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageVoiceSubtitle::set_has_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageVoiceSubtitle::clear_has_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageVoiceSubtitle::clear_item() {
  item_ = 0;
  clear_has_item();
}
inline ::google::protobuf::int32 CUserMessageVoiceSubtitle::item() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVoiceSubtitle.item)
  return item_;
}
inline void CUserMessageVoiceSubtitle::set_item(::google::protobuf::int32 value) {
  set_has_item();
  item_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVoiceSubtitle.item)
}

// -------------------------------------------------------------------

// CUserMessageVGUIMenu_Keys

// optional string name = 1;
inline bool CUserMessageVGUIMenu_Keys::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageVGUIMenu_Keys::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageVGUIMenu_Keys::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageVGUIMenu_Keys::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CUserMessageVGUIMenu_Keys::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVGUIMenu.Keys.name)
  return name_.GetNoArena();
}
inline void CUserMessageVGUIMenu_Keys::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVGUIMenu.Keys.name)
}
#if LANG_CXX11
inline void CUserMessageVGUIMenu_Keys::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageVGUIMenu.Keys.name)
}
#endif
inline void CUserMessageVGUIMenu_Keys::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageVGUIMenu.Keys.name)
}
inline void CUserMessageVGUIMenu_Keys::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageVGUIMenu.Keys.name)
}
inline ::std::string* CUserMessageVGUIMenu_Keys::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageVGUIMenu.Keys.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageVGUIMenu_Keys::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageVGUIMenu.Keys.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageVGUIMenu_Keys::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageVGUIMenu.Keys.name)
}

// optional string value = 2;
inline bool CUserMessageVGUIMenu_Keys::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageVGUIMenu_Keys::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageVGUIMenu_Keys::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageVGUIMenu_Keys::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& CUserMessageVGUIMenu_Keys::value() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVGUIMenu.Keys.value)
  return value_.GetNoArena();
}
inline void CUserMessageVGUIMenu_Keys::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVGUIMenu.Keys.value)
}
#if LANG_CXX11
inline void CUserMessageVGUIMenu_Keys::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageVGUIMenu.Keys.value)
}
#endif
inline void CUserMessageVGUIMenu_Keys::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageVGUIMenu.Keys.value)
}
inline void CUserMessageVGUIMenu_Keys::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageVGUIMenu.Keys.value)
}
inline ::std::string* CUserMessageVGUIMenu_Keys::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageVGUIMenu.Keys.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageVGUIMenu_Keys::release_value() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageVGUIMenu.Keys.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageVGUIMenu_Keys::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageVGUIMenu.Keys.value)
}

// -------------------------------------------------------------------

// CUserMessageVGUIMenu

// optional string name = 1;
inline bool CUserMessageVGUIMenu::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageVGUIMenu::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageVGUIMenu::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageVGUIMenu::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CUserMessageVGUIMenu::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVGUIMenu.name)
  return name_.GetNoArena();
}
inline void CUserMessageVGUIMenu::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVGUIMenu.name)
}
#if LANG_CXX11
inline void CUserMessageVGUIMenu::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageVGUIMenu.name)
}
#endif
inline void CUserMessageVGUIMenu::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageVGUIMenu.name)
}
inline void CUserMessageVGUIMenu::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageVGUIMenu.name)
}
inline ::std::string* CUserMessageVGUIMenu::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageVGUIMenu.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageVGUIMenu::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageVGUIMenu.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageVGUIMenu::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageVGUIMenu.name)
}

// optional bool show = 2;
inline bool CUserMessageVGUIMenu::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageVGUIMenu::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageVGUIMenu::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageVGUIMenu::clear_show() {
  show_ = false;
  clear_has_show();
}
inline bool CUserMessageVGUIMenu::show() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVGUIMenu.show)
  return show_;
}
inline void CUserMessageVGUIMenu::set_show(bool value) {
  set_has_show();
  show_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageVGUIMenu.show)
}

// repeated .proto.dota.CUserMessageVGUIMenu.Keys keys = 3;
inline int CUserMessageVGUIMenu::keys_size() const {
  return keys_.size();
}
inline void CUserMessageVGUIMenu::clear_keys() {
  keys_.Clear();
}
inline const ::proto::dota::CUserMessageVGUIMenu_Keys& CUserMessageVGUIMenu::keys(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageVGUIMenu.keys)
  return keys_.Get(index);
}
inline ::proto::dota::CUserMessageVGUIMenu_Keys* CUserMessageVGUIMenu::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageVGUIMenu.keys)
  return keys_.Mutable(index);
}
inline ::proto::dota::CUserMessageVGUIMenu_Keys* CUserMessageVGUIMenu::add_keys() {
  // @@protoc_insertion_point(field_add:proto.dota.CUserMessageVGUIMenu.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CUserMessageVGUIMenu_Keys >*
CUserMessageVGUIMenu::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CUserMessageVGUIMenu.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CUserMessageVGUIMenu_Keys >&
CUserMessageVGUIMenu::keys() const {
  // @@protoc_insertion_point(field_list:proto.dota.CUserMessageVGUIMenu.keys)
  return keys_;
}

// -------------------------------------------------------------------

// CUserMessageRumble

// optional int32 index = 1;
inline bool CUserMessageRumble::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageRumble::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageRumble::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageRumble::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CUserMessageRumble::index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageRumble.index)
  return index_;
}
inline void CUserMessageRumble::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageRumble.index)
}

// optional int32 data = 2;
inline bool CUserMessageRumble::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageRumble::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageRumble::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageRumble::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 CUserMessageRumble::data() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageRumble.data)
  return data_;
}
inline void CUserMessageRumble::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageRumble.data)
}

// optional int32 flags = 3;
inline bool CUserMessageRumble::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageRumble::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageRumble::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageRumble::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 CUserMessageRumble::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageRumble.flags)
  return flags_;
}
inline void CUserMessageRumble::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageRumble.flags)
}

// -------------------------------------------------------------------

// CUserMessageTrain

// optional uint32 position = 1;
inline bool CUserMessageTrain::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageTrain::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageTrain::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageTrain::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 CUserMessageTrain::position() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageTrain.position)
  return position_;
}
inline void CUserMessageTrain::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageTrain.position)
}

// -------------------------------------------------------------------

// CUserMessageSayTextChannel

// optional int32 player = 1;
inline bool CUserMessageSayTextChannel::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageSayTextChannel::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageSayTextChannel::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageSayTextChannel::clear_player() {
  player_ = 0;
  clear_has_player();
}
inline ::google::protobuf::int32 CUserMessageSayTextChannel::player() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayTextChannel.player)
  return player_;
}
inline void CUserMessageSayTextChannel::set_player(::google::protobuf::int32 value) {
  set_has_player();
  player_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayTextChannel.player)
}

// optional int32 channel = 2;
inline bool CUserMessageSayTextChannel::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageSayTextChannel::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageSayTextChannel::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageSayTextChannel::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 CUserMessageSayTextChannel::channel() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayTextChannel.channel)
  return channel_;
}
inline void CUserMessageSayTextChannel::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayTextChannel.channel)
}

// optional string text = 3;
inline bool CUserMessageSayTextChannel::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageSayTextChannel::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageSayTextChannel::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageSayTextChannel::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& CUserMessageSayTextChannel::text() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageSayTextChannel.text)
  return text_.GetNoArena();
}
inline void CUserMessageSayTextChannel::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageSayTextChannel.text)
}
#if LANG_CXX11
inline void CUserMessageSayTextChannel::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageSayTextChannel.text)
}
#endif
inline void CUserMessageSayTextChannel::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageSayTextChannel.text)
}
inline void CUserMessageSayTextChannel::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageSayTextChannel.text)
}
inline ::std::string* CUserMessageSayTextChannel::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageSayTextChannel.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageSayTextChannel::release_text() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageSayTextChannel.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageSayTextChannel::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageSayTextChannel.text)
}

// -------------------------------------------------------------------

// CUserMessageColoredText

// optional uint32 color = 1;
inline bool CUserMessageColoredText::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageColoredText::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageColoredText::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageColoredText::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CUserMessageColoredText::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageColoredText.color)
  return color_;
}
inline void CUserMessageColoredText::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageColoredText.color)
}

// optional string text = 2;
inline bool CUserMessageColoredText::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageColoredText::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageColoredText::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageColoredText::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& CUserMessageColoredText::text() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageColoredText.text)
  return text_.GetNoArena();
}
inline void CUserMessageColoredText::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageColoredText.text)
}
#if LANG_CXX11
inline void CUserMessageColoredText::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageColoredText.text)
}
#endif
inline void CUserMessageColoredText::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageColoredText.text)
}
inline void CUserMessageColoredText::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageColoredText.text)
}
inline ::std::string* CUserMessageColoredText::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageColoredText.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageColoredText::release_text() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageColoredText.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageColoredText::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageColoredText.text)
}

// optional bool reset = 3;
inline bool CUserMessageColoredText::has_reset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageColoredText::set_has_reset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageColoredText::clear_has_reset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageColoredText::clear_reset() {
  reset_ = false;
  clear_has_reset();
}
inline bool CUserMessageColoredText::reset() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageColoredText.reset)
  return reset_;
}
inline void CUserMessageColoredText::set_reset(bool value) {
  set_has_reset();
  reset_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageColoredText.reset)
}

// optional int32 context_player_id = 4;
inline bool CUserMessageColoredText::has_context_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageColoredText::set_has_context_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageColoredText::clear_has_context_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageColoredText::clear_context_player_id() {
  context_player_id_ = 0;
  clear_has_context_player_id();
}
inline ::google::protobuf::int32 CUserMessageColoredText::context_player_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageColoredText.context_player_id)
  return context_player_id_;
}
inline void CUserMessageColoredText::set_context_player_id(::google::protobuf::int32 value) {
  set_has_context_player_id();
  context_player_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageColoredText.context_player_id)
}

// optional int32 context_value = 5;
inline bool CUserMessageColoredText::has_context_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserMessageColoredText::set_has_context_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserMessageColoredText::clear_has_context_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserMessageColoredText::clear_context_value() {
  context_value_ = 0;
  clear_has_context_value();
}
inline ::google::protobuf::int32 CUserMessageColoredText::context_value() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageColoredText.context_value)
  return context_value_;
}
inline void CUserMessageColoredText::set_context_value(::google::protobuf::int32 value) {
  set_has_context_value();
  context_value_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageColoredText.context_value)
}

// optional int32 context_team_id = 6;
inline bool CUserMessageColoredText::has_context_team_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CUserMessageColoredText::set_has_context_team_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CUserMessageColoredText::clear_has_context_team_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CUserMessageColoredText::clear_context_team_id() {
  context_team_id_ = 0;
  clear_has_context_team_id();
}
inline ::google::protobuf::int32 CUserMessageColoredText::context_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageColoredText.context_team_id)
  return context_team_id_;
}
inline void CUserMessageColoredText::set_context_team_id(::google::protobuf::int32 value) {
  set_has_context_team_id();
  context_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageColoredText.context_team_id)
}

// -------------------------------------------------------------------

// CUserMessageItemPickup

// optional string itemname = 1;
inline bool CUserMessageItemPickup::has_itemname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageItemPickup::set_has_itemname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageItemPickup::clear_has_itemname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageItemPickup::clear_itemname() {
  itemname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_itemname();
}
inline const ::std::string& CUserMessageItemPickup::itemname() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageItemPickup.itemname)
  return itemname_.GetNoArena();
}
inline void CUserMessageItemPickup::set_itemname(const ::std::string& value) {
  set_has_itemname();
  itemname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageItemPickup.itemname)
}
#if LANG_CXX11
inline void CUserMessageItemPickup::set_itemname(::std::string&& value) {
  set_has_itemname();
  itemname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageItemPickup.itemname)
}
#endif
inline void CUserMessageItemPickup::set_itemname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_itemname();
  itemname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageItemPickup.itemname)
}
inline void CUserMessageItemPickup::set_itemname(const char* value, size_t size) {
  set_has_itemname();
  itemname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageItemPickup.itemname)
}
inline ::std::string* CUserMessageItemPickup::mutable_itemname() {
  set_has_itemname();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageItemPickup.itemname)
  return itemname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageItemPickup::release_itemname() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageItemPickup.itemname)
  clear_has_itemname();
  return itemname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageItemPickup::set_allocated_itemname(::std::string* itemname) {
  if (itemname != NULL) {
    set_has_itemname();
  } else {
    clear_has_itemname();
  }
  itemname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), itemname);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageItemPickup.itemname)
}

// -------------------------------------------------------------------

// CUserMessageAmmoDenied

// optional uint32 ammo_id = 1;
inline bool CUserMessageAmmoDenied::has_ammo_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageAmmoDenied::set_has_ammo_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageAmmoDenied::clear_has_ammo_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageAmmoDenied::clear_ammo_id() {
  ammo_id_ = 0u;
  clear_has_ammo_id();
}
inline ::google::protobuf::uint32 CUserMessageAmmoDenied::ammo_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAmmoDenied.ammo_id)
  return ammo_id_;
}
inline void CUserMessageAmmoDenied::set_ammo_id(::google::protobuf::uint32 value) {
  set_has_ammo_id();
  ammo_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAmmoDenied.ammo_id)
}

// -------------------------------------------------------------------

// CUserMessageCrosshairAngle

// optional .proto.dota.CMsgQAngle angcrosshair = 1;
inline bool CUserMessageCrosshairAngle::has_angcrosshair() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCrosshairAngle::set_has_angcrosshair() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCrosshairAngle::clear_has_angcrosshair() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCrosshairAngle::clear_angcrosshair() {
  if (angcrosshair_ != NULL) angcrosshair_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angcrosshair();
}
inline const ::proto::dota::CMsgQAngle& CUserMessageCrosshairAngle::angcrosshair() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCrosshairAngle.angcrosshair)
  return angcrosshair_ != NULL ? *angcrosshair_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CUserMessageCrosshairAngle::mutable_angcrosshair() {
  set_has_angcrosshair();
  if (angcrosshair_ == NULL) {
    angcrosshair_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageCrosshairAngle.angcrosshair)
  return angcrosshair_;
}
inline ::proto::dota::CMsgQAngle* CUserMessageCrosshairAngle::release_angcrosshair() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageCrosshairAngle.angcrosshair)
  clear_has_angcrosshair();
  ::proto::dota::CMsgQAngle* temp = angcrosshair_;
  angcrosshair_ = NULL;
  return temp;
}
inline void CUserMessageCrosshairAngle::set_allocated_angcrosshair(::proto::dota::CMsgQAngle* angcrosshair) {
  delete angcrosshair_;
  angcrosshair_ = angcrosshair;
  if (angcrosshair) {
    set_has_angcrosshair();
  } else {
    clear_has_angcrosshair();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageCrosshairAngle.angcrosshair)
}

// -------------------------------------------------------------------

// CUserMessageShowMenu

// optional uint32 validslots = 1;
inline bool CUserMessageShowMenu::has_validslots() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageShowMenu::set_has_validslots() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageShowMenu::clear_has_validslots() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageShowMenu::clear_validslots() {
  validslots_ = 0u;
  clear_has_validslots();
}
inline ::google::protobuf::uint32 CUserMessageShowMenu::validslots() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShowMenu.validslots)
  return validslots_;
}
inline void CUserMessageShowMenu::set_validslots(::google::protobuf::uint32 value) {
  set_has_validslots();
  validslots_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShowMenu.validslots)
}

// optional uint32 displaytime = 2;
inline bool CUserMessageShowMenu::has_displaytime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageShowMenu::set_has_displaytime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageShowMenu::clear_has_displaytime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageShowMenu::clear_displaytime() {
  displaytime_ = 0u;
  clear_has_displaytime();
}
inline ::google::protobuf::uint32 CUserMessageShowMenu::displaytime() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShowMenu.displaytime)
  return displaytime_;
}
inline void CUserMessageShowMenu::set_displaytime(::google::protobuf::uint32 value) {
  set_has_displaytime();
  displaytime_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShowMenu.displaytime)
}

// optional bool needmore = 3;
inline bool CUserMessageShowMenu::has_needmore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMessageShowMenu::set_has_needmore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMessageShowMenu::clear_has_needmore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMessageShowMenu::clear_needmore() {
  needmore_ = false;
  clear_has_needmore();
}
inline bool CUserMessageShowMenu::needmore() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShowMenu.needmore)
  return needmore_;
}
inline void CUserMessageShowMenu::set_needmore(bool value) {
  set_has_needmore();
  needmore_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShowMenu.needmore)
}

// optional string menustring = 4;
inline bool CUserMessageShowMenu::has_menustring() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageShowMenu::set_has_menustring() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageShowMenu::clear_has_menustring() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageShowMenu::clear_menustring() {
  menustring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_menustring();
}
inline const ::std::string& CUserMessageShowMenu::menustring() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageShowMenu.menustring)
  return menustring_.GetNoArena();
}
inline void CUserMessageShowMenu::set_menustring(const ::std::string& value) {
  set_has_menustring();
  menustring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageShowMenu.menustring)
}
#if LANG_CXX11
inline void CUserMessageShowMenu::set_menustring(::std::string&& value) {
  set_has_menustring();
  menustring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageShowMenu.menustring)
}
#endif
inline void CUserMessageShowMenu::set_menustring(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_menustring();
  menustring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageShowMenu.menustring)
}
inline void CUserMessageShowMenu::set_menustring(const char* value, size_t size) {
  set_has_menustring();
  menustring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageShowMenu.menustring)
}
inline ::std::string* CUserMessageShowMenu::mutable_menustring() {
  set_has_menustring();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageShowMenu.menustring)
  return menustring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageShowMenu::release_menustring() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageShowMenu.menustring)
  clear_has_menustring();
  return menustring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageShowMenu::set_allocated_menustring(::std::string* menustring) {
  if (menustring != NULL) {
    set_has_menustring();
  } else {
    clear_has_menustring();
  }
  menustring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), menustring);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageShowMenu.menustring)
}

// -------------------------------------------------------------------

// CUserMessageCreditsMsg

// optional .proto.dota.eRollType rolltype = 1 [default = ROLL_NONE];
inline bool CUserMessageCreditsMsg::has_rolltype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageCreditsMsg::set_has_rolltype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageCreditsMsg::clear_has_rolltype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageCreditsMsg::clear_rolltype() {
  rolltype_ = -1;
  clear_has_rolltype();
}
inline ::proto::dota::eRollType CUserMessageCreditsMsg::rolltype() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCreditsMsg.rolltype)
  return static_cast< ::proto::dota::eRollType >(rolltype_);
}
inline void CUserMessageCreditsMsg::set_rolltype(::proto::dota::eRollType value) {
  assert(::proto::dota::eRollType_IsValid(value));
  set_has_rolltype();
  rolltype_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCreditsMsg.rolltype)
}

// optional float logo_length = 2;
inline bool CUserMessageCreditsMsg::has_logo_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCreditsMsg::set_has_logo_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCreditsMsg::clear_has_logo_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCreditsMsg::clear_logo_length() {
  logo_length_ = 0;
  clear_has_logo_length();
}
inline float CUserMessageCreditsMsg::logo_length() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCreditsMsg.logo_length)
  return logo_length_;
}
inline void CUserMessageCreditsMsg::set_logo_length(float value) {
  set_has_logo_length();
  logo_length_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCreditsMsg.logo_length)
}

// -------------------------------------------------------------------

// CEntityMessagePlayJingle

// -------------------------------------------------------------------

// CEntityMessageScreenOverlay

// optional bool start_effect = 1;
inline bool CEntityMessageScreenOverlay::has_start_effect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CEntityMessageScreenOverlay::set_has_start_effect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CEntityMessageScreenOverlay::clear_has_start_effect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CEntityMessageScreenOverlay::clear_start_effect() {
  start_effect_ = false;
  clear_has_start_effect();
}
inline bool CEntityMessageScreenOverlay::start_effect() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageScreenOverlay.start_effect)
  return start_effect_;
}
inline void CEntityMessageScreenOverlay::set_start_effect(bool value) {
  set_has_start_effect();
  start_effect_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageScreenOverlay.start_effect)
}

// -------------------------------------------------------------------

// CEntityMessageRemoveAllDecals

// optional bool remove_decals = 1;
inline bool CEntityMessageRemoveAllDecals::has_remove_decals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CEntityMessageRemoveAllDecals::set_has_remove_decals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CEntityMessageRemoveAllDecals::clear_has_remove_decals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CEntityMessageRemoveAllDecals::clear_remove_decals() {
  remove_decals_ = false;
  clear_has_remove_decals();
}
inline bool CEntityMessageRemoveAllDecals::remove_decals() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageRemoveAllDecals.remove_decals)
  return remove_decals_;
}
inline void CEntityMessageRemoveAllDecals::set_remove_decals(bool value) {
  set_has_remove_decals();
  remove_decals_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageRemoveAllDecals.remove_decals)
}

// -------------------------------------------------------------------

// CEntityMessagePropagateForce

// optional .proto.dota.CMsgVector impulse = 1;
inline bool CEntityMessagePropagateForce::has_impulse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CEntityMessagePropagateForce::set_has_impulse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CEntityMessagePropagateForce::clear_has_impulse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CEntityMessagePropagateForce::clear_impulse() {
  if (impulse_ != NULL) impulse_->::proto::dota::CMsgVector::Clear();
  clear_has_impulse();
}
inline const ::proto::dota::CMsgVector& CEntityMessagePropagateForce::impulse() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessagePropagateForce.impulse)
  return impulse_ != NULL ? *impulse_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CEntityMessagePropagateForce::mutable_impulse() {
  set_has_impulse();
  if (impulse_ == NULL) {
    impulse_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CEntityMessagePropagateForce.impulse)
  return impulse_;
}
inline ::proto::dota::CMsgVector* CEntityMessagePropagateForce::release_impulse() {
  // @@protoc_insertion_point(field_release:proto.dota.CEntityMessagePropagateForce.impulse)
  clear_has_impulse();
  ::proto::dota::CMsgVector* temp = impulse_;
  impulse_ = NULL;
  return temp;
}
inline void CEntityMessagePropagateForce::set_allocated_impulse(::proto::dota::CMsgVector* impulse) {
  delete impulse_;
  impulse_ = impulse;
  if (impulse) {
    set_has_impulse();
  } else {
    clear_has_impulse();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CEntityMessagePropagateForce.impulse)
}

// -------------------------------------------------------------------

// CEntityMessageDoSpark

// optional .proto.dota.CMsgVector origin = 1;
inline bool CEntityMessageDoSpark::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CEntityMessageDoSpark::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CEntityMessageDoSpark::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CEntityMessageDoSpark::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CEntityMessageDoSpark::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CEntityMessageDoSpark::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CEntityMessageDoSpark.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CEntityMessageDoSpark::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CEntityMessageDoSpark.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CEntityMessageDoSpark::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CEntityMessageDoSpark.origin)
}

// optional uint32 entityindex = 2;
inline bool CEntityMessageDoSpark::has_entityindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CEntityMessageDoSpark::set_has_entityindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CEntityMessageDoSpark::clear_has_entityindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CEntityMessageDoSpark::clear_entityindex() {
  entityindex_ = 0u;
  clear_has_entityindex();
}
inline ::google::protobuf::uint32 CEntityMessageDoSpark::entityindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.entityindex)
  return entityindex_;
}
inline void CEntityMessageDoSpark::set_entityindex(::google::protobuf::uint32 value) {
  set_has_entityindex();
  entityindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageDoSpark.entityindex)
}

// optional float radius = 3;
inline bool CEntityMessageDoSpark::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CEntityMessageDoSpark::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CEntityMessageDoSpark::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CEntityMessageDoSpark::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CEntityMessageDoSpark::radius() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.radius)
  return radius_;
}
inline void CEntityMessageDoSpark::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageDoSpark.radius)
}

// optional fixed32 color = 4;
inline bool CEntityMessageDoSpark::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CEntityMessageDoSpark::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CEntityMessageDoSpark::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CEntityMessageDoSpark::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CEntityMessageDoSpark::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.color)
  return color_;
}
inline void CEntityMessageDoSpark::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageDoSpark.color)
}

// optional uint32 beams = 5;
inline bool CEntityMessageDoSpark::has_beams() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CEntityMessageDoSpark::set_has_beams() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CEntityMessageDoSpark::clear_has_beams() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CEntityMessageDoSpark::clear_beams() {
  beams_ = 0u;
  clear_has_beams();
}
inline ::google::protobuf::uint32 CEntityMessageDoSpark::beams() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.beams)
  return beams_;
}
inline void CEntityMessageDoSpark::set_beams(::google::protobuf::uint32 value) {
  set_has_beams();
  beams_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageDoSpark.beams)
}

// optional float thick = 6;
inline bool CEntityMessageDoSpark::has_thick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CEntityMessageDoSpark::set_has_thick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CEntityMessageDoSpark::clear_has_thick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CEntityMessageDoSpark::clear_thick() {
  thick_ = 0;
  clear_has_thick();
}
inline float CEntityMessageDoSpark::thick() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.thick)
  return thick_;
}
inline void CEntityMessageDoSpark::set_thick(float value) {
  set_has_thick();
  thick_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageDoSpark.thick)
}

// optional float duration = 7;
inline bool CEntityMessageDoSpark::has_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CEntityMessageDoSpark::set_has_duration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CEntityMessageDoSpark::clear_has_duration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CEntityMessageDoSpark::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CEntityMessageDoSpark::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageDoSpark.duration)
  return duration_;
}
inline void CEntityMessageDoSpark::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageDoSpark.duration)
}

// -------------------------------------------------------------------

// CEntityMessageFixAngle

// optional bool relative = 1;
inline bool CEntityMessageFixAngle::has_relative() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CEntityMessageFixAngle::set_has_relative() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CEntityMessageFixAngle::clear_has_relative() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CEntityMessageFixAngle::clear_relative() {
  relative_ = false;
  clear_has_relative();
}
inline bool CEntityMessageFixAngle::relative() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageFixAngle.relative)
  return relative_;
}
inline void CEntityMessageFixAngle::set_relative(bool value) {
  set_has_relative();
  relative_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CEntityMessageFixAngle.relative)
}

// optional .proto.dota.CMsgQAngle angle = 2;
inline bool CEntityMessageFixAngle::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CEntityMessageFixAngle::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CEntityMessageFixAngle::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CEntityMessageFixAngle::clear_angle() {
  if (angle_ != NULL) angle_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angle();
}
inline const ::proto::dota::CMsgQAngle& CEntityMessageFixAngle::angle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CEntityMessageFixAngle.angle)
  return angle_ != NULL ? *angle_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CEntityMessageFixAngle::mutable_angle() {
  set_has_angle();
  if (angle_ == NULL) {
    angle_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CEntityMessageFixAngle.angle)
  return angle_;
}
inline ::proto::dota::CMsgQAngle* CEntityMessageFixAngle::release_angle() {
  // @@protoc_insertion_point(field_release:proto.dota.CEntityMessageFixAngle.angle)
  clear_has_angle();
  ::proto::dota::CMsgQAngle* temp = angle_;
  angle_ = NULL;
  return temp;
}
inline void CEntityMessageFixAngle::set_allocated_angle(::proto::dota::CMsgQAngle* angle) {
  delete angle_;
  angle_ = angle;
  if (angle) {
    set_has_angle();
  } else {
    clear_has_angle();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CEntityMessageFixAngle.angle)
}

// -------------------------------------------------------------------

// CUserMessageCameraTransition_Transition_DataDriven

// optional string filename = 1;
inline bool CUserMessageCameraTransition_Transition_DataDriven::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& CUserMessageCameraTransition_Transition_DataDriven::filename() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
  return filename_.GetNoArena();
}
inline void CUserMessageCameraTransition_Transition_DataDriven::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
}
#if LANG_CXX11
inline void CUserMessageCameraTransition_Transition_DataDriven::set_filename(::std::string&& value) {
  set_has_filename();
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
}
#endif
inline void CUserMessageCameraTransition_Transition_DataDriven::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
}
inline void CUserMessageCameraTransition_Transition_DataDriven::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
}
inline ::std::string* CUserMessageCameraTransition_Transition_DataDriven::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageCameraTransition_Transition_DataDriven::release_filename() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageCameraTransition_Transition_DataDriven::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.filename)
}

// optional int32 attach_ent_index = 2;
inline bool CUserMessageCameraTransition_Transition_DataDriven::has_attach_ent_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::set_has_attach_ent_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::clear_has_attach_ent_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::clear_attach_ent_index() {
  attach_ent_index_ = 0;
  clear_has_attach_ent_index();
}
inline ::google::protobuf::int32 CUserMessageCameraTransition_Transition_DataDriven::attach_ent_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.attach_ent_index)
  return attach_ent_index_;
}
inline void CUserMessageCameraTransition_Transition_DataDriven::set_attach_ent_index(::google::protobuf::int32 value) {
  set_has_attach_ent_index();
  attach_ent_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCameraTransition.Transition_DataDriven.attach_ent_index)
}

// -------------------------------------------------------------------

// CUserMessageCameraTransition

// optional uint32 camera_type = 1;
inline bool CUserMessageCameraTransition::has_camera_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageCameraTransition::set_has_camera_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageCameraTransition::clear_has_camera_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageCameraTransition::clear_camera_type() {
  camera_type_ = 0u;
  clear_has_camera_type();
}
inline ::google::protobuf::uint32 CUserMessageCameraTransition::camera_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCameraTransition.camera_type)
  return camera_type_;
}
inline void CUserMessageCameraTransition::set_camera_type(::google::protobuf::uint32 value) {
  set_has_camera_type();
  camera_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCameraTransition.camera_type)
}

// optional float duration = 2;
inline bool CUserMessageCameraTransition::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMessageCameraTransition::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMessageCameraTransition::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMessageCameraTransition::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CUserMessageCameraTransition::duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCameraTransition.duration)
  return duration_;
}
inline void CUserMessageCameraTransition::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageCameraTransition.duration)
}

// optional .proto.dota.CUserMessageCameraTransition.Transition_DataDriven params_data_driven = 3;
inline bool CUserMessageCameraTransition::has_params_data_driven() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageCameraTransition::set_has_params_data_driven() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageCameraTransition::clear_has_params_data_driven() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageCameraTransition::clear_params_data_driven() {
  if (params_data_driven_ != NULL) params_data_driven_->::proto::dota::CUserMessageCameraTransition_Transition_DataDriven::Clear();
  clear_has_params_data_driven();
}
inline const ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven& CUserMessageCameraTransition::params_data_driven() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageCameraTransition.params_data_driven)
  return params_data_driven_ != NULL ? *params_data_driven_
                         : *::proto::dota::CUserMessageCameraTransition_Transition_DataDriven::internal_default_instance();
}
inline ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* CUserMessageCameraTransition::mutable_params_data_driven() {
  set_has_params_data_driven();
  if (params_data_driven_ == NULL) {
    params_data_driven_ = new ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageCameraTransition.params_data_driven)
  return params_data_driven_;
}
inline ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* CUserMessageCameraTransition::release_params_data_driven() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageCameraTransition.params_data_driven)
  clear_has_params_data_driven();
  ::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* temp = params_data_driven_;
  params_data_driven_ = NULL;
  return temp;
}
inline void CUserMessageCameraTransition::set_allocated_params_data_driven(::proto::dota::CUserMessageCameraTransition_Transition_DataDriven* params_data_driven) {
  delete params_data_driven_;
  params_data_driven_ = params_data_driven;
  if (params_data_driven) {
    set_has_params_data_driven();
  } else {
    clear_has_params_data_driven();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageCameraTransition.params_data_driven)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_ReleaseParticleIndex

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_CreateParticle

// optional fixed64 particle_name_index = 1;
inline bool CUserMsg_ParticleManager_CreateParticle::has_particle_name_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_CreateParticle::set_has_particle_name_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_CreateParticle::clear_has_particle_name_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_CreateParticle::clear_particle_name_index() {
  particle_name_index_ = GOOGLE_ULONGLONG(0);
  clear_has_particle_name_index();
}
inline ::google::protobuf::uint64 CUserMsg_ParticleManager_CreateParticle::particle_name_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.CreateParticle.particle_name_index)
  return particle_name_index_;
}
inline void CUserMsg_ParticleManager_CreateParticle::set_particle_name_index(::google::protobuf::uint64 value) {
  set_has_particle_name_index();
  particle_name_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.CreateParticle.particle_name_index)
}

// optional int32 attach_type = 2;
inline bool CUserMsg_ParticleManager_CreateParticle::has_attach_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_CreateParticle::set_has_attach_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_CreateParticle::clear_has_attach_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_CreateParticle::clear_attach_type() {
  attach_type_ = 0;
  clear_has_attach_type();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_CreateParticle::attach_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.CreateParticle.attach_type)
  return attach_type_;
}
inline void CUserMsg_ParticleManager_CreateParticle::set_attach_type(::google::protobuf::int32 value) {
  set_has_attach_type();
  attach_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.CreateParticle.attach_type)
}

// optional int32 entity_handle = 3;
inline bool CUserMsg_ParticleManager_CreateParticle::has_entity_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMsg_ParticleManager_CreateParticle::set_has_entity_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMsg_ParticleManager_CreateParticle::clear_has_entity_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMsg_ParticleManager_CreateParticle::clear_entity_handle() {
  entity_handle_ = 0;
  clear_has_entity_handle();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_CreateParticle::entity_handle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.CreateParticle.entity_handle)
  return entity_handle_;
}
inline void CUserMsg_ParticleManager_CreateParticle::set_entity_handle(::google::protobuf::int32 value) {
  set_has_entity_handle();
  entity_handle_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.CreateParticle.entity_handle)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_DestroyParticle

// optional bool destroy_immediately = 1;
inline bool CUserMsg_ParticleManager_DestroyParticle::has_destroy_immediately() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_DestroyParticle::set_has_destroy_immediately() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_DestroyParticle::clear_has_destroy_immediately() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_DestroyParticle::clear_destroy_immediately() {
  destroy_immediately_ = false;
  clear_has_destroy_immediately();
}
inline bool CUserMsg_ParticleManager_DestroyParticle::destroy_immediately() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.DestroyParticle.destroy_immediately)
  return destroy_immediately_;
}
inline void CUserMsg_ParticleManager_DestroyParticle::set_destroy_immediately(bool value) {
  set_has_destroy_immediately();
  destroy_immediately_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.DestroyParticle.destroy_immediately)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_DestroyParticleInvolving

// optional bool destroy_immediately = 1;
inline bool CUserMsg_ParticleManager_DestroyParticleInvolving::has_destroy_immediately() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::set_has_destroy_immediately() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::clear_has_destroy_immediately() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::clear_destroy_immediately() {
  destroy_immediately_ = false;
  clear_has_destroy_immediately();
}
inline bool CUserMsg_ParticleManager_DestroyParticleInvolving::destroy_immediately() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving.destroy_immediately)
  return destroy_immediately_;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::set_destroy_immediately(bool value) {
  set_has_destroy_immediately();
  destroy_immediately_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving.destroy_immediately)
}

// optional int32 entity_handle = 3;
inline bool CUserMsg_ParticleManager_DestroyParticleInvolving::has_entity_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::set_has_entity_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::clear_has_entity_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::clear_entity_handle() {
  entity_handle_ = 0;
  clear_has_entity_handle();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_DestroyParticleInvolving::entity_handle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving.entity_handle)
  return entity_handle_;
}
inline void CUserMsg_ParticleManager_DestroyParticleInvolving::set_entity_handle(::google::protobuf::int32 value) {
  set_has_entity_handle();
  entity_handle_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving.entity_handle)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticle

// optional int32 control_point = 1;
inline bool CUserMsg_ParticleManager_UpdateParticle::has_control_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticle::set_has_control_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticle::clear_has_control_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticle::clear_control_point() {
  control_point_ = 0;
  clear_has_control_point();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticle::control_point() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticle.control_point)
  return control_point_;
}
inline void CUserMsg_ParticleManager_UpdateParticle::set_control_point(::google::protobuf::int32 value) {
  set_has_control_point();
  control_point_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticle.control_point)
}

// optional .proto.dota.CMsgVector position = 2;
inline bool CUserMsg_ParticleManager_UpdateParticle::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticle::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticle::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticle::clear_position() {
  if (position_ != NULL) position_->::proto::dota::CMsgVector::Clear();
  clear_has_position();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticle::position() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticle.position)
  return position_ != NULL ? *position_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticle::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticle.position)
  return position_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticle::release_position() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticle.position)
  clear_has_position();
  ::proto::dota::CMsgVector* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticle::set_allocated_position(::proto::dota::CMsgVector* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticle.position)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleFwd

// optional int32 control_point = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleFwd::has_control_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::set_has_control_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::clear_has_control_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::clear_control_point() {
  control_point_ = 0;
  clear_has_control_point();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleFwd::control_point() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd.control_point)
  return control_point_;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::set_control_point(::google::protobuf::int32 value) {
  set_has_control_point();
  control_point_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd.control_point)
}

// optional .proto.dota.CMsgVector forward = 2;
inline bool CUserMsg_ParticleManager_UpdateParticleFwd::has_forward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::set_has_forward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::clear_has_forward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::clear_forward() {
  if (forward_ != NULL) forward_->::proto::dota::CMsgVector::Clear();
  clear_has_forward();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleFwd::forward() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd.forward)
  return forward_ != NULL ? *forward_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleFwd::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) {
    forward_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd.forward)
  return forward_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleFwd::release_forward() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd.forward)
  clear_has_forward();
  ::proto::dota::CMsgVector* temp = forward_;
  forward_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleFwd::set_allocated_forward(::proto::dota::CMsgVector* forward) {
  delete forward_;
  forward_ = forward;
  if (forward) {
    set_has_forward();
  } else {
    clear_has_forward();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd.forward)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleOrient

// optional int32 control_point = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleOrient::has_control_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_has_control_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_has_control_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_control_point() {
  control_point_ = 0;
  clear_has_control_point();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleOrient::control_point() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.control_point)
  return control_point_;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_control_point(::google::protobuf::int32 value) {
  set_has_control_point();
  control_point_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.control_point)
}

// optional .proto.dota.CMsgVector forward = 2;
inline bool CUserMsg_ParticleManager_UpdateParticleOrient::has_forward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_has_forward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_has_forward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_forward() {
  if (forward_ != NULL) forward_->::proto::dota::CMsgVector::Clear();
  clear_has_forward();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleOrient::forward() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.forward)
  return forward_ != NULL ? *forward_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOrient::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) {
    forward_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.forward)
  return forward_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOrient::release_forward() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.forward)
  clear_has_forward();
  ::proto::dota::CMsgVector* temp = forward_;
  forward_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_allocated_forward(::proto::dota::CMsgVector* forward) {
  delete forward_;
  forward_ = forward;
  if (forward) {
    set_has_forward();
  } else {
    clear_has_forward();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.forward)
}

// optional .proto.dota.CMsgVector right = 3;
inline bool CUserMsg_ParticleManager_UpdateParticleOrient::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_right() {
  if (right_ != NULL) right_->::proto::dota::CMsgVector::Clear();
  clear_has_right();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleOrient::right() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.right)
  return right_ != NULL ? *right_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOrient::mutable_right() {
  set_has_right();
  if (right_ == NULL) {
    right_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.right)
  return right_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOrient::release_right() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.right)
  clear_has_right();
  ::proto::dota::CMsgVector* temp = right_;
  right_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_allocated_right(::proto::dota::CMsgVector* right) {
  delete right_;
  right_ = right;
  if (right) {
    set_has_right();
  } else {
    clear_has_right();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.right)
}

// optional .proto.dota.CMsgVector up = 4;
inline bool CUserMsg_ParticleManager_UpdateParticleOrient::has_up() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_has_up() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_has_up() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::clear_up() {
  if (up_ != NULL) up_->::proto::dota::CMsgVector::Clear();
  clear_has_up();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleOrient::up() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.up)
  return up_ != NULL ? *up_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOrient::mutable_up() {
  set_has_up();
  if (up_ == NULL) {
    up_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.up)
  return up_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOrient::release_up() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.up)
  clear_has_up();
  ::proto::dota::CMsgVector* temp = up_;
  up_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleOrient::set_allocated_up(::proto::dota::CMsgVector* up) {
  delete up_;
  up_ = up;
  if (up) {
    set_has_up();
  } else {
    clear_has_up();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient.up)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleFallback

// optional int32 control_point = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleFallback::has_control_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::set_has_control_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::clear_has_control_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::clear_control_point() {
  control_point_ = 0;
  clear_has_control_point();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleFallback::control_point() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback.control_point)
  return control_point_;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::set_control_point(::google::protobuf::int32 value) {
  set_has_control_point();
  control_point_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback.control_point)
}

// optional .proto.dota.CMsgVector position = 2;
inline bool CUserMsg_ParticleManager_UpdateParticleFallback::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::clear_position() {
  if (position_ != NULL) position_->::proto::dota::CMsgVector::Clear();
  clear_has_position();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleFallback::position() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback.position)
  return position_ != NULL ? *position_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleFallback::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback.position)
  return position_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleFallback::release_position() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback.position)
  clear_has_position();
  ::proto::dota::CMsgVector* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleFallback::set_allocated_position(::proto::dota::CMsgVector* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback.position)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleOffset

// optional int32 control_point = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleOffset::has_control_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::set_has_control_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::clear_has_control_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::clear_control_point() {
  control_point_ = 0;
  clear_has_control_point();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleOffset::control_point() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset.control_point)
  return control_point_;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::set_control_point(::google::protobuf::int32 value) {
  set_has_control_point();
  control_point_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset.control_point)
}

// optional .proto.dota.CMsgVector origin_offset = 2;
inline bool CUserMsg_ParticleManager_UpdateParticleOffset::has_origin_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::set_has_origin_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::clear_has_origin_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::clear_origin_offset() {
  if (origin_offset_ != NULL) origin_offset_->::proto::dota::CMsgVector::Clear();
  clear_has_origin_offset();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleOffset::origin_offset() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset)
  return origin_offset_ != NULL ? *origin_offset_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOffset::mutable_origin_offset() {
  set_has_origin_offset();
  if (origin_offset_ == NULL) {
    origin_offset_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset)
  return origin_offset_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleOffset::release_origin_offset() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset)
  clear_has_origin_offset();
  ::proto::dota::CMsgVector* temp = origin_offset_;
  origin_offset_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleOffset::set_allocated_origin_offset(::proto::dota::CMsgVector* origin_offset) {
  delete origin_offset_;
  origin_offset_ = origin_offset;
  if (origin_offset) {
    set_has_origin_offset();
  } else {
    clear_has_origin_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleEnt

// optional int32 control_point = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::has_control_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_has_control_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_has_control_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_control_point() {
  control_point_ = 0;
  clear_has_control_point();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleEnt::control_point() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.control_point)
  return control_point_;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_control_point(::google::protobuf::int32 value) {
  set_has_control_point();
  control_point_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.control_point)
}

// optional int32 entity_handle = 2;
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::has_entity_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_has_entity_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_has_entity_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_entity_handle() {
  entity_handle_ = 0;
  clear_has_entity_handle();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleEnt::entity_handle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.entity_handle)
  return entity_handle_;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_entity_handle(::google::protobuf::int32 value) {
  set_has_entity_handle();
  entity_handle_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.entity_handle)
}

// optional int32 attach_type = 3;
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::has_attach_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_has_attach_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_has_attach_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_attach_type() {
  attach_type_ = 0;
  clear_has_attach_type();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleEnt::attach_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.attach_type)
  return attach_type_;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_attach_type(::google::protobuf::int32 value) {
  set_has_attach_type();
  attach_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.attach_type)
}

// optional int32 attachment = 4;
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::has_attachment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_has_attachment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_attachment() {
  attachment_ = 0;
  clear_has_attachment();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_UpdateParticleEnt::attachment() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.attachment)
  return attachment_;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_attachment(::google::protobuf::int32 value) {
  set_has_attachment();
  attachment_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.attachment)
}

// optional .proto.dota.CMsgVector fallback_position = 5;
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::has_fallback_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_has_fallback_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_has_fallback_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_fallback_position() {
  if (fallback_position_ != NULL) fallback_position_->::proto::dota::CMsgVector::Clear();
  clear_has_fallback_position();
}
inline const ::proto::dota::CMsgVector& CUserMsg_ParticleManager_UpdateParticleEnt::fallback_position() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position)
  return fallback_position_ != NULL ? *fallback_position_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleEnt::mutable_fallback_position() {
  set_has_fallback_position();
  if (fallback_position_ == NULL) {
    fallback_position_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position)
  return fallback_position_;
}
inline ::proto::dota::CMsgVector* CUserMsg_ParticleManager_UpdateParticleEnt::release_fallback_position() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position)
  clear_has_fallback_position();
  ::proto::dota::CMsgVector* temp = fallback_position_;
  fallback_position_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_allocated_fallback_position(::proto::dota::CMsgVector* fallback_position) {
  delete fallback_position_;
  fallback_position_ = fallback_position;
  if (fallback_position) {
    set_has_fallback_position();
  } else {
    clear_has_fallback_position();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position)
}

// optional bool include_wearables = 6;
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::has_include_wearables() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_has_include_wearables() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_has_include_wearables() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::clear_include_wearables() {
  include_wearables_ = false;
  clear_has_include_wearables();
}
inline bool CUserMsg_ParticleManager_UpdateParticleEnt::include_wearables() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.include_wearables)
  return include_wearables_;
}
inline void CUserMsg_ParticleManager_UpdateParticleEnt::set_include_wearables(bool value) {
  set_has_include_wearables();
  include_wearables_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt.include_wearables)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleSetFrozen

// optional bool set_frozen = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleSetFrozen::has_set_frozen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleSetFrozen::set_has_set_frozen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleSetFrozen::clear_has_set_frozen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleSetFrozen::clear_set_frozen() {
  set_frozen_ = false;
  clear_has_set_frozen();
}
inline bool CUserMsg_ParticleManager_UpdateParticleSetFrozen::set_frozen() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleSetFrozen.set_frozen)
  return set_frozen_;
}
inline void CUserMsg_ParticleManager_UpdateParticleSetFrozen::set_set_frozen(bool value) {
  set_has_set_frozen();
  set_frozen_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleSetFrozen.set_frozen)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_UpdateParticleShouldDraw

// optional bool should_draw = 1;
inline bool CUserMsg_ParticleManager_UpdateParticleShouldDraw::has_should_draw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_UpdateParticleShouldDraw::set_has_should_draw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleShouldDraw::clear_has_should_draw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_UpdateParticleShouldDraw::clear_should_draw() {
  should_draw_ = false;
  clear_has_should_draw();
}
inline bool CUserMsg_ParticleManager_UpdateParticleShouldDraw::should_draw() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.UpdateParticleShouldDraw.should_draw)
  return should_draw_;
}
inline void CUserMsg_ParticleManager_UpdateParticleShouldDraw::set_should_draw(bool value) {
  set_has_should_draw();
  should_draw_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.UpdateParticleShouldDraw.should_draw)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager_ChangeControlPointAttachment

// optional int32 attachment_old = 1;
inline bool CUserMsg_ParticleManager_ChangeControlPointAttachment::has_attachment_old() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::set_has_attachment_old() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::clear_has_attachment_old() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::clear_attachment_old() {
  attachment_old_ = 0;
  clear_has_attachment_old();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_ChangeControlPointAttachment::attachment_old() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_old)
  return attachment_old_;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::set_attachment_old(::google::protobuf::int32 value) {
  set_has_attachment_old();
  attachment_old_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_old)
}

// optional int32 attachment_new = 2;
inline bool CUserMsg_ParticleManager_ChangeControlPointAttachment::has_attachment_new() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::set_has_attachment_new() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::clear_has_attachment_new() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::clear_attachment_new() {
  attachment_new_ = 0;
  clear_has_attachment_new();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_ChangeControlPointAttachment::attachment_new() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_new)
  return attachment_new_;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::set_attachment_new(::google::protobuf::int32 value) {
  set_has_attachment_new();
  attachment_new_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_new)
}

// optional int32 entity_handle = 3;
inline bool CUserMsg_ParticleManager_ChangeControlPointAttachment::has_entity_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::set_has_entity_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::clear_has_entity_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::clear_entity_handle() {
  entity_handle_ = 0;
  clear_has_entity_handle();
}
inline ::google::protobuf::int32 CUserMsg_ParticleManager_ChangeControlPointAttachment::entity_handle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment.entity_handle)
  return entity_handle_;
}
inline void CUserMsg_ParticleManager_ChangeControlPointAttachment::set_entity_handle(::google::protobuf::int32 value) {
  set_has_entity_handle();
  entity_handle_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment.entity_handle)
}

// -------------------------------------------------------------------

// CUserMsg_ParticleManager

// required .proto.dota.PARTICLE_MESSAGE type = 1 [default = GAME_PARTICLE_MANAGER_EVENT_CREATE];
inline bool CUserMsg_ParticleManager::has_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CUserMsg_ParticleManager::clear_has_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CUserMsg_ParticleManager::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::dota::PARTICLE_MESSAGE CUserMsg_ParticleManager::type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.type)
  return static_cast< ::proto::dota::PARTICLE_MESSAGE >(type_);
}
inline void CUserMsg_ParticleManager::set_type(::proto::dota::PARTICLE_MESSAGE value) {
  assert(::proto::dota::PARTICLE_MESSAGE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.type)
}

// required uint32 index = 2;
inline bool CUserMsg_ParticleManager::has_index() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_index() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CUserMsg_ParticleManager::clear_has_index() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CUserMsg_ParticleManager::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CUserMsg_ParticleManager::index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.index)
  return index_;
}
inline void CUserMsg_ParticleManager::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_ParticleManager.index)
}

// optional .proto.dota.CUserMsg_ParticleManager.ReleaseParticleIndex release_particle_index = 3;
inline bool CUserMsg_ParticleManager::has_release_particle_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_release_particle_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_ParticleManager::clear_has_release_particle_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_ParticleManager::clear_release_particle_index() {
  if (release_particle_index_ != NULL) release_particle_index_->::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex::Clear();
  clear_has_release_particle_index();
}
inline const ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex& CUserMsg_ParticleManager::release_particle_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.release_particle_index)
  return release_particle_index_ != NULL ? *release_particle_index_
                         : *::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* CUserMsg_ParticleManager::mutable_release_particle_index() {
  set_has_release_particle_index();
  if (release_particle_index_ == NULL) {
    release_particle_index_ = new ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.release_particle_index)
  return release_particle_index_;
}
inline ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* CUserMsg_ParticleManager::release_release_particle_index() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.release_particle_index)
  clear_has_release_particle_index();
  ::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* temp = release_particle_index_;
  release_particle_index_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_release_particle_index(::proto::dota::CUserMsg_ParticleManager_ReleaseParticleIndex* release_particle_index) {
  delete release_particle_index_;
  release_particle_index_ = release_particle_index;
  if (release_particle_index) {
    set_has_release_particle_index();
  } else {
    clear_has_release_particle_index();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.release_particle_index)
}

// optional .proto.dota.CUserMsg_ParticleManager.CreateParticle create_particle = 4;
inline bool CUserMsg_ParticleManager::has_create_particle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_create_particle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_ParticleManager::clear_has_create_particle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_ParticleManager::clear_create_particle() {
  if (create_particle_ != NULL) create_particle_->::proto::dota::CUserMsg_ParticleManager_CreateParticle::Clear();
  clear_has_create_particle();
}
inline const ::proto::dota::CUserMsg_ParticleManager_CreateParticle& CUserMsg_ParticleManager::create_particle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.create_particle)
  return create_particle_ != NULL ? *create_particle_
                         : *::proto::dota::CUserMsg_ParticleManager_CreateParticle::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_CreateParticle* CUserMsg_ParticleManager::mutable_create_particle() {
  set_has_create_particle();
  if (create_particle_ == NULL) {
    create_particle_ = new ::proto::dota::CUserMsg_ParticleManager_CreateParticle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.create_particle)
  return create_particle_;
}
inline ::proto::dota::CUserMsg_ParticleManager_CreateParticle* CUserMsg_ParticleManager::release_create_particle() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.create_particle)
  clear_has_create_particle();
  ::proto::dota::CUserMsg_ParticleManager_CreateParticle* temp = create_particle_;
  create_particle_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_create_particle(::proto::dota::CUserMsg_ParticleManager_CreateParticle* create_particle) {
  delete create_particle_;
  create_particle_ = create_particle;
  if (create_particle) {
    set_has_create_particle();
  } else {
    clear_has_create_particle();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.create_particle)
}

// optional .proto.dota.CUserMsg_ParticleManager.DestroyParticle destroy_particle = 5;
inline bool CUserMsg_ParticleManager::has_destroy_particle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_destroy_particle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserMsg_ParticleManager::clear_has_destroy_particle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserMsg_ParticleManager::clear_destroy_particle() {
  if (destroy_particle_ != NULL) destroy_particle_->::proto::dota::CUserMsg_ParticleManager_DestroyParticle::Clear();
  clear_has_destroy_particle();
}
inline const ::proto::dota::CUserMsg_ParticleManager_DestroyParticle& CUserMsg_ParticleManager::destroy_particle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.destroy_particle)
  return destroy_particle_ != NULL ? *destroy_particle_
                         : *::proto::dota::CUserMsg_ParticleManager_DestroyParticle::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_DestroyParticle* CUserMsg_ParticleManager::mutable_destroy_particle() {
  set_has_destroy_particle();
  if (destroy_particle_ == NULL) {
    destroy_particle_ = new ::proto::dota::CUserMsg_ParticleManager_DestroyParticle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.destroy_particle)
  return destroy_particle_;
}
inline ::proto::dota::CUserMsg_ParticleManager_DestroyParticle* CUserMsg_ParticleManager::release_destroy_particle() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.destroy_particle)
  clear_has_destroy_particle();
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticle* temp = destroy_particle_;
  destroy_particle_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_destroy_particle(::proto::dota::CUserMsg_ParticleManager_DestroyParticle* destroy_particle) {
  delete destroy_particle_;
  destroy_particle_ = destroy_particle;
  if (destroy_particle) {
    set_has_destroy_particle();
  } else {
    clear_has_destroy_particle();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.destroy_particle)
}

// optional .proto.dota.CUserMsg_ParticleManager.DestroyParticleInvolving destroy_particle_involving = 6;
inline bool CUserMsg_ParticleManager::has_destroy_particle_involving() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_destroy_particle_involving() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserMsg_ParticleManager::clear_has_destroy_particle_involving() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserMsg_ParticleManager::clear_destroy_particle_involving() {
  if (destroy_particle_involving_ != NULL) destroy_particle_involving_->::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving::Clear();
  clear_has_destroy_particle_involving();
}
inline const ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving& CUserMsg_ParticleManager::destroy_particle_involving() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.destroy_particle_involving)
  return destroy_particle_involving_ != NULL ? *destroy_particle_involving_
                         : *::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* CUserMsg_ParticleManager::mutable_destroy_particle_involving() {
  set_has_destroy_particle_involving();
  if (destroy_particle_involving_ == NULL) {
    destroy_particle_involving_ = new ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.destroy_particle_involving)
  return destroy_particle_involving_;
}
inline ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* CUserMsg_ParticleManager::release_destroy_particle_involving() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.destroy_particle_involving)
  clear_has_destroy_particle_involving();
  ::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* temp = destroy_particle_involving_;
  destroy_particle_involving_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_destroy_particle_involving(::proto::dota::CUserMsg_ParticleManager_DestroyParticleInvolving* destroy_particle_involving) {
  delete destroy_particle_involving_;
  destroy_particle_involving_ = destroy_particle_involving;
  if (destroy_particle_involving) {
    set_has_destroy_particle_involving();
  } else {
    clear_has_destroy_particle_involving();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.destroy_particle_involving)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticle update_particle = 7;
inline bool CUserMsg_ParticleManager::has_update_particle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserMsg_ParticleManager::clear_update_particle() {
  if (update_particle_ != NULL) update_particle_->::proto::dota::CUserMsg_ParticleManager_UpdateParticle::Clear();
  clear_has_update_particle();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticle& CUserMsg_ParticleManager::update_particle() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle)
  return update_particle_ != NULL ? *update_particle_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticle::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticle* CUserMsg_ParticleManager::mutable_update_particle() {
  set_has_update_particle();
  if (update_particle_ == NULL) {
    update_particle_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle)
  return update_particle_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticle* CUserMsg_ParticleManager::release_update_particle() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle)
  clear_has_update_particle();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticle* temp = update_particle_;
  update_particle_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle(::proto::dota::CUserMsg_ParticleManager_UpdateParticle* update_particle) {
  delete update_particle_;
  update_particle_ = update_particle;
  if (update_particle) {
    set_has_update_particle();
  } else {
    clear_has_update_particle();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleFwd update_particle_fwd = 8;
inline bool CUserMsg_ParticleManager::has_update_particle_fwd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_fwd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_fwd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_fwd() {
  if (update_particle_fwd_ != NULL) update_particle_fwd_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd::Clear();
  clear_has_update_particle_fwd();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd& CUserMsg_ParticleManager::update_particle_fwd() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_fwd)
  return update_particle_fwd_ != NULL ? *update_particle_fwd_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* CUserMsg_ParticleManager::mutable_update_particle_fwd() {
  set_has_update_particle_fwd();
  if (update_particle_fwd_ == NULL) {
    update_particle_fwd_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_fwd)
  return update_particle_fwd_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* CUserMsg_ParticleManager::release_update_particle_fwd() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_fwd)
  clear_has_update_particle_fwd();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* temp = update_particle_fwd_;
  update_particle_fwd_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_fwd(::proto::dota::CUserMsg_ParticleManager_UpdateParticleFwd* update_particle_fwd) {
  delete update_particle_fwd_;
  update_particle_fwd_ = update_particle_fwd;
  if (update_particle_fwd) {
    set_has_update_particle_fwd();
  } else {
    clear_has_update_particle_fwd();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_fwd)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleOrient update_particle_orient = 9;
inline bool CUserMsg_ParticleManager::has_update_particle_orient() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_orient() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_orient() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_orient() {
  if (update_particle_orient_ != NULL) update_particle_orient_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient::Clear();
  clear_has_update_particle_orient();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient& CUserMsg_ParticleManager::update_particle_orient() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_orient)
  return update_particle_orient_ != NULL ? *update_particle_orient_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* CUserMsg_ParticleManager::mutable_update_particle_orient() {
  set_has_update_particle_orient();
  if (update_particle_orient_ == NULL) {
    update_particle_orient_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_orient)
  return update_particle_orient_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* CUserMsg_ParticleManager::release_update_particle_orient() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_orient)
  clear_has_update_particle_orient();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* temp = update_particle_orient_;
  update_particle_orient_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_orient(::proto::dota::CUserMsg_ParticleManager_UpdateParticleOrient* update_particle_orient) {
  delete update_particle_orient_;
  update_particle_orient_ = update_particle_orient;
  if (update_particle_orient) {
    set_has_update_particle_orient();
  } else {
    clear_has_update_particle_orient();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_orient)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleFallback update_particle_fallback = 10;
inline bool CUserMsg_ParticleManager::has_update_particle_fallback() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_fallback() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_fallback() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_fallback() {
  if (update_particle_fallback_ != NULL) update_particle_fallback_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback::Clear();
  clear_has_update_particle_fallback();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback& CUserMsg_ParticleManager::update_particle_fallback() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_fallback)
  return update_particle_fallback_ != NULL ? *update_particle_fallback_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* CUserMsg_ParticleManager::mutable_update_particle_fallback() {
  set_has_update_particle_fallback();
  if (update_particle_fallback_ == NULL) {
    update_particle_fallback_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_fallback)
  return update_particle_fallback_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* CUserMsg_ParticleManager::release_update_particle_fallback() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_fallback)
  clear_has_update_particle_fallback();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* temp = update_particle_fallback_;
  update_particle_fallback_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_fallback(::proto::dota::CUserMsg_ParticleManager_UpdateParticleFallback* update_particle_fallback) {
  delete update_particle_fallback_;
  update_particle_fallback_ = update_particle_fallback;
  if (update_particle_fallback) {
    set_has_update_particle_fallback();
  } else {
    clear_has_update_particle_fallback();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_fallback)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleOffset update_particle_offset = 11;
inline bool CUserMsg_ParticleManager::has_update_particle_offset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_offset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_offset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_offset() {
  if (update_particle_offset_ != NULL) update_particle_offset_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset::Clear();
  clear_has_update_particle_offset();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset& CUserMsg_ParticleManager::update_particle_offset() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_offset)
  return update_particle_offset_ != NULL ? *update_particle_offset_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* CUserMsg_ParticleManager::mutable_update_particle_offset() {
  set_has_update_particle_offset();
  if (update_particle_offset_ == NULL) {
    update_particle_offset_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_offset)
  return update_particle_offset_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* CUserMsg_ParticleManager::release_update_particle_offset() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_offset)
  clear_has_update_particle_offset();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* temp = update_particle_offset_;
  update_particle_offset_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_offset(::proto::dota::CUserMsg_ParticleManager_UpdateParticleOffset* update_particle_offset) {
  delete update_particle_offset_;
  update_particle_offset_ = update_particle_offset;
  if (update_particle_offset) {
    set_has_update_particle_offset();
  } else {
    clear_has_update_particle_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_offset)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleEnt update_particle_ent = 12;
inline bool CUserMsg_ParticleManager::has_update_particle_ent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_ent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_ent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_ent() {
  if (update_particle_ent_ != NULL) update_particle_ent_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt::Clear();
  clear_has_update_particle_ent();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt& CUserMsg_ParticleManager::update_particle_ent() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_ent)
  return update_particle_ent_ != NULL ? *update_particle_ent_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* CUserMsg_ParticleManager::mutable_update_particle_ent() {
  set_has_update_particle_ent();
  if (update_particle_ent_ == NULL) {
    update_particle_ent_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_ent)
  return update_particle_ent_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* CUserMsg_ParticleManager::release_update_particle_ent() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_ent)
  clear_has_update_particle_ent();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* temp = update_particle_ent_;
  update_particle_ent_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_ent(::proto::dota::CUserMsg_ParticleManager_UpdateParticleEnt* update_particle_ent) {
  delete update_particle_ent_;
  update_particle_ent_ = update_particle_ent;
  if (update_particle_ent) {
    set_has_update_particle_ent();
  } else {
    clear_has_update_particle_ent();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_ent)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleShouldDraw update_particle_should_draw = 14;
inline bool CUserMsg_ParticleManager::has_update_particle_should_draw() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_should_draw() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_should_draw() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_should_draw() {
  if (update_particle_should_draw_ != NULL) update_particle_should_draw_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw::Clear();
  clear_has_update_particle_should_draw();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw& CUserMsg_ParticleManager::update_particle_should_draw() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_should_draw)
  return update_particle_should_draw_ != NULL ? *update_particle_should_draw_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* CUserMsg_ParticleManager::mutable_update_particle_should_draw() {
  set_has_update_particle_should_draw();
  if (update_particle_should_draw_ == NULL) {
    update_particle_should_draw_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_should_draw)
  return update_particle_should_draw_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* CUserMsg_ParticleManager::release_update_particle_should_draw() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_should_draw)
  clear_has_update_particle_should_draw();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* temp = update_particle_should_draw_;
  update_particle_should_draw_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_should_draw(::proto::dota::CUserMsg_ParticleManager_UpdateParticleShouldDraw* update_particle_should_draw) {
  delete update_particle_should_draw_;
  update_particle_should_draw_ = update_particle_should_draw;
  if (update_particle_should_draw) {
    set_has_update_particle_should_draw();
  } else {
    clear_has_update_particle_should_draw();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_should_draw)
}

// optional .proto.dota.CUserMsg_ParticleManager.UpdateParticleSetFrozen update_particle_set_frozen = 15;
inline bool CUserMsg_ParticleManager::has_update_particle_set_frozen() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_update_particle_set_frozen() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CUserMsg_ParticleManager::clear_has_update_particle_set_frozen() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CUserMsg_ParticleManager::clear_update_particle_set_frozen() {
  if (update_particle_set_frozen_ != NULL) update_particle_set_frozen_->::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen::Clear();
  clear_has_update_particle_set_frozen();
}
inline const ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen& CUserMsg_ParticleManager::update_particle_set_frozen() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.update_particle_set_frozen)
  return update_particle_set_frozen_ != NULL ? *update_particle_set_frozen_
                         : *::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* CUserMsg_ParticleManager::mutable_update_particle_set_frozen() {
  set_has_update_particle_set_frozen();
  if (update_particle_set_frozen_ == NULL) {
    update_particle_set_frozen_ = new ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.update_particle_set_frozen)
  return update_particle_set_frozen_;
}
inline ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* CUserMsg_ParticleManager::release_update_particle_set_frozen() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.update_particle_set_frozen)
  clear_has_update_particle_set_frozen();
  ::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* temp = update_particle_set_frozen_;
  update_particle_set_frozen_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_update_particle_set_frozen(::proto::dota::CUserMsg_ParticleManager_UpdateParticleSetFrozen* update_particle_set_frozen) {
  delete update_particle_set_frozen_;
  update_particle_set_frozen_ = update_particle_set_frozen;
  if (update_particle_set_frozen) {
    set_has_update_particle_set_frozen();
  } else {
    clear_has_update_particle_set_frozen();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.update_particle_set_frozen)
}

// optional .proto.dota.CUserMsg_ParticleManager.ChangeControlPointAttachment change_control_point_attachment = 16;
inline bool CUserMsg_ParticleManager::has_change_control_point_attachment() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CUserMsg_ParticleManager::set_has_change_control_point_attachment() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CUserMsg_ParticleManager::clear_has_change_control_point_attachment() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CUserMsg_ParticleManager::clear_change_control_point_attachment() {
  if (change_control_point_attachment_ != NULL) change_control_point_attachment_->::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment::Clear();
  clear_has_change_control_point_attachment();
}
inline const ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment& CUserMsg_ParticleManager::change_control_point_attachment() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_ParticleManager.change_control_point_attachment)
  return change_control_point_attachment_ != NULL ? *change_control_point_attachment_
                         : *::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment::internal_default_instance();
}
inline ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* CUserMsg_ParticleManager::mutable_change_control_point_attachment() {
  set_has_change_control_point_attachment();
  if (change_control_point_attachment_ == NULL) {
    change_control_point_attachment_ = new ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_ParticleManager.change_control_point_attachment)
  return change_control_point_attachment_;
}
inline ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* CUserMsg_ParticleManager::release_change_control_point_attachment() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_ParticleManager.change_control_point_attachment)
  clear_has_change_control_point_attachment();
  ::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* temp = change_control_point_attachment_;
  change_control_point_attachment_ = NULL;
  return temp;
}
inline void CUserMsg_ParticleManager::set_allocated_change_control_point_attachment(::proto::dota::CUserMsg_ParticleManager_ChangeControlPointAttachment* change_control_point_attachment) {
  delete change_control_point_attachment_;
  change_control_point_attachment_ = change_control_point_attachment;
  if (change_control_point_attachment) {
    set_has_change_control_point_attachment();
  } else {
    clear_has_change_control_point_attachment();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_ParticleManager.change_control_point_attachment)
}

// -------------------------------------------------------------------

// CUserMsg_HudError

// optional int32 order_id = 1;
inline bool CUserMsg_HudError::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_HudError::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_HudError::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_HudError::clear_order_id() {
  order_id_ = 0;
  clear_has_order_id();
}
inline ::google::protobuf::int32 CUserMsg_HudError::order_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_HudError.order_id)
  return order_id_;
}
inline void CUserMsg_HudError::set_order_id(::google::protobuf::int32 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_HudError.order_id)
}

// -------------------------------------------------------------------

// CUserMsg_CustomGameEvent

// optional string event_name = 1;
inline bool CUserMsg_CustomGameEvent::has_event_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMsg_CustomGameEvent::set_has_event_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMsg_CustomGameEvent::clear_has_event_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMsg_CustomGameEvent::clear_event_name() {
  event_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_name();
}
inline const ::std::string& CUserMsg_CustomGameEvent::event_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_CustomGameEvent.event_name)
  return event_name_.GetNoArena();
}
inline void CUserMsg_CustomGameEvent::set_event_name(const ::std::string& value) {
  set_has_event_name();
  event_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_CustomGameEvent.event_name)
}
#if LANG_CXX11
inline void CUserMsg_CustomGameEvent::set_event_name(::std::string&& value) {
  set_has_event_name();
  event_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMsg_CustomGameEvent.event_name)
}
#endif
inline void CUserMsg_CustomGameEvent::set_event_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_event_name();
  event_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMsg_CustomGameEvent.event_name)
}
inline void CUserMsg_CustomGameEvent::set_event_name(const char* value, size_t size) {
  set_has_event_name();
  event_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMsg_CustomGameEvent.event_name)
}
inline ::std::string* CUserMsg_CustomGameEvent::mutable_event_name() {
  set_has_event_name();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_CustomGameEvent.event_name)
  return event_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMsg_CustomGameEvent::release_event_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_CustomGameEvent.event_name)
  clear_has_event_name();
  return event_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMsg_CustomGameEvent::set_allocated_event_name(::std::string* event_name) {
  if (event_name != NULL) {
    set_has_event_name();
  } else {
    clear_has_event_name();
  }
  event_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_CustomGameEvent.event_name)
}

// optional bytes data = 2;
inline bool CUserMsg_CustomGameEvent::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMsg_CustomGameEvent::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMsg_CustomGameEvent::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMsg_CustomGameEvent::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CUserMsg_CustomGameEvent::data() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMsg_CustomGameEvent.data)
  return data_.GetNoArena();
}
inline void CUserMsg_CustomGameEvent::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMsg_CustomGameEvent.data)
}
#if LANG_CXX11
inline void CUserMsg_CustomGameEvent::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMsg_CustomGameEvent.data)
}
#endif
inline void CUserMsg_CustomGameEvent::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMsg_CustomGameEvent.data)
}
inline void CUserMsg_CustomGameEvent::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMsg_CustomGameEvent.data)
}
inline ::std::string* CUserMsg_CustomGameEvent::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMsg_CustomGameEvent.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMsg_CustomGameEvent::release_data() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMsg_CustomGameEvent.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMsg_CustomGameEvent::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMsg_CustomGameEvent.data)
}

// -------------------------------------------------------------------

// CUserMessageHapticPulse

// optional int32 hand_id = 1;
inline bool CUserMessageHapticPulse::has_hand_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageHapticPulse::set_has_hand_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageHapticPulse::clear_has_hand_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageHapticPulse::clear_hand_id() {
  hand_id_ = 0;
  clear_has_hand_id();
}
inline ::google::protobuf::int32 CUserMessageHapticPulse::hand_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHapticPulse.hand_id)
  return hand_id_;
}
inline void CUserMessageHapticPulse::set_hand_id(::google::protobuf::int32 value) {
  set_has_hand_id();
  hand_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHapticPulse.hand_id)
}

// optional .proto.dota.EHapticPulseType pulse_type = 2 [default = VR_HAND_HAPTIC_PULSE_LIGHT];
inline bool CUserMessageHapticPulse::has_pulse_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageHapticPulse::set_has_pulse_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageHapticPulse::clear_has_pulse_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageHapticPulse::clear_pulse_type() {
  pulse_type_ = 0;
  clear_has_pulse_type();
}
inline ::proto::dota::EHapticPulseType CUserMessageHapticPulse::pulse_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHapticPulse.pulse_type)
  return static_cast< ::proto::dota::EHapticPulseType >(pulse_type_);
}
inline void CUserMessageHapticPulse::set_pulse_type(::proto::dota::EHapticPulseType value) {
  assert(::proto::dota::EHapticPulseType_IsValid(value));
  set_has_pulse_type();
  pulse_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHapticPulse.pulse_type)
}

// -------------------------------------------------------------------

// CUserMessageHapticPulsePrecise

// optional int32 hand_id = 1;
inline bool CUserMessageHapticPulsePrecise::has_hand_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageHapticPulsePrecise::set_has_hand_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageHapticPulsePrecise::clear_has_hand_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageHapticPulsePrecise::clear_hand_id() {
  hand_id_ = 0;
  clear_has_hand_id();
}
inline ::google::protobuf::int32 CUserMessageHapticPulsePrecise::hand_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHapticPulsePrecise.hand_id)
  return hand_id_;
}
inline void CUserMessageHapticPulsePrecise::set_hand_id(::google::protobuf::int32 value) {
  set_has_hand_id();
  hand_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHapticPulsePrecise.hand_id)
}

// optional int32 pulse_duration = 2;
inline bool CUserMessageHapticPulsePrecise::has_pulse_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageHapticPulsePrecise::set_has_pulse_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageHapticPulsePrecise::clear_has_pulse_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageHapticPulsePrecise::clear_pulse_duration() {
  pulse_duration_ = 0;
  clear_has_pulse_duration();
}
inline ::google::protobuf::int32 CUserMessageHapticPulsePrecise::pulse_duration() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageHapticPulsePrecise.pulse_duration)
  return pulse_duration_;
}
inline void CUserMessageHapticPulsePrecise::set_pulse_duration(::google::protobuf::int32 value) {
  set_has_pulse_duration();
  pulse_duration_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageHapticPulsePrecise.pulse_duration)
}

// -------------------------------------------------------------------

// CUserMessageAnimStateGraphState

// optional int32 entity_index = 1;
inline bool CUserMessageAnimStateGraphState::has_entity_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserMessageAnimStateGraphState::set_has_entity_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserMessageAnimStateGraphState::clear_has_entity_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserMessageAnimStateGraphState::clear_entity_index() {
  entity_index_ = 0;
  clear_has_entity_index();
}
inline ::google::protobuf::int32 CUserMessageAnimStateGraphState::entity_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAnimStateGraphState.entity_index)
  return entity_index_;
}
inline void CUserMessageAnimStateGraphState::set_entity_index(::google::protobuf::int32 value) {
  set_has_entity_index();
  entity_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAnimStateGraphState.entity_index)
}

// optional bytes data = 2;
inline bool CUserMessageAnimStateGraphState::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserMessageAnimStateGraphState::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserMessageAnimStateGraphState::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserMessageAnimStateGraphState::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CUserMessageAnimStateGraphState::data() const {
  // @@protoc_insertion_point(field_get:proto.dota.CUserMessageAnimStateGraphState.data)
  return data_.GetNoArena();
}
inline void CUserMessageAnimStateGraphState::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CUserMessageAnimStateGraphState.data)
}
#if LANG_CXX11
inline void CUserMessageAnimStateGraphState::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CUserMessageAnimStateGraphState.data)
}
#endif
inline void CUserMessageAnimStateGraphState::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CUserMessageAnimStateGraphState.data)
}
inline void CUserMessageAnimStateGraphState::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CUserMessageAnimStateGraphState.data)
}
inline ::std::string* CUserMessageAnimStateGraphState::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:proto.dota.CUserMessageAnimStateGraphState.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CUserMessageAnimStateGraphState::release_data() {
  // @@protoc_insertion_point(field_release:proto.dota.CUserMessageAnimStateGraphState.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CUserMessageAnimStateGraphState::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CUserMessageAnimStateGraphState.data)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dota
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::dota::EBaseUserMessages> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::EBaseUserMessages>() {
  return ::proto::dota::EBaseUserMessages_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::EBaseEntityMessages> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::EBaseEntityMessages>() {
  return ::proto::dota::EBaseEntityMessages_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::eRollType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::eRollType>() {
  return ::proto::dota::eRollType_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::PARTICLE_MESSAGE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::PARTICLE_MESSAGE>() {
  return ::proto::dota::PARTICLE_MESSAGE_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::EHapticPulseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::EHapticPulseType>() {
  return ::proto::dota::EHapticPulseType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_usermessages_2eproto__INCLUDED
