// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: te.proto

#ifndef PROTOBUF_te_2eproto__INCLUDED
#define PROTOBUF_te_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networkbasetypes.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
namespace dota {
class CMsgEffectData;
class CMsgEffectDataDefaultTypeInternal;
extern CMsgEffectDataDefaultTypeInternal _CMsgEffectData_default_instance_;
class CMsgPlayerInfo;
class CMsgPlayerInfoDefaultTypeInternal;
extern CMsgPlayerInfoDefaultTypeInternal _CMsgPlayerInfo_default_instance_;
class CMsgQAngle;
class CMsgQAngleDefaultTypeInternal;
extern CMsgQAngleDefaultTypeInternal _CMsgQAngle_default_instance_;
class CMsgTEArmorRicochet;
class CMsgTEArmorRicochetDefaultTypeInternal;
extern CMsgTEArmorRicochetDefaultTypeInternal _CMsgTEArmorRicochet_default_instance_;
class CMsgTEBSPDecal;
class CMsgTEBSPDecalDefaultTypeInternal;
extern CMsgTEBSPDecalDefaultTypeInternal _CMsgTEBSPDecal_default_instance_;
class CMsgTEBaseBeam;
class CMsgTEBaseBeamDefaultTypeInternal;
extern CMsgTEBaseBeamDefaultTypeInternal _CMsgTEBaseBeam_default_instance_;
class CMsgTEBeamEntPoint;
class CMsgTEBeamEntPointDefaultTypeInternal;
extern CMsgTEBeamEntPointDefaultTypeInternal _CMsgTEBeamEntPoint_default_instance_;
class CMsgTEBeamEnts;
class CMsgTEBeamEntsDefaultTypeInternal;
extern CMsgTEBeamEntsDefaultTypeInternal _CMsgTEBeamEnts_default_instance_;
class CMsgTEBeamPoints;
class CMsgTEBeamPointsDefaultTypeInternal;
extern CMsgTEBeamPointsDefaultTypeInternal _CMsgTEBeamPoints_default_instance_;
class CMsgTEBeamRing;
class CMsgTEBeamRingDefaultTypeInternal;
extern CMsgTEBeamRingDefaultTypeInternal _CMsgTEBeamRing_default_instance_;
class CMsgTEBloodStream;
class CMsgTEBloodStreamDefaultTypeInternal;
extern CMsgTEBloodStreamDefaultTypeInternal _CMsgTEBloodStream_default_instance_;
class CMsgTEBreakModel;
class CMsgTEBreakModelDefaultTypeInternal;
extern CMsgTEBreakModelDefaultTypeInternal _CMsgTEBreakModel_default_instance_;
class CMsgTEBubbleTrail;
class CMsgTEBubbleTrailDefaultTypeInternal;
extern CMsgTEBubbleTrailDefaultTypeInternal _CMsgTEBubbleTrail_default_instance_;
class CMsgTEBubbles;
class CMsgTEBubblesDefaultTypeInternal;
extern CMsgTEBubblesDefaultTypeInternal _CMsgTEBubbles_default_instance_;
class CMsgTEDecal;
class CMsgTEDecalDefaultTypeInternal;
extern CMsgTEDecalDefaultTypeInternal _CMsgTEDecal_default_instance_;
class CMsgTEDust;
class CMsgTEDustDefaultTypeInternal;
extern CMsgTEDustDefaultTypeInternal _CMsgTEDust_default_instance_;
class CMsgTEEffectDispatch;
class CMsgTEEffectDispatchDefaultTypeInternal;
extern CMsgTEEffectDispatchDefaultTypeInternal _CMsgTEEffectDispatch_default_instance_;
class CMsgTEEnergySplash;
class CMsgTEEnergySplashDefaultTypeInternal;
extern CMsgTEEnergySplashDefaultTypeInternal _CMsgTEEnergySplash_default_instance_;
class CMsgTEExplosion;
class CMsgTEExplosionDefaultTypeInternal;
extern CMsgTEExplosionDefaultTypeInternal _CMsgTEExplosion_default_instance_;
class CMsgTEFizz;
class CMsgTEFizzDefaultTypeInternal;
extern CMsgTEFizzDefaultTypeInternal _CMsgTEFizz_default_instance_;
class CMsgTEGlowSprite;
class CMsgTEGlowSpriteDefaultTypeInternal;
extern CMsgTEGlowSpriteDefaultTypeInternal _CMsgTEGlowSprite_default_instance_;
class CMsgTEImpact;
class CMsgTEImpactDefaultTypeInternal;
extern CMsgTEImpactDefaultTypeInternal _CMsgTEImpact_default_instance_;
class CMsgTELargeFunnel;
class CMsgTELargeFunnelDefaultTypeInternal;
extern CMsgTELargeFunnelDefaultTypeInternal _CMsgTELargeFunnel_default_instance_;
class CMsgTEMuzzleFlash;
class CMsgTEMuzzleFlashDefaultTypeInternal;
extern CMsgTEMuzzleFlashDefaultTypeInternal _CMsgTEMuzzleFlash_default_instance_;
class CMsgTEPhysicsProp;
class CMsgTEPhysicsPropDefaultTypeInternal;
extern CMsgTEPhysicsPropDefaultTypeInternal _CMsgTEPhysicsProp_default_instance_;
class CMsgTEPlayerDecal;
class CMsgTEPlayerDecalDefaultTypeInternal;
extern CMsgTEPlayerDecalDefaultTypeInternal _CMsgTEPlayerDecal_default_instance_;
class CMsgTEProjectedDecal;
class CMsgTEProjectedDecalDefaultTypeInternal;
extern CMsgTEProjectedDecalDefaultTypeInternal _CMsgTEProjectedDecal_default_instance_;
class CMsgTEShatterSurface;
class CMsgTEShatterSurfaceDefaultTypeInternal;
extern CMsgTEShatterSurfaceDefaultTypeInternal _CMsgTEShatterSurface_default_instance_;
class CMsgTESmoke;
class CMsgTESmokeDefaultTypeInternal;
extern CMsgTESmokeDefaultTypeInternal _CMsgTESmoke_default_instance_;
class CMsgTESparks;
class CMsgTESparksDefaultTypeInternal;
extern CMsgTESparksDefaultTypeInternal _CMsgTESparks_default_instance_;
class CMsgTEWorldDecal;
class CMsgTEWorldDecalDefaultTypeInternal;
extern CMsgTEWorldDecalDefaultTypeInternal _CMsgTEWorldDecal_default_instance_;
class CMsgVector;
class CMsgVectorDefaultTypeInternal;
extern CMsgVectorDefaultTypeInternal _CMsgVector_default_instance_;
class CMsgVector2D;
class CMsgVector2DDefaultTypeInternal;
extern CMsgVector2DDefaultTypeInternal _CMsgVector2D_default_instance_;
class CMsg_CVars;
class CMsg_CVarsDefaultTypeInternal;
extern CMsg_CVarsDefaultTypeInternal _CMsg_CVars_default_instance_;
class CMsg_CVars_CVar;
class CMsg_CVars_CVarDefaultTypeInternal;
extern CMsg_CVars_CVarDefaultTypeInternal _CMsg_CVars_CVar_default_instance_;
class CNETMsg_Disconnect;
class CNETMsg_DisconnectDefaultTypeInternal;
extern CNETMsg_DisconnectDefaultTypeInternal _CNETMsg_Disconnect_default_instance_;
class CNETMsg_NOP;
class CNETMsg_NOPDefaultTypeInternal;
extern CNETMsg_NOPDefaultTypeInternal _CNETMsg_NOP_default_instance_;
class CNETMsg_SetConVar;
class CNETMsg_SetConVarDefaultTypeInternal;
extern CNETMsg_SetConVarDefaultTypeInternal _CNETMsg_SetConVar_default_instance_;
class CNETMsg_SignonState;
class CNETMsg_SignonStateDefaultTypeInternal;
extern CNETMsg_SignonStateDefaultTypeInternal _CNETMsg_SignonState_default_instance_;
class CNETMsg_SpawnGroup_Load;
class CNETMsg_SpawnGroup_LoadDefaultTypeInternal;
extern CNETMsg_SpawnGroup_LoadDefaultTypeInternal _CNETMsg_SpawnGroup_Load_default_instance_;
class CNETMsg_SpawnGroup_LoadCompleted;
class CNETMsg_SpawnGroup_LoadCompletedDefaultTypeInternal;
extern CNETMsg_SpawnGroup_LoadCompletedDefaultTypeInternal _CNETMsg_SpawnGroup_LoadCompleted_default_instance_;
class CNETMsg_SpawnGroup_ManifestUpdate;
class CNETMsg_SpawnGroup_ManifestUpdateDefaultTypeInternal;
extern CNETMsg_SpawnGroup_ManifestUpdateDefaultTypeInternal _CNETMsg_SpawnGroup_ManifestUpdate_default_instance_;
class CNETMsg_SpawnGroup_SetCreationTick;
class CNETMsg_SpawnGroup_SetCreationTickDefaultTypeInternal;
extern CNETMsg_SpawnGroup_SetCreationTickDefaultTypeInternal _CNETMsg_SpawnGroup_SetCreationTick_default_instance_;
class CNETMsg_SpawnGroup_Unload;
class CNETMsg_SpawnGroup_UnloadDefaultTypeInternal;
extern CNETMsg_SpawnGroup_UnloadDefaultTypeInternal _CNETMsg_SpawnGroup_Unload_default_instance_;
class CNETMsg_SplitScreenUser;
class CNETMsg_SplitScreenUserDefaultTypeInternal;
extern CNETMsg_SplitScreenUserDefaultTypeInternal _CNETMsg_SplitScreenUser_default_instance_;
class CNETMsg_StringCmd;
class CNETMsg_StringCmdDefaultTypeInternal;
extern CNETMsg_StringCmdDefaultTypeInternal _CNETMsg_StringCmd_default_instance_;
class CNETMsg_Tick;
class CNETMsg_TickDefaultTypeInternal;
extern CNETMsg_TickDefaultTypeInternal _CNETMsg_Tick_default_instance_;
class CSVCMsgList_GameEvents;
class CSVCMsgList_GameEventsDefaultTypeInternal;
extern CSVCMsgList_GameEventsDefaultTypeInternal _CSVCMsgList_GameEvents_default_instance_;
class CSVCMsgList_GameEvents_event_t;
class CSVCMsgList_GameEvents_event_tDefaultTypeInternal;
extern CSVCMsgList_GameEvents_event_tDefaultTypeInternal _CSVCMsgList_GameEvents_event_t_default_instance_;
class CSVCMsgList_UserMessages;
class CSVCMsgList_UserMessagesDefaultTypeInternal;
extern CSVCMsgList_UserMessagesDefaultTypeInternal _CSVCMsgList_UserMessages_default_instance_;
class CSVCMsgList_UserMessages_usermsg_t;
class CSVCMsgList_UserMessages_usermsg_tDefaultTypeInternal;
extern CSVCMsgList_UserMessages_usermsg_tDefaultTypeInternal _CSVCMsgList_UserMessages_usermsg_t_default_instance_;
class CSVCMsg_GameEvent;
class CSVCMsg_GameEventDefaultTypeInternal;
extern CSVCMsg_GameEventDefaultTypeInternal _CSVCMsg_GameEvent_default_instance_;
class CSVCMsg_GameEvent_key_t;
class CSVCMsg_GameEvent_key_tDefaultTypeInternal;
extern CSVCMsg_GameEvent_key_tDefaultTypeInternal _CSVCMsg_GameEvent_key_t_default_instance_;
class CSVCMsg_GameSessionConfiguration;
class CSVCMsg_GameSessionConfigurationDefaultTypeInternal;
extern CSVCMsg_GameSessionConfigurationDefaultTypeInternal _CSVCMsg_GameSessionConfiguration_default_instance_;
class CSVCMsg_UserMessage;
class CSVCMsg_UserMessageDefaultTypeInternal;
extern CSVCMsg_UserMessageDefaultTypeInternal _CSVCMsg_UserMessage_default_instance_;
}  // namespace dota
}  // namespace proto

namespace proto {
namespace dota {

namespace protobuf_te_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_te_2eproto

enum ETEProtobufIds {
  TE_EffectDispatchId = 400,
  TE_ArmorRicochetId = 401,
  TE_BeamEntPointId = 402,
  TE_BeamEntsId = 403,
  TE_BeamPointsId = 404,
  TE_BeamRingId = 405,
  TE_BreakModelId = 406,
  TE_BSPDecalId = 407,
  TE_BubblesId = 408,
  TE_BubbleTrailId = 409,
  TE_DecalId = 410,
  TE_WorldDecalId = 411,
  TE_EnergySplashId = 412,
  TE_FizzId = 413,
  TE_ShatterSurfaceId = 414,
  TE_GlowSpriteId = 415,
  TE_ImpactId = 416,
  TE_MuzzleFlashId = 417,
  TE_BloodStreamId = 418,
  TE_ExplosionId = 419,
  TE_DustId = 420,
  TE_LargeFunnelId = 421,
  TE_SparksId = 422,
  TE_PhysicsPropId = 423,
  TE_PlayerDecalId = 424,
  TE_ProjectedDecalId = 425,
  TE_SmokeId = 426
};
bool ETEProtobufIds_IsValid(int value);
const ETEProtobufIds ETEProtobufIds_MIN = TE_EffectDispatchId;
const ETEProtobufIds ETEProtobufIds_MAX = TE_SmokeId;
const int ETEProtobufIds_ARRAYSIZE = ETEProtobufIds_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETEProtobufIds_descriptor();
inline const ::std::string& ETEProtobufIds_Name(ETEProtobufIds value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETEProtobufIds_descriptor(), value);
}
inline bool ETEProtobufIds_Parse(
    const ::std::string& name, ETEProtobufIds* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETEProtobufIds>(
    ETEProtobufIds_descriptor(), name, value);
}
// ===================================================================

class CMsgTEArmorRicochet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEArmorRicochet) */ {
 public:
  CMsgTEArmorRicochet();
  virtual ~CMsgTEArmorRicochet();

  CMsgTEArmorRicochet(const CMsgTEArmorRicochet& from);

  inline CMsgTEArmorRicochet& operator=(const CMsgTEArmorRicochet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEArmorRicochet& default_instance();

  static inline const CMsgTEArmorRicochet* internal_default_instance() {
    return reinterpret_cast<const CMsgTEArmorRicochet*>(
               &_CMsgTEArmorRicochet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CMsgTEArmorRicochet* other);

  // implements Message ----------------------------------------------

  inline CMsgTEArmorRicochet* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEArmorRicochet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEArmorRicochet& from);
  void MergeFrom(const CMsgTEArmorRicochet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEArmorRicochet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::proto::dota::CMsgVector& pos() const;
  ::proto::dota::CMsgVector* mutable_pos();
  ::proto::dota::CMsgVector* release_pos();
  void set_allocated_pos(::proto::dota::CMsgVector* pos);

  // optional .proto.dota.CMsgVector dir = 2;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 2;
  const ::proto::dota::CMsgVector& dir() const;
  ::proto::dota::CMsgVector* mutable_dir();
  ::proto::dota::CMsgVector* release_dir();
  void set_allocated_dir(::proto::dota::CMsgVector* dir);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEArmorRicochet)
 private:
  void set_has_pos();
  void clear_has_pos();
  void set_has_dir();
  void clear_has_dir();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* pos_;
  ::proto::dota::CMsgVector* dir_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBaseBeam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBaseBeam) */ {
 public:
  CMsgTEBaseBeam();
  virtual ~CMsgTEBaseBeam();

  CMsgTEBaseBeam(const CMsgTEBaseBeam& from);

  inline CMsgTEBaseBeam& operator=(const CMsgTEBaseBeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBaseBeam& default_instance();

  static inline const CMsgTEBaseBeam* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBaseBeam*>(
               &_CMsgTEBaseBeam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CMsgTEBaseBeam* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBaseBeam* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBaseBeam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBaseBeam& from);
  void MergeFrom(const CMsgTEBaseBeam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBaseBeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 modelindex = 1;
  bool has_modelindex() const;
  void clear_modelindex();
  static const int kModelindexFieldNumber = 1;
  ::google::protobuf::uint64 modelindex() const;
  void set_modelindex(::google::protobuf::uint64 value);

  // optional fixed64 haloindex = 2;
  bool has_haloindex() const;
  void clear_haloindex();
  static const int kHaloindexFieldNumber = 2;
  ::google::protobuf::uint64 haloindex() const;
  void set_haloindex(::google::protobuf::uint64 value);

  // optional uint32 startframe = 3;
  bool has_startframe() const;
  void clear_startframe();
  static const int kStartframeFieldNumber = 3;
  ::google::protobuf::uint32 startframe() const;
  void set_startframe(::google::protobuf::uint32 value);

  // optional uint32 framerate = 4;
  bool has_framerate() const;
  void clear_framerate();
  static const int kFramerateFieldNumber = 4;
  ::google::protobuf::uint32 framerate() const;
  void set_framerate(::google::protobuf::uint32 value);

  // optional float life = 5;
  bool has_life() const;
  void clear_life();
  static const int kLifeFieldNumber = 5;
  float life() const;
  void set_life(float value);

  // optional float width = 6;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 6;
  float width() const;
  void set_width(float value);

  // optional float endwidth = 7;
  bool has_endwidth() const;
  void clear_endwidth();
  static const int kEndwidthFieldNumber = 7;
  float endwidth() const;
  void set_endwidth(float value);

  // optional uint32 fadelength = 8;
  bool has_fadelength() const;
  void clear_fadelength();
  static const int kFadelengthFieldNumber = 8;
  ::google::protobuf::uint32 fadelength() const;
  void set_fadelength(::google::protobuf::uint32 value);

  // optional float amplitude = 9;
  bool has_amplitude() const;
  void clear_amplitude();
  static const int kAmplitudeFieldNumber = 9;
  float amplitude() const;
  void set_amplitude(float value);

  // optional fixed32 color = 10;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 10;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // optional uint32 speed = 11;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 11;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // optional uint32 flags = 12;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 12;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBaseBeam)
 private:
  void set_has_modelindex();
  void clear_has_modelindex();
  void set_has_haloindex();
  void clear_has_haloindex();
  void set_has_startframe();
  void clear_has_startframe();
  void set_has_framerate();
  void clear_has_framerate();
  void set_has_life();
  void clear_has_life();
  void set_has_width();
  void clear_has_width();
  void set_has_endwidth();
  void clear_has_endwidth();
  void set_has_fadelength();
  void clear_has_fadelength();
  void set_has_amplitude();
  void clear_has_amplitude();
  void set_has_color();
  void clear_has_color();
  void set_has_speed();
  void clear_has_speed();
  void set_has_flags();
  void clear_has_flags();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 modelindex_;
  ::google::protobuf::uint64 haloindex_;
  ::google::protobuf::uint32 startframe_;
  ::google::protobuf::uint32 framerate_;
  float life_;
  float width_;
  float endwidth_;
  ::google::protobuf::uint32 fadelength_;
  float amplitude_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 speed_;
  ::google::protobuf::uint32 flags_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBeamEntPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBeamEntPoint) */ {
 public:
  CMsgTEBeamEntPoint();
  virtual ~CMsgTEBeamEntPoint();

  CMsgTEBeamEntPoint(const CMsgTEBeamEntPoint& from);

  inline CMsgTEBeamEntPoint& operator=(const CMsgTEBeamEntPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBeamEntPoint& default_instance();

  static inline const CMsgTEBeamEntPoint* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBeamEntPoint*>(
               &_CMsgTEBeamEntPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CMsgTEBeamEntPoint* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBeamEntPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBeamEntPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBeamEntPoint& from);
  void MergeFrom(const CMsgTEBeamEntPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBeamEntPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::proto::dota::CMsgTEBaseBeam& base() const;
  ::proto::dota::CMsgTEBaseBeam* mutable_base();
  ::proto::dota::CMsgTEBaseBeam* release_base();
  void set_allocated_base(::proto::dota::CMsgTEBaseBeam* base);

  // optional .proto.dota.CMsgVector start = 4;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 4;
  const ::proto::dota::CMsgVector& start() const;
  ::proto::dota::CMsgVector* mutable_start();
  ::proto::dota::CMsgVector* release_start();
  void set_allocated_start(::proto::dota::CMsgVector* start);

  // optional .proto.dota.CMsgVector end = 5;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 5;
  const ::proto::dota::CMsgVector& end() const;
  ::proto::dota::CMsgVector* mutable_end();
  ::proto::dota::CMsgVector* release_end();
  void set_allocated_end(::proto::dota::CMsgVector* end);

  // optional uint32 startentity = 2;
  bool has_startentity() const;
  void clear_startentity();
  static const int kStartentityFieldNumber = 2;
  ::google::protobuf::uint32 startentity() const;
  void set_startentity(::google::protobuf::uint32 value);

  // optional uint32 endentity = 3;
  bool has_endentity() const;
  void clear_endentity();
  static const int kEndentityFieldNumber = 3;
  ::google::protobuf::uint32 endentity() const;
  void set_endentity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBeamEntPoint)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_startentity();
  void clear_has_startentity();
  void set_has_endentity();
  void clear_has_endentity();
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgTEBaseBeam* base_;
  ::proto::dota::CMsgVector* start_;
  ::proto::dota::CMsgVector* end_;
  ::google::protobuf::uint32 startentity_;
  ::google::protobuf::uint32 endentity_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBeamEnts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBeamEnts) */ {
 public:
  CMsgTEBeamEnts();
  virtual ~CMsgTEBeamEnts();

  CMsgTEBeamEnts(const CMsgTEBeamEnts& from);

  inline CMsgTEBeamEnts& operator=(const CMsgTEBeamEnts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBeamEnts& default_instance();

  static inline const CMsgTEBeamEnts* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBeamEnts*>(
               &_CMsgTEBeamEnts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CMsgTEBeamEnts* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBeamEnts* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBeamEnts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBeamEnts& from);
  void MergeFrom(const CMsgTEBeamEnts& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBeamEnts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::proto::dota::CMsgTEBaseBeam& base() const;
  ::proto::dota::CMsgTEBaseBeam* mutable_base();
  ::proto::dota::CMsgTEBaseBeam* release_base();
  void set_allocated_base(::proto::dota::CMsgTEBaseBeam* base);

  // optional uint32 startentity = 2;
  bool has_startentity() const;
  void clear_startentity();
  static const int kStartentityFieldNumber = 2;
  ::google::protobuf::uint32 startentity() const;
  void set_startentity(::google::protobuf::uint32 value);

  // optional uint32 endentity = 3;
  bool has_endentity() const;
  void clear_endentity();
  static const int kEndentityFieldNumber = 3;
  ::google::protobuf::uint32 endentity() const;
  void set_endentity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBeamEnts)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_startentity();
  void clear_has_startentity();
  void set_has_endentity();
  void clear_has_endentity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgTEBaseBeam* base_;
  ::google::protobuf::uint32 startentity_;
  ::google::protobuf::uint32 endentity_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBeamPoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBeamPoints) */ {
 public:
  CMsgTEBeamPoints();
  virtual ~CMsgTEBeamPoints();

  CMsgTEBeamPoints(const CMsgTEBeamPoints& from);

  inline CMsgTEBeamPoints& operator=(const CMsgTEBeamPoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBeamPoints& default_instance();

  static inline const CMsgTEBeamPoints* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBeamPoints*>(
               &_CMsgTEBeamPoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CMsgTEBeamPoints* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBeamPoints* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBeamPoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBeamPoints& from);
  void MergeFrom(const CMsgTEBeamPoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBeamPoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::proto::dota::CMsgTEBaseBeam& base() const;
  ::proto::dota::CMsgTEBaseBeam* mutable_base();
  ::proto::dota::CMsgTEBaseBeam* release_base();
  void set_allocated_base(::proto::dota::CMsgTEBaseBeam* base);

  // optional .proto.dota.CMsgVector start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::proto::dota::CMsgVector& start() const;
  ::proto::dota::CMsgVector* mutable_start();
  ::proto::dota::CMsgVector* release_start();
  void set_allocated_start(::proto::dota::CMsgVector* start);

  // optional .proto.dota.CMsgVector end = 3;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 3;
  const ::proto::dota::CMsgVector& end() const;
  ::proto::dota::CMsgVector* mutable_end();
  ::proto::dota::CMsgVector* release_end();
  void set_allocated_end(::proto::dota::CMsgVector* end);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBeamPoints)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgTEBaseBeam* base_;
  ::proto::dota::CMsgVector* start_;
  ::proto::dota::CMsgVector* end_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBeamRing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBeamRing) */ {
 public:
  CMsgTEBeamRing();
  virtual ~CMsgTEBeamRing();

  CMsgTEBeamRing(const CMsgTEBeamRing& from);

  inline CMsgTEBeamRing& operator=(const CMsgTEBeamRing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBeamRing& default_instance();

  static inline const CMsgTEBeamRing* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBeamRing*>(
               &_CMsgTEBeamRing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CMsgTEBeamRing* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBeamRing* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBeamRing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBeamRing& from);
  void MergeFrom(const CMsgTEBeamRing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBeamRing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::proto::dota::CMsgTEBaseBeam& base() const;
  ::proto::dota::CMsgTEBaseBeam* mutable_base();
  ::proto::dota::CMsgTEBaseBeam* release_base();
  void set_allocated_base(::proto::dota::CMsgTEBaseBeam* base);

  // optional uint32 startentity = 2;
  bool has_startentity() const;
  void clear_startentity();
  static const int kStartentityFieldNumber = 2;
  ::google::protobuf::uint32 startentity() const;
  void set_startentity(::google::protobuf::uint32 value);

  // optional uint32 endentity = 3;
  bool has_endentity() const;
  void clear_endentity();
  static const int kEndentityFieldNumber = 3;
  ::google::protobuf::uint32 endentity() const;
  void set_endentity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBeamRing)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_startentity();
  void clear_has_startentity();
  void set_has_endentity();
  void clear_has_endentity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgTEBaseBeam* base_;
  ::google::protobuf::uint32 startentity_;
  ::google::protobuf::uint32 endentity_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBreakModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBreakModel) */ {
 public:
  CMsgTEBreakModel();
  virtual ~CMsgTEBreakModel();

  CMsgTEBreakModel(const CMsgTEBreakModel& from);

  inline CMsgTEBreakModel& operator=(const CMsgTEBreakModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBreakModel& default_instance();

  static inline const CMsgTEBreakModel* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBreakModel*>(
               &_CMsgTEBreakModel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CMsgTEBreakModel* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBreakModel* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBreakModel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBreakModel& from);
  void MergeFrom(const CMsgTEBreakModel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBreakModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgQAngle angles = 2;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 2;
  const ::proto::dota::CMsgQAngle& angles() const;
  ::proto::dota::CMsgQAngle* mutable_angles();
  ::proto::dota::CMsgQAngle* release_angles();
  void set_allocated_angles(::proto::dota::CMsgQAngle* angles);

  // optional .proto.dota.CMsgVector size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  const ::proto::dota::CMsgVector& size() const;
  ::proto::dota::CMsgVector* mutable_size();
  ::proto::dota::CMsgVector* release_size();
  void set_allocated_size(::proto::dota::CMsgVector* size);

  // optional .proto.dota.CMsgVector velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  const ::proto::dota::CMsgVector& velocity() const;
  ::proto::dota::CMsgVector* mutable_velocity();
  ::proto::dota::CMsgVector* release_velocity();
  void set_allocated_velocity(::proto::dota::CMsgVector* velocity);

  // optional fixed64 modelindex = 6;
  bool has_modelindex() const;
  void clear_modelindex();
  static const int kModelindexFieldNumber = 6;
  ::google::protobuf::uint64 modelindex() const;
  void set_modelindex(::google::protobuf::uint64 value);

  // optional uint32 randomization = 5;
  bool has_randomization() const;
  void clear_randomization();
  static const int kRandomizationFieldNumber = 5;
  ::google::protobuf::uint32 randomization() const;
  void set_randomization(::google::protobuf::uint32 value);

  // optional uint32 count = 7;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 7;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional float time = 8;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 8;
  float time() const;
  void set_time(float value);

  // optional uint32 flags = 9;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 9;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBreakModel)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_angles();
  void clear_has_angles();
  void set_has_size();
  void clear_has_size();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_randomization();
  void clear_has_randomization();
  void set_has_modelindex();
  void clear_has_modelindex();
  void set_has_count();
  void clear_has_count();
  void set_has_time();
  void clear_has_time();
  void set_has_flags();
  void clear_has_flags();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgQAngle* angles_;
  ::proto::dota::CMsgVector* size_;
  ::proto::dota::CMsgVector* velocity_;
  ::google::protobuf::uint64 modelindex_;
  ::google::protobuf::uint32 randomization_;
  ::google::protobuf::uint32 count_;
  float time_;
  ::google::protobuf::uint32 flags_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBSPDecal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBSPDecal) */ {
 public:
  CMsgTEBSPDecal();
  virtual ~CMsgTEBSPDecal();

  CMsgTEBSPDecal(const CMsgTEBSPDecal& from);

  inline CMsgTEBSPDecal& operator=(const CMsgTEBSPDecal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBSPDecal& default_instance();

  static inline const CMsgTEBSPDecal* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBSPDecal*>(
               &_CMsgTEBSPDecal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(CMsgTEBSPDecal* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBSPDecal* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBSPDecal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBSPDecal& from);
  void MergeFrom(const CMsgTEBSPDecal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBSPDecal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector normal = 2;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 2;
  const ::proto::dota::CMsgVector& normal() const;
  ::proto::dota::CMsgVector* mutable_normal();
  ::proto::dota::CMsgVector* release_normal();
  void set_allocated_normal(::proto::dota::CMsgVector* normal);

  // optional .proto.dota.CMsgVector saxis = 3;
  bool has_saxis() const;
  void clear_saxis();
  static const int kSaxisFieldNumber = 3;
  const ::proto::dota::CMsgVector& saxis() const;
  ::proto::dota::CMsgVector* mutable_saxis();
  ::proto::dota::CMsgVector* release_saxis();
  void set_allocated_saxis(::proto::dota::CMsgVector* saxis);

  // optional uint32 entity = 4;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 4;
  ::google::protobuf::uint32 entity() const;
  void set_entity(::google::protobuf::uint32 value);

  // optional uint32 index = 5;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBSPDecal)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_normal();
  void clear_has_normal();
  void set_has_saxis();
  void clear_has_saxis();
  void set_has_entity();
  void clear_has_entity();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* normal_;
  ::proto::dota::CMsgVector* saxis_;
  ::google::protobuf::uint32 entity_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBubbles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBubbles) */ {
 public:
  CMsgTEBubbles();
  virtual ~CMsgTEBubbles();

  CMsgTEBubbles(const CMsgTEBubbles& from);

  inline CMsgTEBubbles& operator=(const CMsgTEBubbles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBubbles& default_instance();

  static inline const CMsgTEBubbles* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBubbles*>(
               &_CMsgTEBubbles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CMsgTEBubbles* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBubbles* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBubbles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBubbles& from);
  void MergeFrom(const CMsgTEBubbles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBubbles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector mins = 1;
  bool has_mins() const;
  void clear_mins();
  static const int kMinsFieldNumber = 1;
  const ::proto::dota::CMsgVector& mins() const;
  ::proto::dota::CMsgVector* mutable_mins();
  ::proto::dota::CMsgVector* release_mins();
  void set_allocated_mins(::proto::dota::CMsgVector* mins);

  // optional .proto.dota.CMsgVector maxs = 2;
  bool has_maxs() const;
  void clear_maxs();
  static const int kMaxsFieldNumber = 2;
  const ::proto::dota::CMsgVector& maxs() const;
  ::proto::dota::CMsgVector* mutable_maxs();
  ::proto::dota::CMsgVector* release_maxs();
  void set_allocated_maxs(::proto::dota::CMsgVector* maxs);

  // optional float height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  float height() const;
  void set_height(float value);

  // optional uint32 count = 4;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 4;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional float speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBubbles)
 private:
  void set_has_mins();
  void clear_has_mins();
  void set_has_maxs();
  void clear_has_maxs();
  void set_has_height();
  void clear_has_height();
  void set_has_count();
  void clear_has_count();
  void set_has_speed();
  void clear_has_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* mins_;
  ::proto::dota::CMsgVector* maxs_;
  float height_;
  ::google::protobuf::uint32 count_;
  float speed_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBubbleTrail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBubbleTrail) */ {
 public:
  CMsgTEBubbleTrail();
  virtual ~CMsgTEBubbleTrail();

  CMsgTEBubbleTrail(const CMsgTEBubbleTrail& from);

  inline CMsgTEBubbleTrail& operator=(const CMsgTEBubbleTrail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBubbleTrail& default_instance();

  static inline const CMsgTEBubbleTrail* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBubbleTrail*>(
               &_CMsgTEBubbleTrail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CMsgTEBubbleTrail* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBubbleTrail* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBubbleTrail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBubbleTrail& from);
  void MergeFrom(const CMsgTEBubbleTrail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBubbleTrail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector mins = 1;
  bool has_mins() const;
  void clear_mins();
  static const int kMinsFieldNumber = 1;
  const ::proto::dota::CMsgVector& mins() const;
  ::proto::dota::CMsgVector* mutable_mins();
  ::proto::dota::CMsgVector* release_mins();
  void set_allocated_mins(::proto::dota::CMsgVector* mins);

  // optional .proto.dota.CMsgVector maxs = 2;
  bool has_maxs() const;
  void clear_maxs();
  static const int kMaxsFieldNumber = 2;
  const ::proto::dota::CMsgVector& maxs() const;
  ::proto::dota::CMsgVector* mutable_maxs();
  ::proto::dota::CMsgVector* release_maxs();
  void set_allocated_maxs(::proto::dota::CMsgVector* maxs);

  // optional float waterz = 3;
  bool has_waterz() const;
  void clear_waterz();
  static const int kWaterzFieldNumber = 3;
  float waterz() const;
  void set_waterz(float value);

  // optional uint32 count = 4;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 4;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional float speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBubbleTrail)
 private:
  void set_has_mins();
  void clear_has_mins();
  void set_has_maxs();
  void clear_has_maxs();
  void set_has_waterz();
  void clear_has_waterz();
  void set_has_count();
  void clear_has_count();
  void set_has_speed();
  void clear_has_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* mins_;
  ::proto::dota::CMsgVector* maxs_;
  float waterz_;
  ::google::protobuf::uint32 count_;
  float speed_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEDecal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEDecal) */ {
 public:
  CMsgTEDecal();
  virtual ~CMsgTEDecal();

  CMsgTEDecal(const CMsgTEDecal& from);

  inline CMsgTEDecal& operator=(const CMsgTEDecal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEDecal& default_instance();

  static inline const CMsgTEDecal* internal_default_instance() {
    return reinterpret_cast<const CMsgTEDecal*>(
               &_CMsgTEDecal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(CMsgTEDecal* other);

  // implements Message ----------------------------------------------

  inline CMsgTEDecal* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEDecal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEDecal& from);
  void MergeFrom(const CMsgTEDecal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEDecal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::proto::dota::CMsgVector& start() const;
  ::proto::dota::CMsgVector* mutable_start();
  ::proto::dota::CMsgVector* release_start();
  void set_allocated_start(::proto::dota::CMsgVector* start);

  // optional uint32 entity = 3;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 3;
  ::google::protobuf::uint32 entity() const;
  void set_entity(::google::protobuf::uint32 value);

  // optional uint32 hitbox = 4;
  bool has_hitbox() const;
  void clear_hitbox();
  static const int kHitboxFieldNumber = 4;
  ::google::protobuf::uint32 hitbox() const;
  void set_hitbox(::google::protobuf::uint32 value);

  // optional uint32 index = 5;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEDecal)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_start();
  void clear_has_start();
  void set_has_entity();
  void clear_has_entity();
  void set_has_hitbox();
  void clear_has_hitbox();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* start_;
  ::google::protobuf::uint32 entity_;
  ::google::protobuf::uint32 hitbox_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgEffectData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgEffectData) */ {
 public:
  CMsgEffectData();
  virtual ~CMsgEffectData();

  CMsgEffectData(const CMsgEffectData& from);

  inline CMsgEffectData& operator=(const CMsgEffectData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgEffectData& default_instance();

  static inline const CMsgEffectData* internal_default_instance() {
    return reinterpret_cast<const CMsgEffectData*>(
               &_CMsgEffectData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CMsgEffectData* other);

  // implements Message ----------------------------------------------

  inline CMsgEffectData* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgEffectData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgEffectData& from);
  void MergeFrom(const CMsgEffectData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgEffectData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::proto::dota::CMsgVector& start() const;
  ::proto::dota::CMsgVector* mutable_start();
  ::proto::dota::CMsgVector* release_start();
  void set_allocated_start(::proto::dota::CMsgVector* start);

  // optional .proto.dota.CMsgVector normal = 3;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 3;
  const ::proto::dota::CMsgVector& normal() const;
  ::proto::dota::CMsgVector* mutable_normal();
  ::proto::dota::CMsgVector* release_normal();
  void set_allocated_normal(::proto::dota::CMsgVector* normal);

  // optional .proto.dota.CMsgQAngle angles = 4;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 4;
  const ::proto::dota::CMsgQAngle& angles() const;
  ::proto::dota::CMsgQAngle* mutable_angles();
  ::proto::dota::CMsgQAngle* release_angles();
  void set_allocated_angles(::proto::dota::CMsgQAngle* angles);

  // optional fixed32 entity = 5;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 5;
  ::google::protobuf::uint32 entity() const;
  void set_entity(::google::protobuf::uint32 value);

  // optional fixed32 otherentity = 6;
  bool has_otherentity() const;
  void clear_otherentity();
  static const int kOtherentityFieldNumber = 6;
  ::google::protobuf::uint32 otherentity() const;
  void set_otherentity(::google::protobuf::uint32 value);

  // optional float scale = 7;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 7;
  float scale() const;
  void set_scale(float value);

  // optional float magnitude = 8;
  bool has_magnitude() const;
  void clear_magnitude();
  static const int kMagnitudeFieldNumber = 8;
  float magnitude() const;
  void set_magnitude(float value);

  // optional float radius = 9;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 9;
  float radius() const;
  void set_radius(float value);

  // optional fixed32 surfaceprop = 10;
  bool has_surfaceprop() const;
  void clear_surfaceprop();
  static const int kSurfacepropFieldNumber = 10;
  ::google::protobuf::uint32 surfaceprop() const;
  void set_surfaceprop(::google::protobuf::uint32 value);

  // optional fixed64 effectindex = 11;
  bool has_effectindex() const;
  void clear_effectindex();
  static const int kEffectindexFieldNumber = 11;
  ::google::protobuf::uint64 effectindex() const;
  void set_effectindex(::google::protobuf::uint64 value);

  // optional uint32 damagetype = 12;
  bool has_damagetype() const;
  void clear_damagetype();
  static const int kDamagetypeFieldNumber = 12;
  ::google::protobuf::uint32 damagetype() const;
  void set_damagetype(::google::protobuf::uint32 value);

  // optional uint32 material = 13;
  bool has_material() const;
  void clear_material();
  static const int kMaterialFieldNumber = 13;
  ::google::protobuf::uint32 material() const;
  void set_material(::google::protobuf::uint32 value);

  // optional uint32 hitbox = 14;
  bool has_hitbox() const;
  void clear_hitbox();
  static const int kHitboxFieldNumber = 14;
  ::google::protobuf::uint32 hitbox() const;
  void set_hitbox(::google::protobuf::uint32 value);

  // optional uint32 color = 15;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 15;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // optional uint32 flags = 16;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 16;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional int32 attachmentindex = 17;
  bool has_attachmentindex() const;
  void clear_attachmentindex();
  static const int kAttachmentindexFieldNumber = 17;
  ::google::protobuf::int32 attachmentindex() const;
  void set_attachmentindex(::google::protobuf::int32 value);

  // optional uint32 effectname = 18;
  bool has_effectname() const;
  void clear_effectname();
  static const int kEffectnameFieldNumber = 18;
  ::google::protobuf::uint32 effectname() const;
  void set_effectname(::google::protobuf::uint32 value);

  // optional uint32 attachmentname = 19;
  bool has_attachmentname() const;
  void clear_attachmentname();
  static const int kAttachmentnameFieldNumber = 19;
  ::google::protobuf::uint32 attachmentname() const;
  void set_attachmentname(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgEffectData)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_start();
  void clear_has_start();
  void set_has_normal();
  void clear_has_normal();
  void set_has_angles();
  void clear_has_angles();
  void set_has_entity();
  void clear_has_entity();
  void set_has_otherentity();
  void clear_has_otherentity();
  void set_has_scale();
  void clear_has_scale();
  void set_has_magnitude();
  void clear_has_magnitude();
  void set_has_radius();
  void clear_has_radius();
  void set_has_surfaceprop();
  void clear_has_surfaceprop();
  void set_has_effectindex();
  void clear_has_effectindex();
  void set_has_damagetype();
  void clear_has_damagetype();
  void set_has_material();
  void clear_has_material();
  void set_has_hitbox();
  void clear_has_hitbox();
  void set_has_color();
  void clear_has_color();
  void set_has_flags();
  void clear_has_flags();
  void set_has_attachmentindex();
  void clear_has_attachmentindex();
  void set_has_effectname();
  void clear_has_effectname();
  void set_has_attachmentname();
  void clear_has_attachmentname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* start_;
  ::proto::dota::CMsgVector* normal_;
  ::proto::dota::CMsgQAngle* angles_;
  ::google::protobuf::uint32 entity_;
  ::google::protobuf::uint32 otherentity_;
  float scale_;
  float magnitude_;
  float radius_;
  ::google::protobuf::uint32 surfaceprop_;
  ::google::protobuf::uint64 effectindex_;
  ::google::protobuf::uint32 damagetype_;
  ::google::protobuf::uint32 material_;
  ::google::protobuf::uint32 hitbox_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::int32 attachmentindex_;
  ::google::protobuf::uint32 effectname_;
  ::google::protobuf::uint32 attachmentname_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEEffectDispatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEEffectDispatch) */ {
 public:
  CMsgTEEffectDispatch();
  virtual ~CMsgTEEffectDispatch();

  CMsgTEEffectDispatch(const CMsgTEEffectDispatch& from);

  inline CMsgTEEffectDispatch& operator=(const CMsgTEEffectDispatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEEffectDispatch& default_instance();

  static inline const CMsgTEEffectDispatch* internal_default_instance() {
    return reinterpret_cast<const CMsgTEEffectDispatch*>(
               &_CMsgTEEffectDispatch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CMsgTEEffectDispatch* other);

  // implements Message ----------------------------------------------

  inline CMsgTEEffectDispatch* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEEffectDispatch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEEffectDispatch& from);
  void MergeFrom(const CMsgTEEffectDispatch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEEffectDispatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgEffectData effectdata = 1;
  bool has_effectdata() const;
  void clear_effectdata();
  static const int kEffectdataFieldNumber = 1;
  const ::proto::dota::CMsgEffectData& effectdata() const;
  ::proto::dota::CMsgEffectData* mutable_effectdata();
  ::proto::dota::CMsgEffectData* release_effectdata();
  void set_allocated_effectdata(::proto::dota::CMsgEffectData* effectdata);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEEffectDispatch)
 private:
  void set_has_effectdata();
  void clear_has_effectdata();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgEffectData* effectdata_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEEnergySplash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEEnergySplash) */ {
 public:
  CMsgTEEnergySplash();
  virtual ~CMsgTEEnergySplash();

  CMsgTEEnergySplash(const CMsgTEEnergySplash& from);

  inline CMsgTEEnergySplash& operator=(const CMsgTEEnergySplash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEEnergySplash& default_instance();

  static inline const CMsgTEEnergySplash* internal_default_instance() {
    return reinterpret_cast<const CMsgTEEnergySplash*>(
               &_CMsgTEEnergySplash_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(CMsgTEEnergySplash* other);

  // implements Message ----------------------------------------------

  inline CMsgTEEnergySplash* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEEnergySplash* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEEnergySplash& from);
  void MergeFrom(const CMsgTEEnergySplash& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEEnergySplash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::proto::dota::CMsgVector& pos() const;
  ::proto::dota::CMsgVector* mutable_pos();
  ::proto::dota::CMsgVector* release_pos();
  void set_allocated_pos(::proto::dota::CMsgVector* pos);

  // optional .proto.dota.CMsgVector dir = 2;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 2;
  const ::proto::dota::CMsgVector& dir() const;
  ::proto::dota::CMsgVector* mutable_dir();
  ::proto::dota::CMsgVector* release_dir();
  void set_allocated_dir(::proto::dota::CMsgVector* dir);

  // optional bool explosive = 3;
  bool has_explosive() const;
  void clear_explosive();
  static const int kExplosiveFieldNumber = 3;
  bool explosive() const;
  void set_explosive(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEEnergySplash)
 private:
  void set_has_pos();
  void clear_has_pos();
  void set_has_dir();
  void clear_has_dir();
  void set_has_explosive();
  void clear_has_explosive();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* pos_;
  ::proto::dota::CMsgVector* dir_;
  bool explosive_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEFizz : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEFizz) */ {
 public:
  CMsgTEFizz();
  virtual ~CMsgTEFizz();

  CMsgTEFizz(const CMsgTEFizz& from);

  inline CMsgTEFizz& operator=(const CMsgTEFizz& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEFizz& default_instance();

  static inline const CMsgTEFizz* internal_default_instance() {
    return reinterpret_cast<const CMsgTEFizz*>(
               &_CMsgTEFizz_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(CMsgTEFizz* other);

  // implements Message ----------------------------------------------

  inline CMsgTEFizz* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEFizz* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEFizz& from);
  void MergeFrom(const CMsgTEFizz& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEFizz* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 entity = 1;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 1;
  ::google::protobuf::uint32 entity() const;
  void set_entity(::google::protobuf::uint32 value);

  // optional uint32 density = 2;
  bool has_density() const;
  void clear_density();
  static const int kDensityFieldNumber = 2;
  ::google::protobuf::uint32 density() const;
  void set_density(::google::protobuf::uint32 value);

  // optional int32 current = 3;
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 3;
  ::google::protobuf::int32 current() const;
  void set_current(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEFizz)
 private:
  void set_has_entity();
  void clear_has_entity();
  void set_has_density();
  void clear_has_density();
  void set_has_current();
  void clear_has_current();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 entity_;
  ::google::protobuf::uint32 density_;
  ::google::protobuf::int32 current_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEShatterSurface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEShatterSurface) */ {
 public:
  CMsgTEShatterSurface();
  virtual ~CMsgTEShatterSurface();

  CMsgTEShatterSurface(const CMsgTEShatterSurface& from);

  inline CMsgTEShatterSurface& operator=(const CMsgTEShatterSurface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEShatterSurface& default_instance();

  static inline const CMsgTEShatterSurface* internal_default_instance() {
    return reinterpret_cast<const CMsgTEShatterSurface*>(
               &_CMsgTEShatterSurface_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(CMsgTEShatterSurface* other);

  // implements Message ----------------------------------------------

  inline CMsgTEShatterSurface* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEShatterSurface* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEShatterSurface& from);
  void MergeFrom(const CMsgTEShatterSurface& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEShatterSurface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgQAngle angles = 2;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 2;
  const ::proto::dota::CMsgQAngle& angles() const;
  ::proto::dota::CMsgQAngle* mutable_angles();
  ::proto::dota::CMsgQAngle* release_angles();
  void set_allocated_angles(::proto::dota::CMsgQAngle* angles);

  // optional .proto.dota.CMsgVector force = 3;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 3;
  const ::proto::dota::CMsgVector& force() const;
  ::proto::dota::CMsgVector* mutable_force();
  ::proto::dota::CMsgVector* release_force();
  void set_allocated_force(::proto::dota::CMsgVector* force);

  // optional .proto.dota.CMsgVector forcepos = 4;
  bool has_forcepos() const;
  void clear_forcepos();
  static const int kForceposFieldNumber = 4;
  const ::proto::dota::CMsgVector& forcepos() const;
  ::proto::dota::CMsgVector* mutable_forcepos();
  ::proto::dota::CMsgVector* release_forcepos();
  void set_allocated_forcepos(::proto::dota::CMsgVector* forcepos);

  // optional float width = 5;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 5;
  float width() const;
  void set_width(float value);

  // optional float height = 6;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 6;
  float height() const;
  void set_height(float value);

  // optional float shardsize = 7;
  bool has_shardsize() const;
  void clear_shardsize();
  static const int kShardsizeFieldNumber = 7;
  float shardsize() const;
  void set_shardsize(float value);

  // optional uint32 surfacetype = 8;
  bool has_surfacetype() const;
  void clear_surfacetype();
  static const int kSurfacetypeFieldNumber = 8;
  ::google::protobuf::uint32 surfacetype() const;
  void set_surfacetype(::google::protobuf::uint32 value);

  // optional fixed32 frontcolor = 9;
  bool has_frontcolor() const;
  void clear_frontcolor();
  static const int kFrontcolorFieldNumber = 9;
  ::google::protobuf::uint32 frontcolor() const;
  void set_frontcolor(::google::protobuf::uint32 value);

  // optional fixed32 backcolor = 10;
  bool has_backcolor() const;
  void clear_backcolor();
  static const int kBackcolorFieldNumber = 10;
  ::google::protobuf::uint32 backcolor() const;
  void set_backcolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEShatterSurface)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_angles();
  void clear_has_angles();
  void set_has_force();
  void clear_has_force();
  void set_has_forcepos();
  void clear_has_forcepos();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_shardsize();
  void clear_has_shardsize();
  void set_has_surfacetype();
  void clear_has_surfacetype();
  void set_has_frontcolor();
  void clear_has_frontcolor();
  void set_has_backcolor();
  void clear_has_backcolor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgQAngle* angles_;
  ::proto::dota::CMsgVector* force_;
  ::proto::dota::CMsgVector* forcepos_;
  float width_;
  float height_;
  float shardsize_;
  ::google::protobuf::uint32 surfacetype_;
  ::google::protobuf::uint32 frontcolor_;
  ::google::protobuf::uint32 backcolor_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEGlowSprite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEGlowSprite) */ {
 public:
  CMsgTEGlowSprite();
  virtual ~CMsgTEGlowSprite();

  CMsgTEGlowSprite(const CMsgTEGlowSprite& from);

  inline CMsgTEGlowSprite& operator=(const CMsgTEGlowSprite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEGlowSprite& default_instance();

  static inline const CMsgTEGlowSprite* internal_default_instance() {
    return reinterpret_cast<const CMsgTEGlowSprite*>(
               &_CMsgTEGlowSprite_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(CMsgTEGlowSprite* other);

  // implements Message ----------------------------------------------

  inline CMsgTEGlowSprite* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEGlowSprite* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEGlowSprite& from);
  void MergeFrom(const CMsgTEGlowSprite& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEGlowSprite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional float scale = 2;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 2;
  float scale() const;
  void set_scale(float value);

  // optional float life = 3;
  bool has_life() const;
  void clear_life();
  static const int kLifeFieldNumber = 3;
  float life() const;
  void set_life(float value);

  // optional uint32 brightness = 4;
  bool has_brightness() const;
  void clear_brightness();
  static const int kBrightnessFieldNumber = 4;
  ::google::protobuf::uint32 brightness() const;
  void set_brightness(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEGlowSprite)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_scale();
  void clear_has_scale();
  void set_has_life();
  void clear_has_life();
  void set_has_brightness();
  void clear_has_brightness();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  float scale_;
  float life_;
  ::google::protobuf::uint32 brightness_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEImpact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEImpact) */ {
 public:
  CMsgTEImpact();
  virtual ~CMsgTEImpact();

  CMsgTEImpact(const CMsgTEImpact& from);

  inline CMsgTEImpact& operator=(const CMsgTEImpact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEImpact& default_instance();

  static inline const CMsgTEImpact* internal_default_instance() {
    return reinterpret_cast<const CMsgTEImpact*>(
               &_CMsgTEImpact_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(CMsgTEImpact* other);

  // implements Message ----------------------------------------------

  inline CMsgTEImpact* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEImpact* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEImpact& from);
  void MergeFrom(const CMsgTEImpact& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEImpact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector normal = 2;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 2;
  const ::proto::dota::CMsgVector& normal() const;
  ::proto::dota::CMsgVector* mutable_normal();
  ::proto::dota::CMsgVector* release_normal();
  void set_allocated_normal(::proto::dota::CMsgVector* normal);

  // optional uint32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEImpact)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_normal();
  void clear_has_normal();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* normal_;
  ::google::protobuf::uint32 type_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEMuzzleFlash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEMuzzleFlash) */ {
 public:
  CMsgTEMuzzleFlash();
  virtual ~CMsgTEMuzzleFlash();

  CMsgTEMuzzleFlash(const CMsgTEMuzzleFlash& from);

  inline CMsgTEMuzzleFlash& operator=(const CMsgTEMuzzleFlash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEMuzzleFlash& default_instance();

  static inline const CMsgTEMuzzleFlash* internal_default_instance() {
    return reinterpret_cast<const CMsgTEMuzzleFlash*>(
               &_CMsgTEMuzzleFlash_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(CMsgTEMuzzleFlash* other);

  // implements Message ----------------------------------------------

  inline CMsgTEMuzzleFlash* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEMuzzleFlash* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEMuzzleFlash& from);
  void MergeFrom(const CMsgTEMuzzleFlash& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEMuzzleFlash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgQAngle angles = 2;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 2;
  const ::proto::dota::CMsgQAngle& angles() const;
  ::proto::dota::CMsgQAngle* mutable_angles();
  ::proto::dota::CMsgQAngle* release_angles();
  void set_allocated_angles(::proto::dota::CMsgQAngle* angles);

  // optional float scale = 3;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  float scale() const;
  void set_scale(float value);

  // optional uint32 type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEMuzzleFlash)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_angles();
  void clear_has_angles();
  void set_has_scale();
  void clear_has_scale();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgQAngle* angles_;
  float scale_;
  ::google::protobuf::uint32 type_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEBloodStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEBloodStream) */ {
 public:
  CMsgTEBloodStream();
  virtual ~CMsgTEBloodStream();

  CMsgTEBloodStream(const CMsgTEBloodStream& from);

  inline CMsgTEBloodStream& operator=(const CMsgTEBloodStream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEBloodStream& default_instance();

  static inline const CMsgTEBloodStream* internal_default_instance() {
    return reinterpret_cast<const CMsgTEBloodStream*>(
               &_CMsgTEBloodStream_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(CMsgTEBloodStream* other);

  // implements Message ----------------------------------------------

  inline CMsgTEBloodStream* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEBloodStream* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEBloodStream& from);
  void MergeFrom(const CMsgTEBloodStream& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEBloodStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  const ::proto::dota::CMsgVector& direction() const;
  ::proto::dota::CMsgVector* mutable_direction();
  ::proto::dota::CMsgVector* release_direction();
  void set_allocated_direction(::proto::dota::CMsgVector* direction);

  // optional fixed32 color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // optional uint32 amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::uint32 amount() const;
  void set_amount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEBloodStream)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_direction();
  void clear_has_direction();
  void set_has_color();
  void clear_has_color();
  void set_has_amount();
  void clear_has_amount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* direction_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 amount_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEExplosion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEExplosion) */ {
 public:
  CMsgTEExplosion();
  virtual ~CMsgTEExplosion();

  CMsgTEExplosion(const CMsgTEExplosion& from);

  inline CMsgTEExplosion& operator=(const CMsgTEExplosion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEExplosion& default_instance();

  static inline const CMsgTEExplosion* internal_default_instance() {
    return reinterpret_cast<const CMsgTEExplosion*>(
               &_CMsgTEExplosion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(CMsgTEExplosion* other);

  // implements Message ----------------------------------------------

  inline CMsgTEExplosion* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEExplosion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEExplosion& from);
  void MergeFrom(const CMsgTEExplosion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEExplosion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector normal = 4;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 4;
  const ::proto::dota::CMsgVector& normal() const;
  ::proto::dota::CMsgVector* mutable_normal();
  ::proto::dota::CMsgVector* release_normal();
  void set_allocated_normal(::proto::dota::CMsgVector* normal);

  // optional uint32 framerate = 2;
  bool has_framerate() const;
  void clear_framerate();
  static const int kFramerateFieldNumber = 2;
  ::google::protobuf::uint32 framerate() const;
  void set_framerate(::google::protobuf::uint32 value);

  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional uint32 materialtype = 5;
  bool has_materialtype() const;
  void clear_materialtype();
  static const int kMaterialtypeFieldNumber = 5;
  ::google::protobuf::uint32 materialtype() const;
  void set_materialtype(::google::protobuf::uint32 value);

  // optional uint32 radius = 6;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 6;
  ::google::protobuf::uint32 radius() const;
  void set_radius(::google::protobuf::uint32 value);

  // optional uint32 magnitude = 7;
  bool has_magnitude() const;
  void clear_magnitude();
  static const int kMagnitudeFieldNumber = 7;
  ::google::protobuf::uint32 magnitude() const;
  void set_magnitude(::google::protobuf::uint32 value);

  // optional float scale = 8;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 8;
  float scale() const;
  void set_scale(float value);

  // optional bool affect_ragdolls = 9;
  bool has_affect_ragdolls() const;
  void clear_affect_ragdolls();
  static const int kAffectRagdollsFieldNumber = 9;
  bool affect_ragdolls() const;
  void set_affect_ragdolls(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEExplosion)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_framerate();
  void clear_has_framerate();
  void set_has_flags();
  void clear_has_flags();
  void set_has_normal();
  void clear_has_normal();
  void set_has_materialtype();
  void clear_has_materialtype();
  void set_has_radius();
  void clear_has_radius();
  void set_has_magnitude();
  void clear_has_magnitude();
  void set_has_scale();
  void clear_has_scale();
  void set_has_affect_ragdolls();
  void clear_has_affect_ragdolls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* normal_;
  ::google::protobuf::uint32 framerate_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 materialtype_;
  ::google::protobuf::uint32 radius_;
  ::google::protobuf::uint32 magnitude_;
  float scale_;
  bool affect_ragdolls_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEDust : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEDust) */ {
 public:
  CMsgTEDust();
  virtual ~CMsgTEDust();

  CMsgTEDust(const CMsgTEDust& from);

  inline CMsgTEDust& operator=(const CMsgTEDust& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEDust& default_instance();

  static inline const CMsgTEDust* internal_default_instance() {
    return reinterpret_cast<const CMsgTEDust*>(
               &_CMsgTEDust_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(CMsgTEDust* other);

  // implements Message ----------------------------------------------

  inline CMsgTEDust* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEDust* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEDust& from);
  void MergeFrom(const CMsgTEDust& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEDust* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector direction = 4;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 4;
  const ::proto::dota::CMsgVector& direction() const;
  ::proto::dota::CMsgVector* mutable_direction();
  ::proto::dota::CMsgVector* release_direction();
  void set_allocated_direction(::proto::dota::CMsgVector* direction);

  // optional float size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  float size() const;
  void set_size(float value);

  // optional float speed = 3;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEDust)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_size();
  void clear_has_size();
  void set_has_speed();
  void clear_has_speed();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* direction_;
  float size_;
  float speed_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTELargeFunnel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTELargeFunnel) */ {
 public:
  CMsgTELargeFunnel();
  virtual ~CMsgTELargeFunnel();

  CMsgTELargeFunnel(const CMsgTELargeFunnel& from);

  inline CMsgTELargeFunnel& operator=(const CMsgTELargeFunnel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTELargeFunnel& default_instance();

  static inline const CMsgTELargeFunnel* internal_default_instance() {
    return reinterpret_cast<const CMsgTELargeFunnel*>(
               &_CMsgTELargeFunnel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(CMsgTELargeFunnel* other);

  // implements Message ----------------------------------------------

  inline CMsgTELargeFunnel* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTELargeFunnel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTELargeFunnel& from);
  void MergeFrom(const CMsgTELargeFunnel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTELargeFunnel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional uint32 reversed = 2;
  bool has_reversed() const;
  void clear_reversed();
  static const int kReversedFieldNumber = 2;
  ::google::protobuf::uint32 reversed() const;
  void set_reversed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTELargeFunnel)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_reversed();
  void clear_has_reversed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::google::protobuf::uint32 reversed_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTESparks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTESparks) */ {
 public:
  CMsgTESparks();
  virtual ~CMsgTESparks();

  CMsgTESparks(const CMsgTESparks& from);

  inline CMsgTESparks& operator=(const CMsgTESparks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTESparks& default_instance();

  static inline const CMsgTESparks* internal_default_instance() {
    return reinterpret_cast<const CMsgTESparks*>(
               &_CMsgTESparks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(CMsgTESparks* other);

  // implements Message ----------------------------------------------

  inline CMsgTESparks* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTESparks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTESparks& from);
  void MergeFrom(const CMsgTESparks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTESparks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector direction = 4;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 4;
  const ::proto::dota::CMsgVector& direction() const;
  ::proto::dota::CMsgVector* mutable_direction();
  ::proto::dota::CMsgVector* release_direction();
  void set_allocated_direction(::proto::dota::CMsgVector* direction);

  // optional uint32 magnitude = 2;
  bool has_magnitude() const;
  void clear_magnitude();
  static const int kMagnitudeFieldNumber = 2;
  ::google::protobuf::uint32 magnitude() const;
  void set_magnitude(::google::protobuf::uint32 value);

  // optional uint32 length = 3;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTESparks)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_magnitude();
  void clear_has_magnitude();
  void set_has_length();
  void clear_has_length();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* direction_;
  ::google::protobuf::uint32 magnitude_;
  ::google::protobuf::uint32 length_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEPhysicsProp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEPhysicsProp) */ {
 public:
  CMsgTEPhysicsProp();
  virtual ~CMsgTEPhysicsProp();

  CMsgTEPhysicsProp(const CMsgTEPhysicsProp& from);

  inline CMsgTEPhysicsProp& operator=(const CMsgTEPhysicsProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEPhysicsProp& default_instance();

  static inline const CMsgTEPhysicsProp* internal_default_instance() {
    return reinterpret_cast<const CMsgTEPhysicsProp*>(
               &_CMsgTEPhysicsProp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(CMsgTEPhysicsProp* other);

  // implements Message ----------------------------------------------

  inline CMsgTEPhysicsProp* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEPhysicsProp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEPhysicsProp& from);
  void MergeFrom(const CMsgTEPhysicsProp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEPhysicsProp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector velocity = 2;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  const ::proto::dota::CMsgVector& velocity() const;
  ::proto::dota::CMsgVector* mutable_velocity();
  ::proto::dota::CMsgVector* release_velocity();
  void set_allocated_velocity(::proto::dota::CMsgVector* velocity);

  // optional .proto.dota.CMsgQAngle angles = 3;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 3;
  const ::proto::dota::CMsgQAngle& angles() const;
  ::proto::dota::CMsgQAngle* mutable_angles();
  ::proto::dota::CMsgQAngle* release_angles();
  void set_allocated_angles(::proto::dota::CMsgQAngle* angles);

  // optional fixed32 skin = 4;
  bool has_skin() const;
  void clear_skin();
  static const int kSkinFieldNumber = 4;
  ::google::protobuf::uint32 skin() const;
  void set_skin(::google::protobuf::uint32 value);

  // optional uint32 flags = 5;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 5;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional uint32 effects = 6;
  bool has_effects() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 6;
  ::google::protobuf::uint32 effects() const;
  void set_effects(::google::protobuf::uint32 value);

  // optional fixed32 color = 7;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 7;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // optional fixed64 modelindex = 8;
  bool has_modelindex() const;
  void clear_modelindex();
  static const int kModelindexFieldNumber = 8;
  ::google::protobuf::uint64 modelindex() const;
  void set_modelindex(::google::protobuf::uint64 value);

  // optional uint32 breakmodelsnottomake = 9;
  bool has_breakmodelsnottomake() const;
  void clear_breakmodelsnottomake();
  static const int kBreakmodelsnottomakeFieldNumber = 9;
  ::google::protobuf::uint32 breakmodelsnottomake() const;
  void set_breakmodelsnottomake(::google::protobuf::uint32 value);

  // optional float scale = 10;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 10;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEPhysicsProp)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_angles();
  void clear_has_angles();
  void set_has_skin();
  void clear_has_skin();
  void set_has_flags();
  void clear_has_flags();
  void set_has_effects();
  void clear_has_effects();
  void set_has_color();
  void clear_has_color();
  void set_has_modelindex();
  void clear_has_modelindex();
  void set_has_breakmodelsnottomake();
  void clear_has_breakmodelsnottomake();
  void set_has_scale();
  void clear_has_scale();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* velocity_;
  ::proto::dota::CMsgQAngle* angles_;
  ::google::protobuf::uint32 skin_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 effects_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint64 modelindex_;
  ::google::protobuf::uint32 breakmodelsnottomake_;
  float scale_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEPlayerDecal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEPlayerDecal) */ {
 public:
  CMsgTEPlayerDecal();
  virtual ~CMsgTEPlayerDecal();

  CMsgTEPlayerDecal(const CMsgTEPlayerDecal& from);

  inline CMsgTEPlayerDecal& operator=(const CMsgTEPlayerDecal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEPlayerDecal& default_instance();

  static inline const CMsgTEPlayerDecal* internal_default_instance() {
    return reinterpret_cast<const CMsgTEPlayerDecal*>(
               &_CMsgTEPlayerDecal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(CMsgTEPlayerDecal* other);

  // implements Message ----------------------------------------------

  inline CMsgTEPlayerDecal* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEPlayerDecal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEPlayerDecal& from);
  void MergeFrom(const CMsgTEPlayerDecal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEPlayerDecal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional uint32 player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  ::google::protobuf::uint32 player() const;
  void set_player(::google::protobuf::uint32 value);

  // optional uint32 entity = 3;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 3;
  ::google::protobuf::uint32 entity() const;
  void set_entity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEPlayerDecal)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_player();
  void clear_has_player();
  void set_has_entity();
  void clear_has_entity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::google::protobuf::uint32 player_;
  ::google::protobuf::uint32 entity_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEProjectedDecal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEProjectedDecal) */ {
 public:
  CMsgTEProjectedDecal();
  virtual ~CMsgTEProjectedDecal();

  CMsgTEProjectedDecal(const CMsgTEProjectedDecal& from);

  inline CMsgTEProjectedDecal& operator=(const CMsgTEProjectedDecal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEProjectedDecal& default_instance();

  static inline const CMsgTEProjectedDecal* internal_default_instance() {
    return reinterpret_cast<const CMsgTEProjectedDecal*>(
               &_CMsgTEProjectedDecal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(CMsgTEProjectedDecal* other);

  // implements Message ----------------------------------------------

  inline CMsgTEProjectedDecal* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEProjectedDecal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEProjectedDecal& from);
  void MergeFrom(const CMsgTEProjectedDecal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEProjectedDecal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgQAngle angles = 2;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 2;
  const ::proto::dota::CMsgQAngle& angles() const;
  ::proto::dota::CMsgQAngle* mutable_angles();
  ::proto::dota::CMsgQAngle* release_angles();
  void set_allocated_angles(::proto::dota::CMsgQAngle* angles);

  // optional uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional float distance = 4;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 4;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEProjectedDecal)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_angles();
  void clear_has_angles();
  void set_has_index();
  void clear_has_index();
  void set_has_distance();
  void clear_has_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgQAngle* angles_;
  ::google::protobuf::uint32 index_;
  float distance_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTESmoke : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTESmoke) */ {
 public:
  CMsgTESmoke();
  virtual ~CMsgTESmoke();

  CMsgTESmoke(const CMsgTESmoke& from);

  inline CMsgTESmoke& operator=(const CMsgTESmoke& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTESmoke& default_instance();

  static inline const CMsgTESmoke* internal_default_instance() {
    return reinterpret_cast<const CMsgTESmoke*>(
               &_CMsgTESmoke_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(CMsgTESmoke* other);

  // implements Message ----------------------------------------------

  inline CMsgTESmoke* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTESmoke* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTESmoke& from);
  void MergeFrom(const CMsgTESmoke& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTESmoke* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional float scale = 2;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 2;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTESmoke)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_scale();
  void clear_has_scale();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  float scale_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CMsgTEWorldDecal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgTEWorldDecal) */ {
 public:
  CMsgTEWorldDecal();
  virtual ~CMsgTEWorldDecal();

  CMsgTEWorldDecal(const CMsgTEWorldDecal& from);

  inline CMsgTEWorldDecal& operator=(const CMsgTEWorldDecal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgTEWorldDecal& default_instance();

  static inline const CMsgTEWorldDecal* internal_default_instance() {
    return reinterpret_cast<const CMsgTEWorldDecal*>(
               &_CMsgTEWorldDecal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(CMsgTEWorldDecal* other);

  // implements Message ----------------------------------------------

  inline CMsgTEWorldDecal* New() const PROTOBUF_FINAL { return New(NULL); }

  CMsgTEWorldDecal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMsgTEWorldDecal& from);
  void MergeFrom(const CMsgTEWorldDecal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMsgTEWorldDecal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgVector origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::proto::dota::CMsgVector& origin() const;
  ::proto::dota::CMsgVector* mutable_origin();
  ::proto::dota::CMsgVector* release_origin();
  void set_allocated_origin(::proto::dota::CMsgVector* origin);

  // optional .proto.dota.CMsgVector normal = 2;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 2;
  const ::proto::dota::CMsgVector& normal() const;
  ::proto::dota::CMsgVector* mutable_normal();
  ::proto::dota::CMsgVector* release_normal();
  void set_allocated_normal(::proto::dota::CMsgVector* normal);

  // optional uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgTEWorldDecal)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_normal();
  void clear_has_normal();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::dota::CMsgVector* origin_;
  ::proto::dota::CMsgVector* normal_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_te_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEArmorRicochet

// optional .proto.dota.CMsgVector pos = 1;
inline bool CMsgTEArmorRicochet::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEArmorRicochet::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEArmorRicochet::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEArmorRicochet::clear_pos() {
  if (pos_ != NULL) pos_->::proto::dota::CMsgVector::Clear();
  clear_has_pos();
}
inline const ::proto::dota::CMsgVector& CMsgTEArmorRicochet::pos() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEArmorRicochet.pos)
  return pos_ != NULL ? *pos_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEArmorRicochet::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEArmorRicochet.pos)
  return pos_;
}
inline ::proto::dota::CMsgVector* CMsgTEArmorRicochet::release_pos() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEArmorRicochet.pos)
  clear_has_pos();
  ::proto::dota::CMsgVector* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void CMsgTEArmorRicochet::set_allocated_pos(::proto::dota::CMsgVector* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEArmorRicochet.pos)
}

// optional .proto.dota.CMsgVector dir = 2;
inline bool CMsgTEArmorRicochet::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEArmorRicochet::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEArmorRicochet::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEArmorRicochet::clear_dir() {
  if (dir_ != NULL) dir_->::proto::dota::CMsgVector::Clear();
  clear_has_dir();
}
inline const ::proto::dota::CMsgVector& CMsgTEArmorRicochet::dir() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEArmorRicochet.dir)
  return dir_ != NULL ? *dir_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEArmorRicochet::mutable_dir() {
  set_has_dir();
  if (dir_ == NULL) {
    dir_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEArmorRicochet.dir)
  return dir_;
}
inline ::proto::dota::CMsgVector* CMsgTEArmorRicochet::release_dir() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEArmorRicochet.dir)
  clear_has_dir();
  ::proto::dota::CMsgVector* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline void CMsgTEArmorRicochet::set_allocated_dir(::proto::dota::CMsgVector* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    set_has_dir();
  } else {
    clear_has_dir();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEArmorRicochet.dir)
}

// -------------------------------------------------------------------

// CMsgTEBaseBeam

// optional fixed64 modelindex = 1;
inline bool CMsgTEBaseBeam::has_modelindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBaseBeam::set_has_modelindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBaseBeam::clear_has_modelindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBaseBeam::clear_modelindex() {
  modelindex_ = GOOGLE_ULONGLONG(0);
  clear_has_modelindex();
}
inline ::google::protobuf::uint64 CMsgTEBaseBeam::modelindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.modelindex)
  return modelindex_;
}
inline void CMsgTEBaseBeam::set_modelindex(::google::protobuf::uint64 value) {
  set_has_modelindex();
  modelindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.modelindex)
}

// optional fixed64 haloindex = 2;
inline bool CMsgTEBaseBeam::has_haloindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBaseBeam::set_has_haloindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBaseBeam::clear_has_haloindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBaseBeam::clear_haloindex() {
  haloindex_ = GOOGLE_ULONGLONG(0);
  clear_has_haloindex();
}
inline ::google::protobuf::uint64 CMsgTEBaseBeam::haloindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.haloindex)
  return haloindex_;
}
inline void CMsgTEBaseBeam::set_haloindex(::google::protobuf::uint64 value) {
  set_has_haloindex();
  haloindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.haloindex)
}

// optional uint32 startframe = 3;
inline bool CMsgTEBaseBeam::has_startframe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBaseBeam::set_has_startframe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBaseBeam::clear_has_startframe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBaseBeam::clear_startframe() {
  startframe_ = 0u;
  clear_has_startframe();
}
inline ::google::protobuf::uint32 CMsgTEBaseBeam::startframe() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.startframe)
  return startframe_;
}
inline void CMsgTEBaseBeam::set_startframe(::google::protobuf::uint32 value) {
  set_has_startframe();
  startframe_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.startframe)
}

// optional uint32 framerate = 4;
inline bool CMsgTEBaseBeam::has_framerate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBaseBeam::set_has_framerate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBaseBeam::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBaseBeam::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 CMsgTEBaseBeam::framerate() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.framerate)
  return framerate_;
}
inline void CMsgTEBaseBeam::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.framerate)
}

// optional float life = 5;
inline bool CMsgTEBaseBeam::has_life() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEBaseBeam::set_has_life() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEBaseBeam::clear_has_life() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEBaseBeam::clear_life() {
  life_ = 0;
  clear_has_life();
}
inline float CMsgTEBaseBeam::life() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.life)
  return life_;
}
inline void CMsgTEBaseBeam::set_life(float value) {
  set_has_life();
  life_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.life)
}

// optional float width = 6;
inline bool CMsgTEBaseBeam::has_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgTEBaseBeam::set_has_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgTEBaseBeam::clear_has_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgTEBaseBeam::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float CMsgTEBaseBeam::width() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.width)
  return width_;
}
inline void CMsgTEBaseBeam::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.width)
}

// optional float endwidth = 7;
inline bool CMsgTEBaseBeam::has_endwidth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgTEBaseBeam::set_has_endwidth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgTEBaseBeam::clear_has_endwidth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgTEBaseBeam::clear_endwidth() {
  endwidth_ = 0;
  clear_has_endwidth();
}
inline float CMsgTEBaseBeam::endwidth() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.endwidth)
  return endwidth_;
}
inline void CMsgTEBaseBeam::set_endwidth(float value) {
  set_has_endwidth();
  endwidth_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.endwidth)
}

// optional uint32 fadelength = 8;
inline bool CMsgTEBaseBeam::has_fadelength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgTEBaseBeam::set_has_fadelength() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgTEBaseBeam::clear_has_fadelength() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgTEBaseBeam::clear_fadelength() {
  fadelength_ = 0u;
  clear_has_fadelength();
}
inline ::google::protobuf::uint32 CMsgTEBaseBeam::fadelength() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.fadelength)
  return fadelength_;
}
inline void CMsgTEBaseBeam::set_fadelength(::google::protobuf::uint32 value) {
  set_has_fadelength();
  fadelength_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.fadelength)
}

// optional float amplitude = 9;
inline bool CMsgTEBaseBeam::has_amplitude() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgTEBaseBeam::set_has_amplitude() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgTEBaseBeam::clear_has_amplitude() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgTEBaseBeam::clear_amplitude() {
  amplitude_ = 0;
  clear_has_amplitude();
}
inline float CMsgTEBaseBeam::amplitude() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.amplitude)
  return amplitude_;
}
inline void CMsgTEBaseBeam::set_amplitude(float value) {
  set_has_amplitude();
  amplitude_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.amplitude)
}

// optional fixed32 color = 10;
inline bool CMsgTEBaseBeam::has_color() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgTEBaseBeam::set_has_color() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgTEBaseBeam::clear_has_color() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgTEBaseBeam::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CMsgTEBaseBeam::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.color)
  return color_;
}
inline void CMsgTEBaseBeam::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.color)
}

// optional uint32 speed = 11;
inline bool CMsgTEBaseBeam::has_speed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgTEBaseBeam::set_has_speed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgTEBaseBeam::clear_has_speed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgTEBaseBeam::clear_speed() {
  speed_ = 0u;
  clear_has_speed();
}
inline ::google::protobuf::uint32 CMsgTEBaseBeam::speed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.speed)
  return speed_;
}
inline void CMsgTEBaseBeam::set_speed(::google::protobuf::uint32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.speed)
}

// optional uint32 flags = 12;
inline bool CMsgTEBaseBeam::has_flags() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgTEBaseBeam::set_has_flags() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgTEBaseBeam::clear_has_flags() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgTEBaseBeam::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgTEBaseBeam::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBaseBeam.flags)
  return flags_;
}
inline void CMsgTEBaseBeam::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBaseBeam.flags)
}

// -------------------------------------------------------------------

// CMsgTEBeamEntPoint

// optional .proto.dota.CMsgTEBaseBeam base = 1;
inline bool CMsgTEBeamEntPoint::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBeamEntPoint::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBeamEntPoint::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBeamEntPoint::clear_base() {
  if (base_ != NULL) base_->::proto::dota::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
inline const ::proto::dota::CMsgTEBaseBeam& CMsgTEBeamEntPoint::base() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEntPoint.base)
  return base_ != NULL ? *base_
                         : *::proto::dota::CMsgTEBaseBeam::internal_default_instance();
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamEntPoint::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::proto::dota::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamEntPoint.base)
  return base_;
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamEntPoint::release_base() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamEntPoint.base)
  clear_has_base();
  ::proto::dota::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
inline void CMsgTEBeamEntPoint::set_allocated_base(::proto::dota::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamEntPoint.base)
}

// optional uint32 startentity = 2;
inline bool CMsgTEBeamEntPoint::has_startentity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBeamEntPoint::set_has_startentity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBeamEntPoint::clear_has_startentity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBeamEntPoint::clear_startentity() {
  startentity_ = 0u;
  clear_has_startentity();
}
inline ::google::protobuf::uint32 CMsgTEBeamEntPoint::startentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEntPoint.startentity)
  return startentity_;
}
inline void CMsgTEBeamEntPoint::set_startentity(::google::protobuf::uint32 value) {
  set_has_startentity();
  startentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBeamEntPoint.startentity)
}

// optional uint32 endentity = 3;
inline bool CMsgTEBeamEntPoint::has_endentity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEBeamEntPoint::set_has_endentity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEBeamEntPoint::clear_has_endentity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEBeamEntPoint::clear_endentity() {
  endentity_ = 0u;
  clear_has_endentity();
}
inline ::google::protobuf::uint32 CMsgTEBeamEntPoint::endentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEntPoint.endentity)
  return endentity_;
}
inline void CMsgTEBeamEntPoint::set_endentity(::google::protobuf::uint32 value) {
  set_has_endentity();
  endentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBeamEntPoint.endentity)
}

// optional .proto.dota.CMsgVector start = 4;
inline bool CMsgTEBeamEntPoint::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBeamEntPoint::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBeamEntPoint::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBeamEntPoint::clear_start() {
  if (start_ != NULL) start_->::proto::dota::CMsgVector::Clear();
  clear_has_start();
}
inline const ::proto::dota::CMsgVector& CMsgTEBeamEntPoint::start() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEntPoint.start)
  return start_ != NULL ? *start_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBeamEntPoint::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamEntPoint.start)
  return start_;
}
inline ::proto::dota::CMsgVector* CMsgTEBeamEntPoint::release_start() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamEntPoint.start)
  clear_has_start();
  ::proto::dota::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
inline void CMsgTEBeamEntPoint::set_allocated_start(::proto::dota::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamEntPoint.start)
}

// optional .proto.dota.CMsgVector end = 5;
inline bool CMsgTEBeamEntPoint::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBeamEntPoint::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBeamEntPoint::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBeamEntPoint::clear_end() {
  if (end_ != NULL) end_->::proto::dota::CMsgVector::Clear();
  clear_has_end();
}
inline const ::proto::dota::CMsgVector& CMsgTEBeamEntPoint::end() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEntPoint.end)
  return end_ != NULL ? *end_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBeamEntPoint::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    end_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamEntPoint.end)
  return end_;
}
inline ::proto::dota::CMsgVector* CMsgTEBeamEntPoint::release_end() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamEntPoint.end)
  clear_has_end();
  ::proto::dota::CMsgVector* temp = end_;
  end_ = NULL;
  return temp;
}
inline void CMsgTEBeamEntPoint::set_allocated_end(::proto::dota::CMsgVector* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamEntPoint.end)
}

// -------------------------------------------------------------------

// CMsgTEBeamEnts

// optional .proto.dota.CMsgTEBaseBeam base = 1;
inline bool CMsgTEBeamEnts::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBeamEnts::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBeamEnts::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBeamEnts::clear_base() {
  if (base_ != NULL) base_->::proto::dota::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
inline const ::proto::dota::CMsgTEBaseBeam& CMsgTEBeamEnts::base() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEnts.base)
  return base_ != NULL ? *base_
                         : *::proto::dota::CMsgTEBaseBeam::internal_default_instance();
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamEnts::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::proto::dota::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamEnts.base)
  return base_;
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamEnts::release_base() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamEnts.base)
  clear_has_base();
  ::proto::dota::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
inline void CMsgTEBeamEnts::set_allocated_base(::proto::dota::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamEnts.base)
}

// optional uint32 startentity = 2;
inline bool CMsgTEBeamEnts::has_startentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBeamEnts::set_has_startentity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBeamEnts::clear_has_startentity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBeamEnts::clear_startentity() {
  startentity_ = 0u;
  clear_has_startentity();
}
inline ::google::protobuf::uint32 CMsgTEBeamEnts::startentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEnts.startentity)
  return startentity_;
}
inline void CMsgTEBeamEnts::set_startentity(::google::protobuf::uint32 value) {
  set_has_startentity();
  startentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBeamEnts.startentity)
}

// optional uint32 endentity = 3;
inline bool CMsgTEBeamEnts::has_endentity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBeamEnts::set_has_endentity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBeamEnts::clear_has_endentity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBeamEnts::clear_endentity() {
  endentity_ = 0u;
  clear_has_endentity();
}
inline ::google::protobuf::uint32 CMsgTEBeamEnts::endentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamEnts.endentity)
  return endentity_;
}
inline void CMsgTEBeamEnts::set_endentity(::google::protobuf::uint32 value) {
  set_has_endentity();
  endentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBeamEnts.endentity)
}

// -------------------------------------------------------------------

// CMsgTEBeamPoints

// optional .proto.dota.CMsgTEBaseBeam base = 1;
inline bool CMsgTEBeamPoints::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBeamPoints::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBeamPoints::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBeamPoints::clear_base() {
  if (base_ != NULL) base_->::proto::dota::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
inline const ::proto::dota::CMsgTEBaseBeam& CMsgTEBeamPoints::base() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamPoints.base)
  return base_ != NULL ? *base_
                         : *::proto::dota::CMsgTEBaseBeam::internal_default_instance();
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamPoints::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::proto::dota::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamPoints.base)
  return base_;
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamPoints::release_base() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamPoints.base)
  clear_has_base();
  ::proto::dota::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
inline void CMsgTEBeamPoints::set_allocated_base(::proto::dota::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamPoints.base)
}

// optional .proto.dota.CMsgVector start = 2;
inline bool CMsgTEBeamPoints::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBeamPoints::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBeamPoints::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBeamPoints::clear_start() {
  if (start_ != NULL) start_->::proto::dota::CMsgVector::Clear();
  clear_has_start();
}
inline const ::proto::dota::CMsgVector& CMsgTEBeamPoints::start() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamPoints.start)
  return start_ != NULL ? *start_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBeamPoints::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamPoints.start)
  return start_;
}
inline ::proto::dota::CMsgVector* CMsgTEBeamPoints::release_start() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamPoints.start)
  clear_has_start();
  ::proto::dota::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
inline void CMsgTEBeamPoints::set_allocated_start(::proto::dota::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamPoints.start)
}

// optional .proto.dota.CMsgVector end = 3;
inline bool CMsgTEBeamPoints::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBeamPoints::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBeamPoints::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBeamPoints::clear_end() {
  if (end_ != NULL) end_->::proto::dota::CMsgVector::Clear();
  clear_has_end();
}
inline const ::proto::dota::CMsgVector& CMsgTEBeamPoints::end() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamPoints.end)
  return end_ != NULL ? *end_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBeamPoints::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    end_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamPoints.end)
  return end_;
}
inline ::proto::dota::CMsgVector* CMsgTEBeamPoints::release_end() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamPoints.end)
  clear_has_end();
  ::proto::dota::CMsgVector* temp = end_;
  end_ = NULL;
  return temp;
}
inline void CMsgTEBeamPoints::set_allocated_end(::proto::dota::CMsgVector* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamPoints.end)
}

// -------------------------------------------------------------------

// CMsgTEBeamRing

// optional .proto.dota.CMsgTEBaseBeam base = 1;
inline bool CMsgTEBeamRing::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBeamRing::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBeamRing::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBeamRing::clear_base() {
  if (base_ != NULL) base_->::proto::dota::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
inline const ::proto::dota::CMsgTEBaseBeam& CMsgTEBeamRing::base() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamRing.base)
  return base_ != NULL ? *base_
                         : *::proto::dota::CMsgTEBaseBeam::internal_default_instance();
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamRing::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::proto::dota::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBeamRing.base)
  return base_;
}
inline ::proto::dota::CMsgTEBaseBeam* CMsgTEBeamRing::release_base() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBeamRing.base)
  clear_has_base();
  ::proto::dota::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
inline void CMsgTEBeamRing::set_allocated_base(::proto::dota::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBeamRing.base)
}

// optional uint32 startentity = 2;
inline bool CMsgTEBeamRing::has_startentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBeamRing::set_has_startentity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBeamRing::clear_has_startentity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBeamRing::clear_startentity() {
  startentity_ = 0u;
  clear_has_startentity();
}
inline ::google::protobuf::uint32 CMsgTEBeamRing::startentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamRing.startentity)
  return startentity_;
}
inline void CMsgTEBeamRing::set_startentity(::google::protobuf::uint32 value) {
  set_has_startentity();
  startentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBeamRing.startentity)
}

// optional uint32 endentity = 3;
inline bool CMsgTEBeamRing::has_endentity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBeamRing::set_has_endentity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBeamRing::clear_has_endentity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBeamRing::clear_endentity() {
  endentity_ = 0u;
  clear_has_endentity();
}
inline ::google::protobuf::uint32 CMsgTEBeamRing::endentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBeamRing.endentity)
  return endentity_;
}
inline void CMsgTEBeamRing::set_endentity(::google::protobuf::uint32 value) {
  set_has_endentity();
  endentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBeamRing.endentity)
}

// -------------------------------------------------------------------

// CMsgTEBreakModel

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEBreakModel::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBreakModel::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBreakModel::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBreakModel::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEBreakModel::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBreakModel::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBreakModel.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEBreakModel::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBreakModel.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEBreakModel::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBreakModel.origin)
}

// optional .proto.dota.CMsgQAngle angles = 2;
inline bool CMsgTEBreakModel::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBreakModel::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBreakModel::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBreakModel::clear_angles() {
  if (angles_ != NULL) angles_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angles();
}
inline const ::proto::dota::CMsgQAngle& CMsgTEBreakModel::angles() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.angles)
  return angles_ != NULL ? *angles_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CMsgTEBreakModel::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBreakModel.angles)
  return angles_;
}
inline ::proto::dota::CMsgQAngle* CMsgTEBreakModel::release_angles() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBreakModel.angles)
  clear_has_angles();
  ::proto::dota::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void CMsgTEBreakModel::set_allocated_angles(::proto::dota::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBreakModel.angles)
}

// optional .proto.dota.CMsgVector size = 3;
inline bool CMsgTEBreakModel::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBreakModel::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBreakModel::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBreakModel::clear_size() {
  if (size_ != NULL) size_->::proto::dota::CMsgVector::Clear();
  clear_has_size();
}
inline const ::proto::dota::CMsgVector& CMsgTEBreakModel::size() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.size)
  return size_ != NULL ? *size_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBreakModel::mutable_size() {
  set_has_size();
  if (size_ == NULL) {
    size_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBreakModel.size)
  return size_;
}
inline ::proto::dota::CMsgVector* CMsgTEBreakModel::release_size() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBreakModel.size)
  clear_has_size();
  ::proto::dota::CMsgVector* temp = size_;
  size_ = NULL;
  return temp;
}
inline void CMsgTEBreakModel::set_allocated_size(::proto::dota::CMsgVector* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBreakModel.size)
}

// optional .proto.dota.CMsgVector velocity = 4;
inline bool CMsgTEBreakModel::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBreakModel::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBreakModel::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBreakModel::clear_velocity() {
  if (velocity_ != NULL) velocity_->::proto::dota::CMsgVector::Clear();
  clear_has_velocity();
}
inline const ::proto::dota::CMsgVector& CMsgTEBreakModel::velocity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.velocity)
  return velocity_ != NULL ? *velocity_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBreakModel::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBreakModel.velocity)
  return velocity_;
}
inline ::proto::dota::CMsgVector* CMsgTEBreakModel::release_velocity() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBreakModel.velocity)
  clear_has_velocity();
  ::proto::dota::CMsgVector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void CMsgTEBreakModel::set_allocated_velocity(::proto::dota::CMsgVector* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBreakModel.velocity)
}

// optional uint32 randomization = 5;
inline bool CMsgTEBreakModel::has_randomization() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgTEBreakModel::set_has_randomization() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgTEBreakModel::clear_has_randomization() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgTEBreakModel::clear_randomization() {
  randomization_ = 0u;
  clear_has_randomization();
}
inline ::google::protobuf::uint32 CMsgTEBreakModel::randomization() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.randomization)
  return randomization_;
}
inline void CMsgTEBreakModel::set_randomization(::google::protobuf::uint32 value) {
  set_has_randomization();
  randomization_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBreakModel.randomization)
}

// optional fixed64 modelindex = 6;
inline bool CMsgTEBreakModel::has_modelindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEBreakModel::set_has_modelindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEBreakModel::clear_has_modelindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEBreakModel::clear_modelindex() {
  modelindex_ = GOOGLE_ULONGLONG(0);
  clear_has_modelindex();
}
inline ::google::protobuf::uint64 CMsgTEBreakModel::modelindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.modelindex)
  return modelindex_;
}
inline void CMsgTEBreakModel::set_modelindex(::google::protobuf::uint64 value) {
  set_has_modelindex();
  modelindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBreakModel.modelindex)
}

// optional uint32 count = 7;
inline bool CMsgTEBreakModel::has_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgTEBreakModel::set_has_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgTEBreakModel::clear_has_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgTEBreakModel::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgTEBreakModel::count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.count)
  return count_;
}
inline void CMsgTEBreakModel::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBreakModel.count)
}

// optional float time = 8;
inline bool CMsgTEBreakModel::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgTEBreakModel::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgTEBreakModel::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgTEBreakModel::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float CMsgTEBreakModel::time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.time)
  return time_;
}
inline void CMsgTEBreakModel::set_time(float value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBreakModel.time)
}

// optional uint32 flags = 9;
inline bool CMsgTEBreakModel::has_flags() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgTEBreakModel::set_has_flags() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgTEBreakModel::clear_has_flags() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgTEBreakModel::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgTEBreakModel::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBreakModel.flags)
  return flags_;
}
inline void CMsgTEBreakModel::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBreakModel.flags)
}

// -------------------------------------------------------------------

// CMsgTEBSPDecal

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEBSPDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBSPDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBSPDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBSPDecal::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEBSPDecal::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBSPDecal.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBSPDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBSPDecal.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEBSPDecal::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBSPDecal.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEBSPDecal::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBSPDecal.origin)
}

// optional .proto.dota.CMsgVector normal = 2;
inline bool CMsgTEBSPDecal::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBSPDecal::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBSPDecal::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBSPDecal::clear_normal() {
  if (normal_ != NULL) normal_->::proto::dota::CMsgVector::Clear();
  clear_has_normal();
}
inline const ::proto::dota::CMsgVector& CMsgTEBSPDecal::normal() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBSPDecal.normal)
  return normal_ != NULL ? *normal_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBSPDecal::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBSPDecal.normal)
  return normal_;
}
inline ::proto::dota::CMsgVector* CMsgTEBSPDecal::release_normal() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBSPDecal.normal)
  clear_has_normal();
  ::proto::dota::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void CMsgTEBSPDecal::set_allocated_normal(::proto::dota::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBSPDecal.normal)
}

// optional .proto.dota.CMsgVector saxis = 3;
inline bool CMsgTEBSPDecal::has_saxis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBSPDecal::set_has_saxis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBSPDecal::clear_has_saxis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBSPDecal::clear_saxis() {
  if (saxis_ != NULL) saxis_->::proto::dota::CMsgVector::Clear();
  clear_has_saxis();
}
inline const ::proto::dota::CMsgVector& CMsgTEBSPDecal::saxis() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBSPDecal.saxis)
  return saxis_ != NULL ? *saxis_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBSPDecal::mutable_saxis() {
  set_has_saxis();
  if (saxis_ == NULL) {
    saxis_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBSPDecal.saxis)
  return saxis_;
}
inline ::proto::dota::CMsgVector* CMsgTEBSPDecal::release_saxis() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBSPDecal.saxis)
  clear_has_saxis();
  ::proto::dota::CMsgVector* temp = saxis_;
  saxis_ = NULL;
  return temp;
}
inline void CMsgTEBSPDecal::set_allocated_saxis(::proto::dota::CMsgVector* saxis) {
  delete saxis_;
  saxis_ = saxis;
  if (saxis) {
    set_has_saxis();
  } else {
    clear_has_saxis();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBSPDecal.saxis)
}

// optional uint32 entity = 4;
inline bool CMsgTEBSPDecal::has_entity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBSPDecal::set_has_entity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBSPDecal::clear_has_entity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBSPDecal::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
inline ::google::protobuf::uint32 CMsgTEBSPDecal::entity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBSPDecal.entity)
  return entity_;
}
inline void CMsgTEBSPDecal::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBSPDecal.entity)
}

// optional uint32 index = 5;
inline bool CMsgTEBSPDecal::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEBSPDecal::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEBSPDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEBSPDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CMsgTEBSPDecal::index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBSPDecal.index)
  return index_;
}
inline void CMsgTEBSPDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBSPDecal.index)
}

// -------------------------------------------------------------------

// CMsgTEBubbles

// optional .proto.dota.CMsgVector mins = 1;
inline bool CMsgTEBubbles::has_mins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBubbles::set_has_mins() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBubbles::clear_has_mins() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBubbles::clear_mins() {
  if (mins_ != NULL) mins_->::proto::dota::CMsgVector::Clear();
  clear_has_mins();
}
inline const ::proto::dota::CMsgVector& CMsgTEBubbles::mins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbles.mins)
  return mins_ != NULL ? *mins_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBubbles::mutable_mins() {
  set_has_mins();
  if (mins_ == NULL) {
    mins_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBubbles.mins)
  return mins_;
}
inline ::proto::dota::CMsgVector* CMsgTEBubbles::release_mins() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBubbles.mins)
  clear_has_mins();
  ::proto::dota::CMsgVector* temp = mins_;
  mins_ = NULL;
  return temp;
}
inline void CMsgTEBubbles::set_allocated_mins(::proto::dota::CMsgVector* mins) {
  delete mins_;
  mins_ = mins;
  if (mins) {
    set_has_mins();
  } else {
    clear_has_mins();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBubbles.mins)
}

// optional .proto.dota.CMsgVector maxs = 2;
inline bool CMsgTEBubbles::has_maxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBubbles::set_has_maxs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBubbles::clear_has_maxs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBubbles::clear_maxs() {
  if (maxs_ != NULL) maxs_->::proto::dota::CMsgVector::Clear();
  clear_has_maxs();
}
inline const ::proto::dota::CMsgVector& CMsgTEBubbles::maxs() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbles.maxs)
  return maxs_ != NULL ? *maxs_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBubbles::mutable_maxs() {
  set_has_maxs();
  if (maxs_ == NULL) {
    maxs_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBubbles.maxs)
  return maxs_;
}
inline ::proto::dota::CMsgVector* CMsgTEBubbles::release_maxs() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBubbles.maxs)
  clear_has_maxs();
  ::proto::dota::CMsgVector* temp = maxs_;
  maxs_ = NULL;
  return temp;
}
inline void CMsgTEBubbles::set_allocated_maxs(::proto::dota::CMsgVector* maxs) {
  delete maxs_;
  maxs_ = maxs;
  if (maxs) {
    set_has_maxs();
  } else {
    clear_has_maxs();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBubbles.maxs)
}

// optional float height = 3;
inline bool CMsgTEBubbles::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBubbles::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBubbles::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBubbles::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float CMsgTEBubbles::height() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbles.height)
  return height_;
}
inline void CMsgTEBubbles::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBubbles.height)
}

// optional uint32 count = 4;
inline bool CMsgTEBubbles::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBubbles::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBubbles::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBubbles::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgTEBubbles::count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbles.count)
  return count_;
}
inline void CMsgTEBubbles::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBubbles.count)
}

// optional float speed = 5;
inline bool CMsgTEBubbles::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEBubbles::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEBubbles::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEBubbles::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float CMsgTEBubbles::speed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbles.speed)
  return speed_;
}
inline void CMsgTEBubbles::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBubbles.speed)
}

// -------------------------------------------------------------------

// CMsgTEBubbleTrail

// optional .proto.dota.CMsgVector mins = 1;
inline bool CMsgTEBubbleTrail::has_mins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBubbleTrail::set_has_mins() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBubbleTrail::clear_has_mins() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBubbleTrail::clear_mins() {
  if (mins_ != NULL) mins_->::proto::dota::CMsgVector::Clear();
  clear_has_mins();
}
inline const ::proto::dota::CMsgVector& CMsgTEBubbleTrail::mins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbleTrail.mins)
  return mins_ != NULL ? *mins_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBubbleTrail::mutable_mins() {
  set_has_mins();
  if (mins_ == NULL) {
    mins_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBubbleTrail.mins)
  return mins_;
}
inline ::proto::dota::CMsgVector* CMsgTEBubbleTrail::release_mins() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBubbleTrail.mins)
  clear_has_mins();
  ::proto::dota::CMsgVector* temp = mins_;
  mins_ = NULL;
  return temp;
}
inline void CMsgTEBubbleTrail::set_allocated_mins(::proto::dota::CMsgVector* mins) {
  delete mins_;
  mins_ = mins;
  if (mins) {
    set_has_mins();
  } else {
    clear_has_mins();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBubbleTrail.mins)
}

// optional .proto.dota.CMsgVector maxs = 2;
inline bool CMsgTEBubbleTrail::has_maxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBubbleTrail::set_has_maxs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBubbleTrail::clear_has_maxs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBubbleTrail::clear_maxs() {
  if (maxs_ != NULL) maxs_->::proto::dota::CMsgVector::Clear();
  clear_has_maxs();
}
inline const ::proto::dota::CMsgVector& CMsgTEBubbleTrail::maxs() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbleTrail.maxs)
  return maxs_ != NULL ? *maxs_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBubbleTrail::mutable_maxs() {
  set_has_maxs();
  if (maxs_ == NULL) {
    maxs_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBubbleTrail.maxs)
  return maxs_;
}
inline ::proto::dota::CMsgVector* CMsgTEBubbleTrail::release_maxs() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBubbleTrail.maxs)
  clear_has_maxs();
  ::proto::dota::CMsgVector* temp = maxs_;
  maxs_ = NULL;
  return temp;
}
inline void CMsgTEBubbleTrail::set_allocated_maxs(::proto::dota::CMsgVector* maxs) {
  delete maxs_;
  maxs_ = maxs;
  if (maxs) {
    set_has_maxs();
  } else {
    clear_has_maxs();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBubbleTrail.maxs)
}

// optional float waterz = 3;
inline bool CMsgTEBubbleTrail::has_waterz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBubbleTrail::set_has_waterz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBubbleTrail::clear_has_waterz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBubbleTrail::clear_waterz() {
  waterz_ = 0;
  clear_has_waterz();
}
inline float CMsgTEBubbleTrail::waterz() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbleTrail.waterz)
  return waterz_;
}
inline void CMsgTEBubbleTrail::set_waterz(float value) {
  set_has_waterz();
  waterz_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBubbleTrail.waterz)
}

// optional uint32 count = 4;
inline bool CMsgTEBubbleTrail::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBubbleTrail::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBubbleTrail::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBubbleTrail::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgTEBubbleTrail::count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbleTrail.count)
  return count_;
}
inline void CMsgTEBubbleTrail::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBubbleTrail.count)
}

// optional float speed = 5;
inline bool CMsgTEBubbleTrail::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEBubbleTrail::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEBubbleTrail::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEBubbleTrail::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float CMsgTEBubbleTrail::speed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBubbleTrail.speed)
  return speed_;
}
inline void CMsgTEBubbleTrail::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBubbleTrail.speed)
}

// -------------------------------------------------------------------

// CMsgTEDecal

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEDecal::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEDecal::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDecal.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEDecal.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEDecal::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEDecal.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEDecal::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEDecal.origin)
}

// optional .proto.dota.CMsgVector start = 2;
inline bool CMsgTEDecal::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEDecal::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEDecal::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEDecal::clear_start() {
  if (start_ != NULL) start_->::proto::dota::CMsgVector::Clear();
  clear_has_start();
}
inline const ::proto::dota::CMsgVector& CMsgTEDecal::start() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDecal.start)
  return start_ != NULL ? *start_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEDecal::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEDecal.start)
  return start_;
}
inline ::proto::dota::CMsgVector* CMsgTEDecal::release_start() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEDecal.start)
  clear_has_start();
  ::proto::dota::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
inline void CMsgTEDecal::set_allocated_start(::proto::dota::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEDecal.start)
}

// optional uint32 entity = 3;
inline bool CMsgTEDecal::has_entity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEDecal::set_has_entity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEDecal::clear_has_entity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEDecal::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
inline ::google::protobuf::uint32 CMsgTEDecal::entity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDecal.entity)
  return entity_;
}
inline void CMsgTEDecal::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEDecal.entity)
}

// optional uint32 hitbox = 4;
inline bool CMsgTEDecal::has_hitbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEDecal::set_has_hitbox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEDecal::clear_has_hitbox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEDecal::clear_hitbox() {
  hitbox_ = 0u;
  clear_has_hitbox();
}
inline ::google::protobuf::uint32 CMsgTEDecal::hitbox() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDecal.hitbox)
  return hitbox_;
}
inline void CMsgTEDecal::set_hitbox(::google::protobuf::uint32 value) {
  set_has_hitbox();
  hitbox_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEDecal.hitbox)
}

// optional uint32 index = 5;
inline bool CMsgTEDecal::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEDecal::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CMsgTEDecal::index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDecal.index)
  return index_;
}
inline void CMsgTEDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEDecal.index)
}

// -------------------------------------------------------------------

// CMsgEffectData

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgEffectData::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgEffectData::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgEffectData::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgEffectData::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgEffectData::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgEffectData::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEffectData.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgEffectData::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEffectData.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgEffectData::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEffectData.origin)
}

// optional .proto.dota.CMsgVector start = 2;
inline bool CMsgEffectData::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgEffectData::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgEffectData::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgEffectData::clear_start() {
  if (start_ != NULL) start_->::proto::dota::CMsgVector::Clear();
  clear_has_start();
}
inline const ::proto::dota::CMsgVector& CMsgEffectData::start() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.start)
  return start_ != NULL ? *start_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgEffectData::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEffectData.start)
  return start_;
}
inline ::proto::dota::CMsgVector* CMsgEffectData::release_start() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEffectData.start)
  clear_has_start();
  ::proto::dota::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
inline void CMsgEffectData::set_allocated_start(::proto::dota::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEffectData.start)
}

// optional .proto.dota.CMsgVector normal = 3;
inline bool CMsgEffectData::has_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgEffectData::set_has_normal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgEffectData::clear_has_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgEffectData::clear_normal() {
  if (normal_ != NULL) normal_->::proto::dota::CMsgVector::Clear();
  clear_has_normal();
}
inline const ::proto::dota::CMsgVector& CMsgEffectData::normal() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.normal)
  return normal_ != NULL ? *normal_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgEffectData::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEffectData.normal)
  return normal_;
}
inline ::proto::dota::CMsgVector* CMsgEffectData::release_normal() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEffectData.normal)
  clear_has_normal();
  ::proto::dota::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void CMsgEffectData::set_allocated_normal(::proto::dota::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEffectData.normal)
}

// optional .proto.dota.CMsgQAngle angles = 4;
inline bool CMsgEffectData::has_angles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgEffectData::set_has_angles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgEffectData::clear_has_angles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgEffectData::clear_angles() {
  if (angles_ != NULL) angles_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angles();
}
inline const ::proto::dota::CMsgQAngle& CMsgEffectData::angles() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.angles)
  return angles_ != NULL ? *angles_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CMsgEffectData::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEffectData.angles)
  return angles_;
}
inline ::proto::dota::CMsgQAngle* CMsgEffectData::release_angles() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEffectData.angles)
  clear_has_angles();
  ::proto::dota::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void CMsgEffectData::set_allocated_angles(::proto::dota::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEffectData.angles)
}

// optional fixed32 entity = 5;
inline bool CMsgEffectData::has_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgEffectData::set_has_entity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgEffectData::clear_has_entity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgEffectData::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
inline ::google::protobuf::uint32 CMsgEffectData::entity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.entity)
  return entity_;
}
inline void CMsgEffectData::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.entity)
}

// optional fixed32 otherentity = 6;
inline bool CMsgEffectData::has_otherentity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgEffectData::set_has_otherentity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgEffectData::clear_has_otherentity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgEffectData::clear_otherentity() {
  otherentity_ = 0u;
  clear_has_otherentity();
}
inline ::google::protobuf::uint32 CMsgEffectData::otherentity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.otherentity)
  return otherentity_;
}
inline void CMsgEffectData::set_otherentity(::google::protobuf::uint32 value) {
  set_has_otherentity();
  otherentity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.otherentity)
}

// optional float scale = 7;
inline bool CMsgEffectData::has_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgEffectData::set_has_scale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgEffectData::clear_has_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgEffectData::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float CMsgEffectData::scale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.scale)
  return scale_;
}
inline void CMsgEffectData::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.scale)
}

// optional float magnitude = 8;
inline bool CMsgEffectData::has_magnitude() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgEffectData::set_has_magnitude() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgEffectData::clear_has_magnitude() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgEffectData::clear_magnitude() {
  magnitude_ = 0;
  clear_has_magnitude();
}
inline float CMsgEffectData::magnitude() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.magnitude)
  return magnitude_;
}
inline void CMsgEffectData::set_magnitude(float value) {
  set_has_magnitude();
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.magnitude)
}

// optional float radius = 9;
inline bool CMsgEffectData::has_radius() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgEffectData::set_has_radius() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgEffectData::clear_has_radius() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgEffectData::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CMsgEffectData::radius() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.radius)
  return radius_;
}
inline void CMsgEffectData::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.radius)
}

// optional fixed32 surfaceprop = 10;
inline bool CMsgEffectData::has_surfaceprop() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgEffectData::set_has_surfaceprop() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgEffectData::clear_has_surfaceprop() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgEffectData::clear_surfaceprop() {
  surfaceprop_ = 0u;
  clear_has_surfaceprop();
}
inline ::google::protobuf::uint32 CMsgEffectData::surfaceprop() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.surfaceprop)
  return surfaceprop_;
}
inline void CMsgEffectData::set_surfaceprop(::google::protobuf::uint32 value) {
  set_has_surfaceprop();
  surfaceprop_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.surfaceprop)
}

// optional fixed64 effectindex = 11;
inline bool CMsgEffectData::has_effectindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgEffectData::set_has_effectindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgEffectData::clear_has_effectindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgEffectData::clear_effectindex() {
  effectindex_ = GOOGLE_ULONGLONG(0);
  clear_has_effectindex();
}
inline ::google::protobuf::uint64 CMsgEffectData::effectindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.effectindex)
  return effectindex_;
}
inline void CMsgEffectData::set_effectindex(::google::protobuf::uint64 value) {
  set_has_effectindex();
  effectindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.effectindex)
}

// optional uint32 damagetype = 12;
inline bool CMsgEffectData::has_damagetype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgEffectData::set_has_damagetype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgEffectData::clear_has_damagetype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgEffectData::clear_damagetype() {
  damagetype_ = 0u;
  clear_has_damagetype();
}
inline ::google::protobuf::uint32 CMsgEffectData::damagetype() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.damagetype)
  return damagetype_;
}
inline void CMsgEffectData::set_damagetype(::google::protobuf::uint32 value) {
  set_has_damagetype();
  damagetype_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.damagetype)
}

// optional uint32 material = 13;
inline bool CMsgEffectData::has_material() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgEffectData::set_has_material() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgEffectData::clear_has_material() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgEffectData::clear_material() {
  material_ = 0u;
  clear_has_material();
}
inline ::google::protobuf::uint32 CMsgEffectData::material() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.material)
  return material_;
}
inline void CMsgEffectData::set_material(::google::protobuf::uint32 value) {
  set_has_material();
  material_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.material)
}

// optional uint32 hitbox = 14;
inline bool CMsgEffectData::has_hitbox() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgEffectData::set_has_hitbox() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgEffectData::clear_has_hitbox() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgEffectData::clear_hitbox() {
  hitbox_ = 0u;
  clear_has_hitbox();
}
inline ::google::protobuf::uint32 CMsgEffectData::hitbox() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.hitbox)
  return hitbox_;
}
inline void CMsgEffectData::set_hitbox(::google::protobuf::uint32 value) {
  set_has_hitbox();
  hitbox_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.hitbox)
}

// optional uint32 color = 15;
inline bool CMsgEffectData::has_color() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgEffectData::set_has_color() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgEffectData::clear_has_color() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgEffectData::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CMsgEffectData::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.color)
  return color_;
}
inline void CMsgEffectData::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.color)
}

// optional uint32 flags = 16;
inline bool CMsgEffectData::has_flags() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgEffectData::set_has_flags() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgEffectData::clear_has_flags() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgEffectData::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgEffectData::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.flags)
  return flags_;
}
inline void CMsgEffectData::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.flags)
}

// optional int32 attachmentindex = 17;
inline bool CMsgEffectData::has_attachmentindex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgEffectData::set_has_attachmentindex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgEffectData::clear_has_attachmentindex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgEffectData::clear_attachmentindex() {
  attachmentindex_ = 0;
  clear_has_attachmentindex();
}
inline ::google::protobuf::int32 CMsgEffectData::attachmentindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.attachmentindex)
  return attachmentindex_;
}
inline void CMsgEffectData::set_attachmentindex(::google::protobuf::int32 value) {
  set_has_attachmentindex();
  attachmentindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.attachmentindex)
}

// optional uint32 effectname = 18;
inline bool CMsgEffectData::has_effectname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgEffectData::set_has_effectname() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgEffectData::clear_has_effectname() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgEffectData::clear_effectname() {
  effectname_ = 0u;
  clear_has_effectname();
}
inline ::google::protobuf::uint32 CMsgEffectData::effectname() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.effectname)
  return effectname_;
}
inline void CMsgEffectData::set_effectname(::google::protobuf::uint32 value) {
  set_has_effectname();
  effectname_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.effectname)
}

// optional uint32 attachmentname = 19;
inline bool CMsgEffectData::has_attachmentname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgEffectData::set_has_attachmentname() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgEffectData::clear_has_attachmentname() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgEffectData::clear_attachmentname() {
  attachmentname_ = 0u;
  clear_has_attachmentname();
}
inline ::google::protobuf::uint32 CMsgEffectData::attachmentname() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEffectData.attachmentname)
  return attachmentname_;
}
inline void CMsgEffectData::set_attachmentname(::google::protobuf::uint32 value) {
  set_has_attachmentname();
  attachmentname_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEffectData.attachmentname)
}

// -------------------------------------------------------------------

// CMsgTEEffectDispatch

// optional .proto.dota.CMsgEffectData effectdata = 1;
inline bool CMsgTEEffectDispatch::has_effectdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEEffectDispatch::set_has_effectdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEEffectDispatch::clear_has_effectdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEEffectDispatch::clear_effectdata() {
  if (effectdata_ != NULL) effectdata_->::proto::dota::CMsgEffectData::Clear();
  clear_has_effectdata();
}
inline const ::proto::dota::CMsgEffectData& CMsgTEEffectDispatch::effectdata() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEEffectDispatch.effectdata)
  return effectdata_ != NULL ? *effectdata_
                         : *::proto::dota::CMsgEffectData::internal_default_instance();
}
inline ::proto::dota::CMsgEffectData* CMsgTEEffectDispatch::mutable_effectdata() {
  set_has_effectdata();
  if (effectdata_ == NULL) {
    effectdata_ = new ::proto::dota::CMsgEffectData;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEEffectDispatch.effectdata)
  return effectdata_;
}
inline ::proto::dota::CMsgEffectData* CMsgTEEffectDispatch::release_effectdata() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEEffectDispatch.effectdata)
  clear_has_effectdata();
  ::proto::dota::CMsgEffectData* temp = effectdata_;
  effectdata_ = NULL;
  return temp;
}
inline void CMsgTEEffectDispatch::set_allocated_effectdata(::proto::dota::CMsgEffectData* effectdata) {
  delete effectdata_;
  effectdata_ = effectdata;
  if (effectdata) {
    set_has_effectdata();
  } else {
    clear_has_effectdata();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEEffectDispatch.effectdata)
}

// -------------------------------------------------------------------

// CMsgTEEnergySplash

// optional .proto.dota.CMsgVector pos = 1;
inline bool CMsgTEEnergySplash::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEEnergySplash::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEEnergySplash::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEEnergySplash::clear_pos() {
  if (pos_ != NULL) pos_->::proto::dota::CMsgVector::Clear();
  clear_has_pos();
}
inline const ::proto::dota::CMsgVector& CMsgTEEnergySplash::pos() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEEnergySplash.pos)
  return pos_ != NULL ? *pos_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEEnergySplash::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEEnergySplash.pos)
  return pos_;
}
inline ::proto::dota::CMsgVector* CMsgTEEnergySplash::release_pos() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEEnergySplash.pos)
  clear_has_pos();
  ::proto::dota::CMsgVector* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void CMsgTEEnergySplash::set_allocated_pos(::proto::dota::CMsgVector* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEEnergySplash.pos)
}

// optional .proto.dota.CMsgVector dir = 2;
inline bool CMsgTEEnergySplash::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEEnergySplash::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEEnergySplash::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEEnergySplash::clear_dir() {
  if (dir_ != NULL) dir_->::proto::dota::CMsgVector::Clear();
  clear_has_dir();
}
inline const ::proto::dota::CMsgVector& CMsgTEEnergySplash::dir() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEEnergySplash.dir)
  return dir_ != NULL ? *dir_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEEnergySplash::mutable_dir() {
  set_has_dir();
  if (dir_ == NULL) {
    dir_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEEnergySplash.dir)
  return dir_;
}
inline ::proto::dota::CMsgVector* CMsgTEEnergySplash::release_dir() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEEnergySplash.dir)
  clear_has_dir();
  ::proto::dota::CMsgVector* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline void CMsgTEEnergySplash::set_allocated_dir(::proto::dota::CMsgVector* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    set_has_dir();
  } else {
    clear_has_dir();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEEnergySplash.dir)
}

// optional bool explosive = 3;
inline bool CMsgTEEnergySplash::has_explosive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEEnergySplash::set_has_explosive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEEnergySplash::clear_has_explosive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEEnergySplash::clear_explosive() {
  explosive_ = false;
  clear_has_explosive();
}
inline bool CMsgTEEnergySplash::explosive() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEEnergySplash.explosive)
  return explosive_;
}
inline void CMsgTEEnergySplash::set_explosive(bool value) {
  set_has_explosive();
  explosive_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEEnergySplash.explosive)
}

// -------------------------------------------------------------------

// CMsgTEFizz

// optional uint32 entity = 1;
inline bool CMsgTEFizz::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEFizz::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEFizz::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEFizz::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
inline ::google::protobuf::uint32 CMsgTEFizz::entity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEFizz.entity)
  return entity_;
}
inline void CMsgTEFizz::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEFizz.entity)
}

// optional uint32 density = 2;
inline bool CMsgTEFizz::has_density() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEFizz::set_has_density() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEFizz::clear_has_density() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEFizz::clear_density() {
  density_ = 0u;
  clear_has_density();
}
inline ::google::protobuf::uint32 CMsgTEFizz::density() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEFizz.density)
  return density_;
}
inline void CMsgTEFizz::set_density(::google::protobuf::uint32 value) {
  set_has_density();
  density_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEFizz.density)
}

// optional int32 current = 3;
inline bool CMsgTEFizz::has_current() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEFizz::set_has_current() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEFizz::clear_has_current() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEFizz::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline ::google::protobuf::int32 CMsgTEFizz::current() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEFizz.current)
  return current_;
}
inline void CMsgTEFizz::set_current(::google::protobuf::int32 value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEFizz.current)
}

// -------------------------------------------------------------------

// CMsgTEShatterSurface

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEShatterSurface::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEShatterSurface::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEShatterSurface::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEShatterSurface::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEShatterSurface::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEShatterSurface::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEShatterSurface.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEShatterSurface::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEShatterSurface.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEShatterSurface::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEShatterSurface.origin)
}

// optional .proto.dota.CMsgQAngle angles = 2;
inline bool CMsgTEShatterSurface::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEShatterSurface::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEShatterSurface::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEShatterSurface::clear_angles() {
  if (angles_ != NULL) angles_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angles();
}
inline const ::proto::dota::CMsgQAngle& CMsgTEShatterSurface::angles() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.angles)
  return angles_ != NULL ? *angles_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CMsgTEShatterSurface::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEShatterSurface.angles)
  return angles_;
}
inline ::proto::dota::CMsgQAngle* CMsgTEShatterSurface::release_angles() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEShatterSurface.angles)
  clear_has_angles();
  ::proto::dota::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void CMsgTEShatterSurface::set_allocated_angles(::proto::dota::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEShatterSurface.angles)
}

// optional .proto.dota.CMsgVector force = 3;
inline bool CMsgTEShatterSurface::has_force() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEShatterSurface::set_has_force() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEShatterSurface::clear_has_force() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEShatterSurface::clear_force() {
  if (force_ != NULL) force_->::proto::dota::CMsgVector::Clear();
  clear_has_force();
}
inline const ::proto::dota::CMsgVector& CMsgTEShatterSurface::force() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.force)
  return force_ != NULL ? *force_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEShatterSurface::mutable_force() {
  set_has_force();
  if (force_ == NULL) {
    force_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEShatterSurface.force)
  return force_;
}
inline ::proto::dota::CMsgVector* CMsgTEShatterSurface::release_force() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEShatterSurface.force)
  clear_has_force();
  ::proto::dota::CMsgVector* temp = force_;
  force_ = NULL;
  return temp;
}
inline void CMsgTEShatterSurface::set_allocated_force(::proto::dota::CMsgVector* force) {
  delete force_;
  force_ = force;
  if (force) {
    set_has_force();
  } else {
    clear_has_force();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEShatterSurface.force)
}

// optional .proto.dota.CMsgVector forcepos = 4;
inline bool CMsgTEShatterSurface::has_forcepos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEShatterSurface::set_has_forcepos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEShatterSurface::clear_has_forcepos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEShatterSurface::clear_forcepos() {
  if (forcepos_ != NULL) forcepos_->::proto::dota::CMsgVector::Clear();
  clear_has_forcepos();
}
inline const ::proto::dota::CMsgVector& CMsgTEShatterSurface::forcepos() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.forcepos)
  return forcepos_ != NULL ? *forcepos_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEShatterSurface::mutable_forcepos() {
  set_has_forcepos();
  if (forcepos_ == NULL) {
    forcepos_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEShatterSurface.forcepos)
  return forcepos_;
}
inline ::proto::dota::CMsgVector* CMsgTEShatterSurface::release_forcepos() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEShatterSurface.forcepos)
  clear_has_forcepos();
  ::proto::dota::CMsgVector* temp = forcepos_;
  forcepos_ = NULL;
  return temp;
}
inline void CMsgTEShatterSurface::set_allocated_forcepos(::proto::dota::CMsgVector* forcepos) {
  delete forcepos_;
  forcepos_ = forcepos;
  if (forcepos) {
    set_has_forcepos();
  } else {
    clear_has_forcepos();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEShatterSurface.forcepos)
}

// optional float width = 5;
inline bool CMsgTEShatterSurface::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEShatterSurface::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEShatterSurface::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEShatterSurface::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float CMsgTEShatterSurface::width() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.width)
  return width_;
}
inline void CMsgTEShatterSurface::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEShatterSurface.width)
}

// optional float height = 6;
inline bool CMsgTEShatterSurface::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgTEShatterSurface::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgTEShatterSurface::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgTEShatterSurface::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float CMsgTEShatterSurface::height() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.height)
  return height_;
}
inline void CMsgTEShatterSurface::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEShatterSurface.height)
}

// optional float shardsize = 7;
inline bool CMsgTEShatterSurface::has_shardsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgTEShatterSurface::set_has_shardsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgTEShatterSurface::clear_has_shardsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgTEShatterSurface::clear_shardsize() {
  shardsize_ = 0;
  clear_has_shardsize();
}
inline float CMsgTEShatterSurface::shardsize() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.shardsize)
  return shardsize_;
}
inline void CMsgTEShatterSurface::set_shardsize(float value) {
  set_has_shardsize();
  shardsize_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEShatterSurface.shardsize)
}

// optional uint32 surfacetype = 8;
inline bool CMsgTEShatterSurface::has_surfacetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgTEShatterSurface::set_has_surfacetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgTEShatterSurface::clear_has_surfacetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgTEShatterSurface::clear_surfacetype() {
  surfacetype_ = 0u;
  clear_has_surfacetype();
}
inline ::google::protobuf::uint32 CMsgTEShatterSurface::surfacetype() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.surfacetype)
  return surfacetype_;
}
inline void CMsgTEShatterSurface::set_surfacetype(::google::protobuf::uint32 value) {
  set_has_surfacetype();
  surfacetype_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEShatterSurface.surfacetype)
}

// optional fixed32 frontcolor = 9;
inline bool CMsgTEShatterSurface::has_frontcolor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgTEShatterSurface::set_has_frontcolor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgTEShatterSurface::clear_has_frontcolor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgTEShatterSurface::clear_frontcolor() {
  frontcolor_ = 0u;
  clear_has_frontcolor();
}
inline ::google::protobuf::uint32 CMsgTEShatterSurface::frontcolor() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.frontcolor)
  return frontcolor_;
}
inline void CMsgTEShatterSurface::set_frontcolor(::google::protobuf::uint32 value) {
  set_has_frontcolor();
  frontcolor_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEShatterSurface.frontcolor)
}

// optional fixed32 backcolor = 10;
inline bool CMsgTEShatterSurface::has_backcolor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgTEShatterSurface::set_has_backcolor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgTEShatterSurface::clear_has_backcolor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgTEShatterSurface::clear_backcolor() {
  backcolor_ = 0u;
  clear_has_backcolor();
}
inline ::google::protobuf::uint32 CMsgTEShatterSurface::backcolor() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEShatterSurface.backcolor)
  return backcolor_;
}
inline void CMsgTEShatterSurface::set_backcolor(::google::protobuf::uint32 value) {
  set_has_backcolor();
  backcolor_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEShatterSurface.backcolor)
}

// -------------------------------------------------------------------

// CMsgTEGlowSprite

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEGlowSprite::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEGlowSprite::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEGlowSprite::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEGlowSprite::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEGlowSprite::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEGlowSprite.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEGlowSprite::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEGlowSprite.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEGlowSprite::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEGlowSprite.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEGlowSprite::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEGlowSprite.origin)
}

// optional float scale = 2;
inline bool CMsgTEGlowSprite::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEGlowSprite::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEGlowSprite::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEGlowSprite::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float CMsgTEGlowSprite::scale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEGlowSprite.scale)
  return scale_;
}
inline void CMsgTEGlowSprite::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEGlowSprite.scale)
}

// optional float life = 3;
inline bool CMsgTEGlowSprite::has_life() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEGlowSprite::set_has_life() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEGlowSprite::clear_has_life() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEGlowSprite::clear_life() {
  life_ = 0;
  clear_has_life();
}
inline float CMsgTEGlowSprite::life() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEGlowSprite.life)
  return life_;
}
inline void CMsgTEGlowSprite::set_life(float value) {
  set_has_life();
  life_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEGlowSprite.life)
}

// optional uint32 brightness = 4;
inline bool CMsgTEGlowSprite::has_brightness() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEGlowSprite::set_has_brightness() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEGlowSprite::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEGlowSprite::clear_brightness() {
  brightness_ = 0u;
  clear_has_brightness();
}
inline ::google::protobuf::uint32 CMsgTEGlowSprite::brightness() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEGlowSprite.brightness)
  return brightness_;
}
inline void CMsgTEGlowSprite::set_brightness(::google::protobuf::uint32 value) {
  set_has_brightness();
  brightness_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEGlowSprite.brightness)
}

// -------------------------------------------------------------------

// CMsgTEImpact

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEImpact::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEImpact::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEImpact::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEImpact::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEImpact::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEImpact.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEImpact::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEImpact.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEImpact::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEImpact.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEImpact::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEImpact.origin)
}

// optional .proto.dota.CMsgVector normal = 2;
inline bool CMsgTEImpact::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEImpact::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEImpact::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEImpact::clear_normal() {
  if (normal_ != NULL) normal_->::proto::dota::CMsgVector::Clear();
  clear_has_normal();
}
inline const ::proto::dota::CMsgVector& CMsgTEImpact::normal() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEImpact.normal)
  return normal_ != NULL ? *normal_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEImpact::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEImpact.normal)
  return normal_;
}
inline ::proto::dota::CMsgVector* CMsgTEImpact::release_normal() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEImpact.normal)
  clear_has_normal();
  ::proto::dota::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void CMsgTEImpact::set_allocated_normal(::proto::dota::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEImpact.normal)
}

// optional uint32 type = 3;
inline bool CMsgTEImpact::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEImpact::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEImpact::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEImpact::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CMsgTEImpact::type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEImpact.type)
  return type_;
}
inline void CMsgTEImpact::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEImpact.type)
}

// -------------------------------------------------------------------

// CMsgTEMuzzleFlash

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEMuzzleFlash::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEMuzzleFlash::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEMuzzleFlash::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEMuzzleFlash::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEMuzzleFlash::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEMuzzleFlash.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEMuzzleFlash::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEMuzzleFlash.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEMuzzleFlash::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEMuzzleFlash.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEMuzzleFlash::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEMuzzleFlash.origin)
}

// optional .proto.dota.CMsgQAngle angles = 2;
inline bool CMsgTEMuzzleFlash::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEMuzzleFlash::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEMuzzleFlash::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEMuzzleFlash::clear_angles() {
  if (angles_ != NULL) angles_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angles();
}
inline const ::proto::dota::CMsgQAngle& CMsgTEMuzzleFlash::angles() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEMuzzleFlash.angles)
  return angles_ != NULL ? *angles_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CMsgTEMuzzleFlash::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEMuzzleFlash.angles)
  return angles_;
}
inline ::proto::dota::CMsgQAngle* CMsgTEMuzzleFlash::release_angles() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEMuzzleFlash.angles)
  clear_has_angles();
  ::proto::dota::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void CMsgTEMuzzleFlash::set_allocated_angles(::proto::dota::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEMuzzleFlash.angles)
}

// optional float scale = 3;
inline bool CMsgTEMuzzleFlash::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEMuzzleFlash::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEMuzzleFlash::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEMuzzleFlash::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float CMsgTEMuzzleFlash::scale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEMuzzleFlash.scale)
  return scale_;
}
inline void CMsgTEMuzzleFlash::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEMuzzleFlash.scale)
}

// optional uint32 type = 4;
inline bool CMsgTEMuzzleFlash::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEMuzzleFlash::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEMuzzleFlash::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEMuzzleFlash::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CMsgTEMuzzleFlash::type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEMuzzleFlash.type)
  return type_;
}
inline void CMsgTEMuzzleFlash::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEMuzzleFlash.type)
}

// -------------------------------------------------------------------

// CMsgTEBloodStream

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEBloodStream::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEBloodStream::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEBloodStream::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEBloodStream::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEBloodStream::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBloodStream.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBloodStream::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBloodStream.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEBloodStream::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBloodStream.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEBloodStream::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBloodStream.origin)
}

// optional .proto.dota.CMsgVector direction = 2;
inline bool CMsgTEBloodStream::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEBloodStream::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEBloodStream::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEBloodStream::clear_direction() {
  if (direction_ != NULL) direction_->::proto::dota::CMsgVector::Clear();
  clear_has_direction();
}
inline const ::proto::dota::CMsgVector& CMsgTEBloodStream::direction() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBloodStream.direction)
  return direction_ != NULL ? *direction_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEBloodStream::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEBloodStream.direction)
  return direction_;
}
inline ::proto::dota::CMsgVector* CMsgTEBloodStream::release_direction() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEBloodStream.direction)
  clear_has_direction();
  ::proto::dota::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void CMsgTEBloodStream::set_allocated_direction(::proto::dota::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEBloodStream.direction)
}

// optional fixed32 color = 3;
inline bool CMsgTEBloodStream::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEBloodStream::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEBloodStream::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEBloodStream::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CMsgTEBloodStream::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBloodStream.color)
  return color_;
}
inline void CMsgTEBloodStream::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBloodStream.color)
}

// optional uint32 amount = 4;
inline bool CMsgTEBloodStream::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEBloodStream::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEBloodStream::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEBloodStream::clear_amount() {
  amount_ = 0u;
  clear_has_amount();
}
inline ::google::protobuf::uint32 CMsgTEBloodStream::amount() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEBloodStream.amount)
  return amount_;
}
inline void CMsgTEBloodStream::set_amount(::google::protobuf::uint32 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEBloodStream.amount)
}

// -------------------------------------------------------------------

// CMsgTEExplosion

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEExplosion::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEExplosion::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEExplosion::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEExplosion::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEExplosion::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEExplosion::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEExplosion.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEExplosion::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEExplosion.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEExplosion::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEExplosion.origin)
}

// optional uint32 framerate = 2;
inline bool CMsgTEExplosion::has_framerate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEExplosion::set_has_framerate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEExplosion::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEExplosion::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 CMsgTEExplosion::framerate() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.framerate)
  return framerate_;
}
inline void CMsgTEExplosion::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.framerate)
}

// optional uint32 flags = 3;
inline bool CMsgTEExplosion::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEExplosion::set_has_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEExplosion::clear_has_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEExplosion::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgTEExplosion::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.flags)
  return flags_;
}
inline void CMsgTEExplosion::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.flags)
}

// optional .proto.dota.CMsgVector normal = 4;
inline bool CMsgTEExplosion::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEExplosion::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEExplosion::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEExplosion::clear_normal() {
  if (normal_ != NULL) normal_->::proto::dota::CMsgVector::Clear();
  clear_has_normal();
}
inline const ::proto::dota::CMsgVector& CMsgTEExplosion::normal() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.normal)
  return normal_ != NULL ? *normal_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEExplosion::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEExplosion.normal)
  return normal_;
}
inline ::proto::dota::CMsgVector* CMsgTEExplosion::release_normal() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEExplosion.normal)
  clear_has_normal();
  ::proto::dota::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void CMsgTEExplosion::set_allocated_normal(::proto::dota::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEExplosion.normal)
}

// optional uint32 materialtype = 5;
inline bool CMsgTEExplosion::has_materialtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEExplosion::set_has_materialtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEExplosion::clear_has_materialtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEExplosion::clear_materialtype() {
  materialtype_ = 0u;
  clear_has_materialtype();
}
inline ::google::protobuf::uint32 CMsgTEExplosion::materialtype() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.materialtype)
  return materialtype_;
}
inline void CMsgTEExplosion::set_materialtype(::google::protobuf::uint32 value) {
  set_has_materialtype();
  materialtype_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.materialtype)
}

// optional uint32 radius = 6;
inline bool CMsgTEExplosion::has_radius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgTEExplosion::set_has_radius() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgTEExplosion::clear_has_radius() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgTEExplosion::clear_radius() {
  radius_ = 0u;
  clear_has_radius();
}
inline ::google::protobuf::uint32 CMsgTEExplosion::radius() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.radius)
  return radius_;
}
inline void CMsgTEExplosion::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.radius)
}

// optional uint32 magnitude = 7;
inline bool CMsgTEExplosion::has_magnitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgTEExplosion::set_has_magnitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgTEExplosion::clear_has_magnitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgTEExplosion::clear_magnitude() {
  magnitude_ = 0u;
  clear_has_magnitude();
}
inline ::google::protobuf::uint32 CMsgTEExplosion::magnitude() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.magnitude)
  return magnitude_;
}
inline void CMsgTEExplosion::set_magnitude(::google::protobuf::uint32 value) {
  set_has_magnitude();
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.magnitude)
}

// optional float scale = 8;
inline bool CMsgTEExplosion::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgTEExplosion::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgTEExplosion::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgTEExplosion::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float CMsgTEExplosion::scale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.scale)
  return scale_;
}
inline void CMsgTEExplosion::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.scale)
}

// optional bool affect_ragdolls = 9;
inline bool CMsgTEExplosion::has_affect_ragdolls() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgTEExplosion::set_has_affect_ragdolls() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgTEExplosion::clear_has_affect_ragdolls() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgTEExplosion::clear_affect_ragdolls() {
  affect_ragdolls_ = false;
  clear_has_affect_ragdolls();
}
inline bool CMsgTEExplosion::affect_ragdolls() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEExplosion.affect_ragdolls)
  return affect_ragdolls_;
}
inline void CMsgTEExplosion::set_affect_ragdolls(bool value) {
  set_has_affect_ragdolls();
  affect_ragdolls_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEExplosion.affect_ragdolls)
}

// -------------------------------------------------------------------

// CMsgTEDust

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEDust::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEDust::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEDust::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEDust::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEDust::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDust.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEDust::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEDust.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEDust::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEDust.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEDust::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEDust.origin)
}

// optional float size = 2;
inline bool CMsgTEDust::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEDust::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEDust::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEDust::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float CMsgTEDust::size() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDust.size)
  return size_;
}
inline void CMsgTEDust::set_size(float value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEDust.size)
}

// optional float speed = 3;
inline bool CMsgTEDust::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEDust::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEDust::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEDust::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float CMsgTEDust::speed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDust.speed)
  return speed_;
}
inline void CMsgTEDust::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEDust.speed)
}

// optional .proto.dota.CMsgVector direction = 4;
inline bool CMsgTEDust::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEDust::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEDust::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEDust::clear_direction() {
  if (direction_ != NULL) direction_->::proto::dota::CMsgVector::Clear();
  clear_has_direction();
}
inline const ::proto::dota::CMsgVector& CMsgTEDust::direction() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEDust.direction)
  return direction_ != NULL ? *direction_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEDust::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEDust.direction)
  return direction_;
}
inline ::proto::dota::CMsgVector* CMsgTEDust::release_direction() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEDust.direction)
  clear_has_direction();
  ::proto::dota::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void CMsgTEDust::set_allocated_direction(::proto::dota::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEDust.direction)
}

// -------------------------------------------------------------------

// CMsgTELargeFunnel

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTELargeFunnel::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTELargeFunnel::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTELargeFunnel::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTELargeFunnel::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTELargeFunnel::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTELargeFunnel.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTELargeFunnel::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTELargeFunnel.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTELargeFunnel::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTELargeFunnel.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTELargeFunnel::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTELargeFunnel.origin)
}

// optional uint32 reversed = 2;
inline bool CMsgTELargeFunnel::has_reversed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTELargeFunnel::set_has_reversed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTELargeFunnel::clear_has_reversed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTELargeFunnel::clear_reversed() {
  reversed_ = 0u;
  clear_has_reversed();
}
inline ::google::protobuf::uint32 CMsgTELargeFunnel::reversed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTELargeFunnel.reversed)
  return reversed_;
}
inline void CMsgTELargeFunnel::set_reversed(::google::protobuf::uint32 value) {
  set_has_reversed();
  reversed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTELargeFunnel.reversed)
}

// -------------------------------------------------------------------

// CMsgTESparks

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTESparks::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTESparks::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTESparks::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTESparks::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTESparks::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTESparks.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTESparks::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTESparks.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTESparks::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTESparks.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTESparks::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTESparks.origin)
}

// optional uint32 magnitude = 2;
inline bool CMsgTESparks::has_magnitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTESparks::set_has_magnitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTESparks::clear_has_magnitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTESparks::clear_magnitude() {
  magnitude_ = 0u;
  clear_has_magnitude();
}
inline ::google::protobuf::uint32 CMsgTESparks::magnitude() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTESparks.magnitude)
  return magnitude_;
}
inline void CMsgTESparks::set_magnitude(::google::protobuf::uint32 value) {
  set_has_magnitude();
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTESparks.magnitude)
}

// optional uint32 length = 3;
inline bool CMsgTESparks::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTESparks::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTESparks::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTESparks::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 CMsgTESparks::length() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTESparks.length)
  return length_;
}
inline void CMsgTESparks::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTESparks.length)
}

// optional .proto.dota.CMsgVector direction = 4;
inline bool CMsgTESparks::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTESparks::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTESparks::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTESparks::clear_direction() {
  if (direction_ != NULL) direction_->::proto::dota::CMsgVector::Clear();
  clear_has_direction();
}
inline const ::proto::dota::CMsgVector& CMsgTESparks::direction() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTESparks.direction)
  return direction_ != NULL ? *direction_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTESparks::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTESparks.direction)
  return direction_;
}
inline ::proto::dota::CMsgVector* CMsgTESparks::release_direction() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTESparks.direction)
  clear_has_direction();
  ::proto::dota::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void CMsgTESparks::set_allocated_direction(::proto::dota::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTESparks.direction)
}

// -------------------------------------------------------------------

// CMsgTEPhysicsProp

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEPhysicsProp::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEPhysicsProp::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEPhysicsProp::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEPhysicsProp::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEPhysicsProp::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEPhysicsProp.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEPhysicsProp::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEPhysicsProp.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEPhysicsProp::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEPhysicsProp.origin)
}

// optional .proto.dota.CMsgVector velocity = 2;
inline bool CMsgTEPhysicsProp::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEPhysicsProp::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEPhysicsProp::clear_velocity() {
  if (velocity_ != NULL) velocity_->::proto::dota::CMsgVector::Clear();
  clear_has_velocity();
}
inline const ::proto::dota::CMsgVector& CMsgTEPhysicsProp::velocity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.velocity)
  return velocity_ != NULL ? *velocity_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEPhysicsProp::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEPhysicsProp.velocity)
  return velocity_;
}
inline ::proto::dota::CMsgVector* CMsgTEPhysicsProp::release_velocity() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEPhysicsProp.velocity)
  clear_has_velocity();
  ::proto::dota::CMsgVector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void CMsgTEPhysicsProp::set_allocated_velocity(::proto::dota::CMsgVector* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEPhysicsProp.velocity)
}

// optional .proto.dota.CMsgQAngle angles = 3;
inline bool CMsgTEPhysicsProp::has_angles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_angles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEPhysicsProp::clear_has_angles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEPhysicsProp::clear_angles() {
  if (angles_ != NULL) angles_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angles();
}
inline const ::proto::dota::CMsgQAngle& CMsgTEPhysicsProp::angles() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.angles)
  return angles_ != NULL ? *angles_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CMsgTEPhysicsProp::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEPhysicsProp.angles)
  return angles_;
}
inline ::proto::dota::CMsgQAngle* CMsgTEPhysicsProp::release_angles() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEPhysicsProp.angles)
  clear_has_angles();
  ::proto::dota::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void CMsgTEPhysicsProp::set_allocated_angles(::proto::dota::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEPhysicsProp.angles)
}

// optional fixed32 skin = 4;
inline bool CMsgTEPhysicsProp::has_skin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_skin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEPhysicsProp::clear_has_skin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEPhysicsProp::clear_skin() {
  skin_ = 0u;
  clear_has_skin();
}
inline ::google::protobuf::uint32 CMsgTEPhysicsProp::skin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.skin)
  return skin_;
}
inline void CMsgTEPhysicsProp::set_skin(::google::protobuf::uint32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.skin)
}

// optional uint32 flags = 5;
inline bool CMsgTEPhysicsProp::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgTEPhysicsProp::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgTEPhysicsProp::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgTEPhysicsProp::flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.flags)
  return flags_;
}
inline void CMsgTEPhysicsProp::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.flags)
}

// optional uint32 effects = 6;
inline bool CMsgTEPhysicsProp::has_effects() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_effects() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgTEPhysicsProp::clear_has_effects() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgTEPhysicsProp::clear_effects() {
  effects_ = 0u;
  clear_has_effects();
}
inline ::google::protobuf::uint32 CMsgTEPhysicsProp::effects() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.effects)
  return effects_;
}
inline void CMsgTEPhysicsProp::set_effects(::google::protobuf::uint32 value) {
  set_has_effects();
  effects_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.effects)
}

// optional fixed32 color = 7;
inline bool CMsgTEPhysicsProp::has_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgTEPhysicsProp::clear_has_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgTEPhysicsProp::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CMsgTEPhysicsProp::color() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.color)
  return color_;
}
inline void CMsgTEPhysicsProp::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.color)
}

// optional fixed64 modelindex = 8;
inline bool CMsgTEPhysicsProp::has_modelindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_modelindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgTEPhysicsProp::clear_has_modelindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgTEPhysicsProp::clear_modelindex() {
  modelindex_ = GOOGLE_ULONGLONG(0);
  clear_has_modelindex();
}
inline ::google::protobuf::uint64 CMsgTEPhysicsProp::modelindex() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.modelindex)
  return modelindex_;
}
inline void CMsgTEPhysicsProp::set_modelindex(::google::protobuf::uint64 value) {
  set_has_modelindex();
  modelindex_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.modelindex)
}

// optional uint32 breakmodelsnottomake = 9;
inline bool CMsgTEPhysicsProp::has_breakmodelsnottomake() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_breakmodelsnottomake() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgTEPhysicsProp::clear_has_breakmodelsnottomake() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgTEPhysicsProp::clear_breakmodelsnottomake() {
  breakmodelsnottomake_ = 0u;
  clear_has_breakmodelsnottomake();
}
inline ::google::protobuf::uint32 CMsgTEPhysicsProp::breakmodelsnottomake() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.breakmodelsnottomake)
  return breakmodelsnottomake_;
}
inline void CMsgTEPhysicsProp::set_breakmodelsnottomake(::google::protobuf::uint32 value) {
  set_has_breakmodelsnottomake();
  breakmodelsnottomake_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.breakmodelsnottomake)
}

// optional float scale = 10;
inline bool CMsgTEPhysicsProp::has_scale() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgTEPhysicsProp::set_has_scale() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgTEPhysicsProp::clear_has_scale() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgTEPhysicsProp::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float CMsgTEPhysicsProp::scale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPhysicsProp.scale)
  return scale_;
}
inline void CMsgTEPhysicsProp::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPhysicsProp.scale)
}

// -------------------------------------------------------------------

// CMsgTEPlayerDecal

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEPlayerDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEPlayerDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEPlayerDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEPlayerDecal::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEPlayerDecal::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPlayerDecal.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEPlayerDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEPlayerDecal.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEPlayerDecal::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEPlayerDecal.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEPlayerDecal::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEPlayerDecal.origin)
}

// optional uint32 player = 2;
inline bool CMsgTEPlayerDecal::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEPlayerDecal::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEPlayerDecal::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEPlayerDecal::clear_player() {
  player_ = 0u;
  clear_has_player();
}
inline ::google::protobuf::uint32 CMsgTEPlayerDecal::player() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPlayerDecal.player)
  return player_;
}
inline void CMsgTEPlayerDecal::set_player(::google::protobuf::uint32 value) {
  set_has_player();
  player_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPlayerDecal.player)
}

// optional uint32 entity = 3;
inline bool CMsgTEPlayerDecal::has_entity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEPlayerDecal::set_has_entity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEPlayerDecal::clear_has_entity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEPlayerDecal::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
inline ::google::protobuf::uint32 CMsgTEPlayerDecal::entity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEPlayerDecal.entity)
  return entity_;
}
inline void CMsgTEPlayerDecal::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEPlayerDecal.entity)
}

// -------------------------------------------------------------------

// CMsgTEProjectedDecal

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEProjectedDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEProjectedDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEProjectedDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEProjectedDecal::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEProjectedDecal::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEProjectedDecal.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEProjectedDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEProjectedDecal.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEProjectedDecal::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEProjectedDecal.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEProjectedDecal::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEProjectedDecal.origin)
}

// optional .proto.dota.CMsgQAngle angles = 2;
inline bool CMsgTEProjectedDecal::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEProjectedDecal::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEProjectedDecal::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEProjectedDecal::clear_angles() {
  if (angles_ != NULL) angles_->::proto::dota::CMsgQAngle::Clear();
  clear_has_angles();
}
inline const ::proto::dota::CMsgQAngle& CMsgTEProjectedDecal::angles() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEProjectedDecal.angles)
  return angles_ != NULL ? *angles_
                         : *::proto::dota::CMsgQAngle::internal_default_instance();
}
inline ::proto::dota::CMsgQAngle* CMsgTEProjectedDecal::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::proto::dota::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEProjectedDecal.angles)
  return angles_;
}
inline ::proto::dota::CMsgQAngle* CMsgTEProjectedDecal::release_angles() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEProjectedDecal.angles)
  clear_has_angles();
  ::proto::dota::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void CMsgTEProjectedDecal::set_allocated_angles(::proto::dota::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEProjectedDecal.angles)
}

// optional uint32 index = 3;
inline bool CMsgTEProjectedDecal::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEProjectedDecal::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEProjectedDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEProjectedDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CMsgTEProjectedDecal::index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEProjectedDecal.index)
  return index_;
}
inline void CMsgTEProjectedDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEProjectedDecal.index)
}

// optional float distance = 4;
inline bool CMsgTEProjectedDecal::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTEProjectedDecal::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTEProjectedDecal::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTEProjectedDecal::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float CMsgTEProjectedDecal::distance() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEProjectedDecal.distance)
  return distance_;
}
inline void CMsgTEProjectedDecal::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEProjectedDecal.distance)
}

// -------------------------------------------------------------------

// CMsgTESmoke

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTESmoke::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTESmoke::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTESmoke::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTESmoke::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTESmoke::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTESmoke.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTESmoke::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTESmoke.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTESmoke::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTESmoke.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTESmoke::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTESmoke.origin)
}

// optional float scale = 2;
inline bool CMsgTESmoke::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTESmoke::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTESmoke::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTESmoke::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float CMsgTESmoke::scale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTESmoke.scale)
  return scale_;
}
inline void CMsgTESmoke::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTESmoke.scale)
}

// -------------------------------------------------------------------

// CMsgTEWorldDecal

// optional .proto.dota.CMsgVector origin = 1;
inline bool CMsgTEWorldDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTEWorldDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTEWorldDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTEWorldDecal::clear_origin() {
  if (origin_ != NULL) origin_->::proto::dota::CMsgVector::Clear();
  clear_has_origin();
}
inline const ::proto::dota::CMsgVector& CMsgTEWorldDecal::origin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEWorldDecal.origin)
  return origin_ != NULL ? *origin_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEWorldDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEWorldDecal.origin)
  return origin_;
}
inline ::proto::dota::CMsgVector* CMsgTEWorldDecal::release_origin() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEWorldDecal.origin)
  clear_has_origin();
  ::proto::dota::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void CMsgTEWorldDecal::set_allocated_origin(::proto::dota::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEWorldDecal.origin)
}

// optional .proto.dota.CMsgVector normal = 2;
inline bool CMsgTEWorldDecal::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTEWorldDecal::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTEWorldDecal::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTEWorldDecal::clear_normal() {
  if (normal_ != NULL) normal_->::proto::dota::CMsgVector::Clear();
  clear_has_normal();
}
inline const ::proto::dota::CMsgVector& CMsgTEWorldDecal::normal() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEWorldDecal.normal)
  return normal_ != NULL ? *normal_
                         : *::proto::dota::CMsgVector::internal_default_instance();
}
inline ::proto::dota::CMsgVector* CMsgTEWorldDecal::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::proto::dota::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgTEWorldDecal.normal)
  return normal_;
}
inline ::proto::dota::CMsgVector* CMsgTEWorldDecal::release_normal() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgTEWorldDecal.normal)
  clear_has_normal();
  ::proto::dota::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void CMsgTEWorldDecal::set_allocated_normal(::proto::dota::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgTEWorldDecal.normal)
}

// optional uint32 index = 3;
inline bool CMsgTEWorldDecal::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTEWorldDecal::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTEWorldDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTEWorldDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CMsgTEWorldDecal::index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgTEWorldDecal.index)
  return index_;
}
inline void CMsgTEWorldDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgTEWorldDecal.index)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dota
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::dota::ETEProtobufIds> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::ETEProtobufIds>() {
  return ::proto::dota::ETEProtobufIds_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_te_2eproto__INCLUDED
